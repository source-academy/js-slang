// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`These tests are reporting weird line numbers, as list functions are now implemented in Source. bad index error list_ref: expectParsedError 1`] = `
Object {
  "alertResult": Array [],
  "code": "list_ref(list(1, 2, 3), 3);",
  "displayResult": Array [],
  "errors": Array [
    ExceptionError {
      "error": [Error: head(xs) expects a pair as argument xs, but encountered null],
      "location": SourceLocation {
        "end": Position {
          "column": 27,
          "line": 157,
        },
        "start": Position {
          "column": 19,
          "line": 157,
        },
      },
      "severity": "Error",
      "type": "Runtime",
    },
  ],
  "parsedErrors": "Line 157: Error: head(xs) expects a pair as argument xs, but encountered null",
  "result": undefined,
  "resultStatus": "error",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(list_ref, 1, 0, callIfFuncAndRightArgs(list, 1, 9, 1, 2, 3), 3);\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`These tests are reporting weird line numbers, as list functions are now implemented in Source. bad index error list_ref: expectParsedError 2`] = `
Object {
  "alertResult": Array [],
  "code": "list_ref(list(1, 2, 3), -1);",
  "displayResult": Array [],
  "errors": Array [
    ExceptionError {
      "error": [Error: tail(xs) expects a pair as argument xs, but encountered null],
      "location": SourceLocation {
        "end": Position {
          "column": 47,
          "line": 157,
        },
        "start": Position {
          "column": 39,
          "line": 157,
        },
      },
      "severity": "Error",
      "type": "Runtime",
    },
  ],
  "parsedErrors": "Line 157: Error: tail(xs) expects a pair as argument xs, but encountered null",
  "result": undefined,
  "resultStatus": "error",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(list_ref, 1, 0, callIfFuncAndRightArgs(list, 1, 9, 1, 2, 3), unaryOp(\\\\\\"-\\\\\\", 1, 1, 24));\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`These tests are reporting weird line numbers, as list functions are now implemented in Source. bad index error list_ref: expectParsedError 3`] = `
Object {
  "alertResult": Array [],
  "code": "list_ref(list(1, 2, 3), 1.5);",
  "displayResult": Array [],
  "errors": Array [
    ExceptionError {
      "error": [Error: tail(xs) expects a pair as argument xs, but encountered null],
      "location": SourceLocation {
        "end": Position {
          "column": 47,
          "line": 157,
        },
        "start": Position {
          "column": 39,
          "line": 157,
        },
      },
      "severity": "Error",
      "type": "Runtime",
    },
  ],
  "parsedErrors": "Line 157: Error: tail(xs) expects a pair as argument xs, but encountered null",
  "result": undefined,
  "resultStatus": "error",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(list_ref, 1, 0, callIfFuncAndRightArgs(list, 1, 9, 1, 2, 3), 1.5);\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`These tests are reporting weird line numbers, as list functions are now implemented in Source. bad index error list_ref: expectParsedError 4`] = `
Object {
  "alertResult": Array [],
  "code": "list_ref(list(1, 2, 3), '1');",
  "displayResult": Array [],
  "errors": Array [
    TypeError {
      "expected": "string",
      "got": "number",
      "location": SourceLocation {
        "end": Position {
          "column": 16,
          "line": 157,
        },
        "start": Position {
          "column": 9,
          "line": 157,
        },
      },
      "severity": "Error",
      "side": " on right hand side of operation",
      "type": "Runtime",
    },
  ],
  "parsedErrors": "Line 157: Expected string on right hand side of operation, got number.",
  "result": undefined,
  "resultStatus": "error",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(list_ref, 1, 0, callIfFuncAndRightArgs(list, 1, 9, 1, 2, 3), '1');\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`These tests are reporting weird line numbers, as list functions are now implemented in Source. bad number error build_list: expectParsedError 1`] = `
Object {
  "alertResult": Array [],
  "code": "build_list('1', x => x);",
  "displayResult": Array [],
  "errors": Array [
    TypeError {
      "expected": "number",
      "got": "string",
      "location": SourceLocation {
        "end": Position {
          "column": 20,
          "line": 55,
        },
        "start": Position {
          "column": 15,
          "line": 55,
        },
      },
      "severity": "Error",
      "side": " on left hand side of operation",
      "type": "Runtime",
    },
  ],
  "parsedErrors": "Line 55: Expected number on left hand side of operation, got string.",
  "result": undefined,
  "resultStatus": "error",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(build_list, 1, 0, '1', wrap(x => ({   isTail: false,   value: x }), \\\\\\"x => x\\\\\\", native));\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`These tests are reporting weird line numbers, as list functions are now implemented in Source. bad number error enum_list: expectParsedError 1`] = `
Object {
  "alertResult": Array [],
  "code": "enum_list('1', '5');",
  "displayResult": Array [],
  "errors": Array [
    TypeError {
      "expected": "string",
      "got": "number",
      "location": SourceLocation {
        "end": Position {
          "column": 61,
          "line": 149,
        },
        "start": Position {
          "column": 52,
          "line": 149,
        },
      },
      "severity": "Error",
      "side": " on right hand side of operation",
      "type": "Runtime",
    },
  ],
  "parsedErrors": "Line 149: Expected string on right hand side of operation, got number.",
  "result": undefined,
  "resultStatus": "error",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(enum_list, 1, 0, '1', '5');\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`These tests are reporting weird line numbers, as list functions are now implemented in Source. bad number error enum_list: expectParsedError 2`] = `
Object {
  "alertResult": Array [],
  "code": "enum_list('1', 5);",
  "displayResult": Array [],
  "errors": Array [
    TypeError {
      "expected": "string",
      "got": "number",
      "location": SourceLocation {
        "end": Position {
          "column": 20,
          "line": 149,
        },
        "start": Position {
          "column": 9,
          "line": 149,
        },
      },
      "severity": "Error",
      "side": " on right hand side of operation",
      "type": "Runtime",
    },
  ],
  "parsedErrors": "Line 149: Expected string on right hand side of operation, got number.",
  "result": undefined,
  "resultStatus": "error",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(enum_list, 1, 0, '1', 5);\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`These tests are reporting weird line numbers, as list functions are now implemented in Source. bad number error enum_list: expectParsedError 3`] = `
Object {
  "alertResult": Array [],
  "code": "enum_list(1, '5');",
  "displayResult": Array [],
  "errors": Array [
    TypeError {
      "expected": "number",
      "got": "string",
      "location": SourceLocation {
        "end": Position {
          "column": 20,
          "line": 149,
        },
        "start": Position {
          "column": 9,
          "line": 149,
        },
      },
      "severity": "Error",
      "side": " on right hand side of operation",
      "type": "Runtime",
    },
  ],
  "parsedErrors": "Line 149: Expected number on right hand side of operation, got string.",
  "result": undefined,
  "resultStatus": "error",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(enum_list, 1, 0, 1, '5');\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`These tests are reporting weird line numbers, as list functions are now implemented in Source. non-list error accumulate: expectParsedError 1`] = `
Object {
  "alertResult": Array [],
  "code": "accumulate((x, y) => x + y, [1, 2, 3]);",
  "displayResult": Array [],
  "errors": Array [
    InvalidNumberOfArguments {
      "calleeStr": "accumulate",
      "expected": 3,
      "got": 2,
      "location": SourceLocation {
        "end": Position {
          "column": 38,
          "line": 1,
        },
        "start": Position {
          "column": 0,
          "line": 1,
        },
      },
      "severity": "Error",
      "type": "Runtime",
    },
  ],
  "parsedErrors": "Line 1: Expected 3 arguments, but got 2.",
  "result": undefined,
  "resultStatus": "error",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(accumulate, 1, 0, wrap((x, y) => ({   isTail: false,   value: binaryOp(\\\\\\"+\\\\\\", 3, x, y, 1, 21) }), \\\\\\"(x, y) => x + y\\\\\\", native), [1, 2, 3]);\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`These tests are reporting weird line numbers, as list functions are now implemented in Source. non-list error accumulate: expectParsedError 2`] = `
Object {
  "alertResult": Array [],
  "code": "accumulate((x, y) => x + y, [1, 2, 3]);",
  "displayResult": Array [],
  "errors": Array [
    InvalidNumberOfArguments {
      "calleeStr": "accumulate",
      "expected": 3,
      "got": 2,
      "location": SourceLocation {
        "end": Position {
          "column": 38,
          "line": 1,
        },
        "start": Position {
          "column": 0,
          "line": 1,
        },
      },
      "severity": "Error",
      "type": "Runtime",
    },
  ],
  "parsedErrors": "Line 1: Expected 3 arguments, but got 2.",
  "result": undefined,
  "resultStatus": "error",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(accumulate, 1, 0, wrap((x, y) => ({   isTail: false,   value: binaryOp(\\\\\\"+\\\\\\", 3, x, y, 1, 21) }), \\\\\\"(x, y) => x + y\\\\\\", native), [1, 2, 3]);\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`These tests are reporting weird line numbers, as list functions are now implemented in Source. non-list error append: expectParsedError 1`] = `
Object {
  "alertResult": Array [],
  "code": "append([1, 2, 3], list(1, 2, 3));",
  "displayResult": Array [],
  "errors": Array [
    ExceptionError {
      "error": [Error: head(xs) expects a pair as argument xs, but encountered [1, 2, 3]],
      "location": SourceLocation {
        "end": Position {
          "column": 41,
          "line": 101,
        },
        "start": Position {
          "column": 33,
          "line": 101,
        },
      },
      "severity": "Error",
      "type": "Runtime",
    },
  ],
  "parsedErrors": "Line 101: Error: head(xs) expects a pair as argument xs, but encountered [1, 2, 3]",
  "result": undefined,
  "resultStatus": "error",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(append, 1, 0, [1, 2, 3], callIfFuncAndRightArgs(list, 1, 18, 1, 2, 3));\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`These tests are reporting weird line numbers, as list functions are now implemented in Source. non-list error assoc: expectParsedError 1`] = `
Object {
  "alertResult": Array [],
  "code": "assoc(1, [1, 2, 3]);",
  "displayResult": Array [],
  "errors": Array [
    UndefinedVariable {
      "location": SourceLocation {
        "end": Position {
          "column": 5,
          "line": 1,
        },
        "start": Position {
          "column": 0,
          "line": 1,
        },
      },
      "name": "assoc",
      "severity": "Error",
      "type": "Runtime",
    },
  ],
  "parsedErrors": "Line 1: Name assoc not declared.",
  "result": undefined,
  "resultStatus": "error",
  "visualiseListResult": Array [],
}
`;

exports[`These tests are reporting weird line numbers, as list functions are now implemented in Source. non-list error filter: expectParsedError 1`] = `
Object {
  "alertResult": Array [],
  "code": "filter(x => true, [1, 2, 3]);",
  "displayResult": Array [],
  "errors": Array [
    ExceptionError {
      "error": [Error: head(xs) expects a pair as argument xs, but encountered [1, 2, 3]],
      "location": SourceLocation {
        "end": Position {
          "column": 19,
          "line": 139,
        },
        "start": Position {
          "column": 11,
          "line": 139,
        },
      },
      "severity": "Error",
      "type": "Runtime",
    },
  ],
  "parsedErrors": "Line 139: Error: head(xs) expects a pair as argument xs, but encountered [1, 2, 3]",
  "result": undefined,
  "resultStatus": "error",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(filter, 1, 0, wrap(x => ({   isTail: false,   value: true }), \\\\\\"x => true\\\\\\", native), [1, 2, 3]);\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`These tests are reporting weird line numbers, as list functions are now implemented in Source. non-list error for_each: expectParsedError 1`] = `
Object {
  "alertResult": Array [],
  "code": "for_each(x=>x, [1, 2, 3]);",
  "displayResult": Array [],
  "errors": Array [
    ExceptionError {
      "error": [Error: head(xs) expects a pair as argument xs, but encountered [1, 2, 3]],
      "location": SourceLocation {
        "end": Position {
          "column": 16,
          "line": 68,
        },
        "start": Position {
          "column": 8,
          "line": 68,
        },
      },
      "severity": "Error",
      "type": "Runtime",
    },
  ],
  "parsedErrors": "Line 68: Error: head(xs) expects a pair as argument xs, but encountered [1, 2, 3]",
  "result": undefined,
  "resultStatus": "error",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(for_each, 1, 0, wrap(x => ({   isTail: false,   value: x }), \\\\\\"x => x\\\\\\", native), [1, 2, 3]);\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`These tests are reporting weird line numbers, as list functions are now implemented in Source. non-list error length: expectParsedError 1`] = `
Object {
  "alertResult": Array [],
  "code": "length([1, 2, 3]);",
  "displayResult": Array [],
  "errors": Array [
    ExceptionError {
      "error": [Error: tail(xs) expects a pair as argument xs, but encountered [1, 2, 3]],
      "location": SourceLocation {
        "end": Position {
          "column": 46,
          "line": 34,
        },
        "start": Position {
          "column": 38,
          "line": 34,
        },
      },
      "severity": "Error",
      "type": "Runtime",
    },
  ],
  "parsedErrors": "Line 34: Error: tail(xs) expects a pair as argument xs, but encountered [1, 2, 3]",
  "result": undefined,
  "resultStatus": "error",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(length, 1, 0, [1, 2, 3]);\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`These tests are reporting weird line numbers, as list functions are now implemented in Source. non-list error map: expectParsedError 1`] = `
Object {
  "alertResult": Array [],
  "code": "map(x=>x, [1, 2, 3]);",
  "displayResult": Array [],
  "errors": Array [
    ExceptionError {
      "error": [Error: head(xs) expects a pair as argument xs, but encountered [1, 2, 3]],
      "location": SourceLocation {
        "end": Position {
          "column": 45,
          "line": 43,
        },
        "start": Position {
          "column": 37,
          "line": 43,
        },
      },
      "severity": "Error",
      "type": "Runtime",
    },
  ],
  "parsedErrors": "Line 43: Error: head(xs) expects a pair as argument xs, but encountered [1, 2, 3]",
  "result": undefined,
  "resultStatus": "error",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(map, 1, 0, wrap(x => ({   isTail: false,   value: x }), \\\\\\"x => x\\\\\\", native), [1, 2, 3]);\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`These tests are reporting weird line numbers, as list functions are now implemented in Source. non-list error member: expectParsedError 1`] = `
Object {
  "alertResult": Array [],
  "code": "member(1, [1, 2, 3]);",
  "displayResult": Array [],
  "errors": Array [
    ExceptionError {
      "error": [Error: head(xs) expects a pair as argument xs, but encountered [1, 2, 3]],
      "location": SourceLocation {
        "end": Position {
          "column": 44,
          "line": 110,
        },
        "start": Position {
          "column": 36,
          "line": 110,
        },
      },
      "severity": "Error",
      "type": "Runtime",
    },
  ],
  "parsedErrors": "Line 110: Error: head(xs) expects a pair as argument xs, but encountered [1, 2, 3]",
  "result": undefined,
  "resultStatus": "error",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(member, 1, 0, 1, [1, 2, 3]);\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`These tests are reporting weird line numbers, as list functions are now implemented in Source. non-list error remove: expectParsedError 1`] = `
Object {
  "alertResult": Array [],
  "code": "remove(1, [1, 2, 3]);",
  "displayResult": Array [],
  "errors": Array [
    ExceptionError {
      "error": [Error: head(xs) expects a pair as argument xs, but encountered [1, 2, 3]],
      "location": SourceLocation {
        "end": Position {
          "column": 44,
          "line": 118,
        },
        "start": Position {
          "column": 36,
          "line": 118,
        },
      },
      "severity": "Error",
      "type": "Runtime",
    },
  ],
  "parsedErrors": "Line 118: Error: head(xs) expects a pair as argument xs, but encountered [1, 2, 3]",
  "result": undefined,
  "resultStatus": "error",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(remove, 1, 0, 1, [1, 2, 3]);\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`These tests are reporting weird line numbers, as list functions are now implemented in Source. non-list error remove_all: expectParsedError 1`] = `
Object {
  "alertResult": Array [],
  "code": "remove_all(1, [1, 2, 3]);",
  "displayResult": Array [],
  "errors": Array [
    ExceptionError {
      "error": [Error: head(xs) expects a pair as argument xs, but encountered [1, 2, 3]],
      "location": SourceLocation {
        "end": Position {
          "column": 20,
          "line": 127,
        },
        "start": Position {
          "column": 12,
          "line": 127,
        },
      },
      "severity": "Error",
      "type": "Runtime",
    },
  ],
  "parsedErrors": "Line 127: Error: head(xs) expects a pair as argument xs, but encountered [1, 2, 3]",
  "result": undefined,
  "resultStatus": "error",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(remove_all, 1, 0, 1, [1, 2, 3]);\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`These tests are reporting weird line numbers, as list functions are now implemented in Source. non-list error reverse: expectParsedError 1`] = `
Object {
  "alertResult": Array [],
  "code": "reverse([1, 2, 3]);",
  "displayResult": Array [],
  "errors": Array [
    ExceptionError {
      "error": [Error: tail(xs) expects a pair as argument xs, but encountered [1, 2, 3]],
      "location": SourceLocation {
        "end": Position {
          "column": 60,
          "line": 90,
        },
        "start": Position {
          "column": 46,
          "line": 90,
        },
      },
      "severity": "Error",
      "type": "Runtime",
    },
  ],
  "parsedErrors": "Line 90: Error: tail(xs) expects a pair as argument xs, but encountered [1, 2, 3]",
  "result": undefined,
  "resultStatus": "error",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(reverse, 1, 0, [1, 2, 3]);\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`These tests are reporting weird line numbers, as list functions are now implemented in Source. non-list error set_head: expectParsedError 1`] = `
Object {
  "alertResult": Array [],
  "code": "set_head([1, 2, 3], 4);",
  "displayResult": Array [],
  "errors": Array [
    ExceptionError {
      "error": [Error: set_head(xs,x) expects a pair as argument xs, but encountered [1, 2, 3]],
      "location": SourceLocation {
        "end": Position {
          "column": 22,
          "line": 1,
        },
        "start": Position {
          "column": 0,
          "line": 1,
        },
      },
      "severity": "Error",
      "type": "Runtime",
    },
  ],
  "parsedErrors": "Line 1: Error: set_head(xs,x) expects a pair as argument xs, but encountered [1, 2, 3]",
  "result": undefined,
  "resultStatus": "error",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(set_head, 1, 0, [1, 2, 3], 4);\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`These tests are reporting weird line numbers, as list functions are now implemented in Source. non-list error set_tail: expectParsedError 1`] = `
Object {
  "alertResult": Array [],
  "code": "set_tail([1, 2, 3], 4);",
  "displayResult": Array [],
  "errors": Array [
    ExceptionError {
      "error": [Error: set_tail(xs,x) expects a pair as argument xs, but encountered [1, 2, 3]],
      "location": SourceLocation {
        "end": Position {
          "column": 22,
          "line": 1,
        },
        "start": Position {
          "column": 0,
          "line": 1,
        },
      },
      "severity": "Error",
      "type": "Runtime",
    },
  ],
  "parsedErrors": "Line 1: Error: set_tail(xs,x) expects a pair as argument xs, but encountered [1, 2, 3]",
  "result": undefined,
  "resultStatus": "error",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(set_tail, 1, 0, [1, 2, 3], 4);\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`accumulate: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "accumulate((curr, acc) => curr + acc, 0, list(2, 3, 4, 1));",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": 10,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(accumulate, 1, 0, wrap((curr, acc) => ({   isTail: false,   value: binaryOp(\\\\\\"+\\\\\\", 2, curr, acc, 1, 26) }), \\\\\\"(curr, acc) => curr + acc\\\\\\", native), 0, callIfFuncAndRightArgs(list, 1, 41, 2, 3, 4, 1));\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`append: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "equal(append(list(123, 123), list(456, 456, 456)), list(123, 123, 456, 456, 456));",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": true,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(equal, 1, 0, callIfFuncAndRightArgs(append, 1, 6, callIfFuncAndRightArgs(list, 1, 13, 123, 123), callIfFuncAndRightArgs(list, 1, 29, 456, 456, 456)), callIfFuncAndRightArgs(list, 1, 51, 123, 123, 456, 456, 456));\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`build_list: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "equal(build_list(5, x => x * x), list(0, 1, 4, 9, 16));",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": true,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(equal, 1, 0, callIfFuncAndRightArgs(build_list, 1, 6, 5, wrap(x => ({   isTail: false,   value: binaryOp(\\\\\\"*\\\\\\", 2, x, x, 1, 25) }), \\\\\\"x => x * x\\\\\\", native)), callIfFuncAndRightArgs(list, 1, 33, 0, 1, 4, 9, 16));\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`empty list is null: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "list();",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": null,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(list, 1, 0);\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`enum_list with floats: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "equal(enum_list(1.5, 5), list(1.5, 2.5, 3.5, 4.5));",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": true,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(equal, 1, 0, callIfFuncAndRightArgs(enum_list, 1, 6, 1.5, 5), callIfFuncAndRightArgs(list, 1, 25, 1.5, 2.5, 3.5, 4.5));\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`enum_list: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "equal(enum_list(1, 5), list(1, 2, 3, 4, 5));",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": true,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(equal, 1, 0, callIfFuncAndRightArgs(enum_list, 1, 6, 1, 5), callIfFuncAndRightArgs(list, 1, 23, 1, 2, 3, 4, 5));\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`filter: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "equal(filter(x => x <= 4, list(2, 10, 1000, 1, 3, 100, 4, 5, 2, 1000)), list(2, 1, 3, 4, 2));",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": true,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(equal, 1, 0, callIfFuncAndRightArgs(filter, 1, 6, wrap(x => ({   isTail: false,   value: binaryOp(\\\\\\"<=\\\\\\", 2, x, 4, 1, 18) }), \\\\\\"x => x <= 4\\\\\\", native), callIfFuncAndRightArgs(list, 1, 26, 2, 10, 1000, 1, 3, 100, 4, 5, 2, 1000)), callIfFuncAndRightArgs(list, 1, 72, 2, 1, 3, 4, 2));\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`for_each: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "let sum = 0;
for_each(x => {
  sum = sum + x;
}, list(1, 2, 3));
sum;",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": 6,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    let sum = 0;
    callIfFuncAndRightArgs(for_each, 2, 0, wrap(x => {
      sum = binaryOp(\\"+\\", 3, sum, x, 3, 8);
    }, \\"x => {\\\\n  sum = sum + x;\\\\n}\\", native), callIfFuncAndRightArgs(list, 4, 3, 1, 2, 3));
    lastStatementResult = eval(\\"sum;\\");
    globals.variables.set(\\"sum\\", {
      kind: \\"let\\",
      getValue: () => {
        return sum;
      },
      assignNewValue: function (unique) {
        return sum = unique;
      }
    });
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`head works: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "head(pair(1, 'a string \\"\\"'));",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": 1,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(head, 1, 0, callIfFuncAndRightArgs(pair, 1, 5, 1, 'a string \\\\\\"\\\\\\"'));\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`list creates list: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "function f() { return 1; }
list(1, 'a string \\"\\"', () => f, f, true, 3.14);",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": Array [
    1,
    Array [
      "a string \\"\\"",
      Array [
        [Function],
        Array [
          [Function],
          Array [
            true,
            Array [
              3.14,
              null,
            ],
          ],
        ],
      ],
    ],
  ],
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    const f = wrap(() => {
      return {
        isTail: false,
        value: 1
      };
    }, \\"function f() {\\\\n  return 1;\\\\n}\\", native);
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(list, 2, 0, 1, 'a string \\\\\\"\\\\\\"', wrap(() => ({   isTail: false,   value: f }), \\\\\\"() => f\\\\\\", native), f, true, 3.14);\\");
    globals.variables.set(\\"f\\", {
      kind: \\"const\\",
      getValue: () => {
        return f;
      }
    });
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`list_ref: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "list_ref(list(1, 2, 3, \\"4\\", 4), 4);",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": 4,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(list_ref, 1, 0, callIfFuncAndRightArgs(list, 1, 9, 1, 2, 3, \\\\\\"4\\\\\\", 4), 4);\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`list_to_string: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "list_to_string(list(1, 2, 3));",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": "[1,[2,[3,null]]]",
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(list_to_string, 1, 0, callIfFuncAndRightArgs(list, 1, 15, 1, 2, 3));\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`map: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "equal(map(x => 2 * x, list(12, 11, 3)), list(24, 22, 6));",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": true,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(equal, 1, 0, callIfFuncAndRightArgs(map, 1, 6, wrap(x => ({   isTail: false,   value: binaryOp(\\\\\\"*\\\\\\", 2, 2, x, 1, 15) }), \\\\\\"x => 2 * x\\\\\\", native), callIfFuncAndRightArgs(list, 1, 22, 12, 11, 3)), callIfFuncAndRightArgs(list, 1, 40, 24, 22, 6));\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`member: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "equal(
  member(4, list(1, 2, 3, 4, 123, 456, 789)),
  list(4, 123, 456, 789));",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": true,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(equal, 1, 0, callIfFuncAndRightArgs(member, 2, 2, 4, callIfFuncAndRightArgs(list, 2, 12, 1, 2, 3, 4, 123, 456, 789)), callIfFuncAndRightArgs(list, 3, 2, 4, 123, 456, 789));\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`non-list error head: expectParsedError 1`] = `
Object {
  "alertResult": Array [],
  "code": "head([1, 2, 3]);",
  "displayResult": Array [],
  "errors": Array [
    ExceptionError {
      "error": [Error: head(xs) expects a pair as argument xs, but encountered [1, 2, 3]],
      "location": SourceLocation {
        "end": Position {
          "column": 15,
          "line": 1,
        },
        "start": Position {
          "column": 0,
          "line": 1,
        },
      },
      "severity": "Error",
      "type": "Runtime",
    },
  ],
  "parsedErrors": "Line 1: Error: head(xs) expects a pair as argument xs, but encountered [1, 2, 3]",
  "result": undefined,
  "resultStatus": "error",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(head, 1, 0, [1, 2, 3]);\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`non-list error tail: expectParsedError 1`] = `
Object {
  "alertResult": Array [],
  "code": "tail([1, 2, 3]);",
  "displayResult": Array [],
  "errors": Array [
    ExceptionError {
      "error": [Error: tail(xs) expects a pair as argument xs, but encountered [1, 2, 3]],
      "location": SourceLocation {
        "end": Position {
          "column": 15,
          "line": 1,
        },
        "start": Position {
          "column": 0,
          "line": 1,
        },
      },
      "severity": "Error",
      "type": "Runtime",
    },
  ],
  "parsedErrors": "Line 1: Error: tail(xs) expects a pair as argument xs, but encountered [1, 2, 3]",
  "result": undefined,
  "resultStatus": "error",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(tail, 1, 0, [1, 2, 3]);\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`pair creates pair: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "pair(1, 'a string \\"\\"');",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": Array [
    1,
    "a string \\"\\"",
  ],
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(pair, 1, 0, 1, 'a string \\\\\\"\\\\\\"');\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`remove not found: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "remove(2, list(1));",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": Array [
    1,
    null,
  ],
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(remove, 1, 0, 2, callIfFuncAndRightArgs(list, 1, 10, 1));\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`remove: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "remove(1, list(1));",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": null,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(remove, 1, 0, 1, callIfFuncAndRightArgs(list, 1, 10, 1));\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`remove_all not found: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "equal(remove_all(1, list(2, 3, 4)), list(2, 3, 4));",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": true,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(equal, 1, 0, callIfFuncAndRightArgs(remove_all, 1, 6, 1, callIfFuncAndRightArgs(list, 1, 20, 2, 3, 4)), callIfFuncAndRightArgs(list, 1, 36, 2, 3, 4));\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`remove_all: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "equal(remove_all(1, list(1, 2, 3, 4, 1, 1, 1, 5, 1, 1, 6)), list(2, 3, 4, 5, 6));",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": true,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(equal, 1, 0, callIfFuncAndRightArgs(remove_all, 1, 6, 1, callIfFuncAndRightArgs(list, 1, 20, 1, 2, 3, 4, 1, 1, 1, 5, 1, 1, 6)), callIfFuncAndRightArgs(list, 1, 60, 2, 3, 4, 5, 6));\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`reverse: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "equal(reverse(list(\\"string\\", \\"null\\", \\"undefined\\", \\"null\\", 123)), list(123, \\"null\\", \\"undefined\\", \\"null\\", \\"string\\"));",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": true,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(equal, 1, 0, callIfFuncAndRightArgs(reverse, 1, 6, callIfFuncAndRightArgs(list, 1, 14, \\\\\\"string\\\\\\", \\\\\\"null\\\\\\", \\\\\\"undefined\\\\\\", \\\\\\"null\\\\\\", 123)), callIfFuncAndRightArgs(list, 1, 65, 123, \\\\\\"null\\\\\\", \\\\\\"undefined\\\\\\", \\\\\\"null\\\\\\", \\\\\\"string\\\\\\"));\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`set_head: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "let p = pair(1, 2);
const q = p;
set_head(p, 3);
p === q && equal(p, pair(3, 2));",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": true,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    let p = callIfFuncAndRightArgs(pair, 1, 8, 1, 2);
    const q = p;
    callIfFuncAndRightArgs(set_head, 3, 0, p, 3);
    lastStatementResult = eval(\\"boolOrErr(binaryOp(\\\\\\"===\\\\\\", 3, p, q, 4, 0), 4, 0) && callIfFuncAndRightArgs(equal, 4, 11, p, callIfFuncAndRightArgs(pair, 4, 20, 3, 2));\\");
    globals.variables.set(\\"p\\", {
      kind: \\"let\\",
      getValue: () => {
        return p;
      },
      assignNewValue: function (unique) {
        return p = unique;
      }
    });
    globals.variables.set(\\"q\\", {
      kind: \\"const\\",
      getValue: () => {
        return q;
      }
    });
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`set_tail: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "let p = pair(1, 2);
const q = p;
set_tail(p, 3);
p === q && equal(p, pair(1, 3));",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": true,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    let p = callIfFuncAndRightArgs(pair, 1, 8, 1, 2);
    const q = p;
    callIfFuncAndRightArgs(set_tail, 3, 0, p, 3);
    lastStatementResult = eval(\\"boolOrErr(binaryOp(\\\\\\"===\\\\\\", 3, p, q, 4, 0), 4, 0) && callIfFuncAndRightArgs(equal, 4, 11, p, callIfFuncAndRightArgs(pair, 4, 20, 1, 3));\\");
    globals.variables.set(\\"p\\", {
      kind: \\"let\\",
      getValue: () => {
        return p;
      },
      assignNewValue: function (unique) {
        return p = unique;
      }
    });
    globals.variables.set(\\"q\\", {
      kind: \\"const\\",
      getValue: () => {
        return q;
      }
    });
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`tail of a 1 element list is null: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "tail(list(1));",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": null,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(tail, 1, 0, callIfFuncAndRightArgs(list, 1, 5, 1));\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`tail works: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "tail(pair(1, 'a string \\"\\"'));",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": "a string \\"\\"",
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const __createKernel = native.operators.get(\\"__createKernel\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(tail, 1, 0, callIfFuncAndRightArgs(pair, 1, 5, 1, 'a string \\\\\\"\\\\\\"'));\\");
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

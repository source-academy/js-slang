import es from 'estree'

import { accessExportFunctionName } from '../stdlib/localImport.prelude'

// Note that typecasting is done on some of the constructed AST nodes because
// the ESTree AST node types are not fully aligned with the actual AST that
// is generated by the Acorn parser. However, the extra/missing properties
// are unused in the Source interpreter/transpiler. As such, we can safely
// ignore their existence to make the typing cleaner. The alternative would
// be to define our own AST node types based off the ESTree AST node types
// and use our custom AST node types everywhere.

export const createLiteral = (
  value: string | number | boolean | null,
  raw?: string
): es.Literal => {
  return {
    type: 'Literal',
    value,
    raw: raw ?? typeof value === 'string' ? `"${value}"` : String(value)
  }
}

export const createIdentifier = (name: string): es.Identifier => {
  return {
    type: 'Identifier',
    name
  }
}

export const createCallExpression = (
  functionName: string,
  functionArguments: Array<es.Expression | es.SpreadElement>
): es.SimpleCallExpression => {
  return {
    type: 'CallExpression',
    callee: createIdentifier(functionName),
    arguments: functionArguments
    // The 'optional' property is typed in ESTree, but does not exist
    // on SimpleCallExpression nodes in the AST generated by acorn parser.
  } as es.SimpleCallExpression
}

export const createPairCallExpression = (
  head: es.Expression | es.SpreadElement,
  tail: es.Expression | es.SpreadElement
): es.SimpleCallExpression => {
  return createCallExpression('pair', [head, tail])
}

export const createListCallExpression = (
  listElements: Array<es.Expression | es.SpreadElement>
): es.SimpleCallExpression => {
  return createCallExpression('list', listElements)
}

export const createImportedNameDeclaration = (
  functionName: string,
  importedName: es.Identifier
): es.VariableDeclaration => {
  const callExpression = createCallExpression(accessExportFunctionName, [
    createIdentifier(functionName),
    createLiteral(importedName.name)
  ])
  const variableDeclarator: es.VariableDeclarator = {
    type: 'VariableDeclarator',
    id: importedName,
    init: callExpression
  }
  return {
    type: 'VariableDeclaration',
    declarations: [variableDeclarator],
    kind: 'const'
  }
}

export const createReturnStatement = (
  argument: es.Expression | null | undefined
): es.ReturnStatement => {
  return {
    type: 'ReturnStatement',
    argument
  }
}

export const createFunctionDeclaration = (
  name: string,
  params: es.Pattern[],
  body: es.Statement[]
): es.FunctionDeclaration => {
  return {
    type: 'FunctionDeclaration',
    expression: false,
    generator: false,
    id: {
      type: 'Identifier',
      name
    },
    params,
    body: {
      type: 'BlockStatement',
      body
    }
    // The 'expression' property is not typed in ESTree, but it exists
    // on FunctionDeclaration nodes in the AST generated by acorn parser.
  } as es.FunctionDeclaration
}

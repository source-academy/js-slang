import es from 'estree'

import { mockContext } from '../../mocks/context'
import { parse } from '../../parser/parser'
import { Chapter } from '../../types'
import { full } from '../../utils/walkers'
import { transformImportedFile } from '../transformer'

let actualContext = mockContext(Chapter.SOURCE_2)
let expectedContext = mockContext(Chapter.SOURCE_2)
const parseError = new Error('Unable to parse code')

// This test suite only cares about the structure of the transformed AST.
// The line & column numbers, as well as the character offsets of each node in
// the ASTs derived from parsing the pre-transform code & the equivalent
// post-transform code will not be the same.
// Note that it is insufficient to pass in 'locations: false' into the acorn
// parser as there will still be 'start' & 'end' properties attached to nodes
// which represent character offsets.
//
// WARNING: Since this function is only used for this test suite, it mutates
// the original AST for convenience instead of creating a copy.
const stripLocationInfo = (node: es.Node): es.Node => {
  // The 'start' & 'end' properties are not typed in ESTree, but they exist
  // on some nodes in the AST generated by acorn parser.
  full(node, (node: es.Node & { start?: number; end?: number }) => {
    // Line & column numbers
    delete node.loc
    // Character offsets
    delete node.start
    delete node.end
  })
  return node
}

beforeEach(() => {
  actualContext = mockContext(Chapter.SOURCE_2)
  expectedContext = mockContext(Chapter.SOURCE_2)
})

describe('transformImportedFile', () => {
  it('wraps the program body in a FunctionDeclaration', () => {
    const iifeIdentifier = 'importedFile'
    const actualCode = `const square = x => x * x;
      const x = 42;
    `
    const expectedCode = `function ${iifeIdentifier}() {
        const square = x => x * x;
        const x = 42;
        return list();
      }
    `

    const actualProgram = parse(actualCode, actualContext)
    const expectedProgram = parse(expectedCode, expectedContext)

    if (actualProgram === undefined || expectedProgram === undefined) {
      throw parseError
    }
    const actualFunctionDeclaration = transformImportedFile(actualProgram, iifeIdentifier)
    const expectedFunctionDeclaration = expectedProgram.body[0]
    expect(expectedFunctionDeclaration.type).toEqual('FunctionDeclaration')
    expect(stripLocationInfo(actualFunctionDeclaration)).toEqual(
      stripLocationInfo(expectedFunctionDeclaration)
    )
  })
})

import es from 'estree'

import { mockContext } from '../../mocks/context'
import { parse } from '../../parser/parser'
import { Chapter } from '../../types'
import { full } from '../../utils/walkers'
import { transformImportedFile } from '../transformer'

// This test suite only cares about the structure of the transformed AST.
// The line & column numbers, as well as the character offsets of each node in
// the ASTs derived from parsing the pre-transform code & the equivalent
// post-transform code will not be the same.
// Note that it is insufficient to pass in 'locations: false' into the acorn
// parser as there will still be 'start' & 'end' properties attached to nodes
// which represent character offsets.
//
// WARNING: Since this function is only used for this test suite, it mutates
// the original AST for convenience instead of creating a copy.
const stripLocationInfo = (node: es.Node): es.Node => {
  // The 'start' & 'end' properties are not typed in ESTree, but they exist
  // on some nodes in the AST generated by acorn parser.
  full(node, (node: es.Node & { start?: number; end?: number }) => {
    // Line & column numbers
    delete node.loc
    // Character offsets
    delete node.start
    delete node.end
  })
  return node
}

describe('transformImportedFile', () => {
  const iifeIdentifier = 'importedFile'
  const parseError = new Error('Unable to parse code')
  let actualContext = mockContext(Chapter.SOURCE_2)
  let expectedContext = mockContext(Chapter.SOURCE_2)

  beforeEach(() => {
    actualContext = mockContext(Chapter.SOURCE_2)
    expectedContext = mockContext(Chapter.SOURCE_2)
  })

  const assertASTsAreEquivalent = (actualCode: string, expectedCode: string): void => {
    const actualProgram = parse(actualCode, actualContext)
    const expectedProgram = parse(expectedCode, expectedContext)

    if (actualProgram === undefined || expectedProgram === undefined) {
      throw parseError
    }
    const actualFunctionDeclaration = transformImportedFile(actualProgram, iifeIdentifier)
    const expectedFunctionDeclaration = expectedProgram.body[0]
    expect(expectedFunctionDeclaration.type).toEqual('FunctionDeclaration')
    expect(stripLocationInfo(actualFunctionDeclaration)).toEqual(
      stripLocationInfo(expectedFunctionDeclaration)
    )
  }

  it('wraps the program body in a FunctionDeclaration', () => {
    const actualCode = `const square = x => x * x;
      const x = 42;
    `
    const expectedCode = `function ${iifeIdentifier}() {
        const square = x => x * x;
        const x = 42;
        return pair(null, list());
      }
    `
    assertASTsAreEquivalent(actualCode, expectedCode)
  })

  it('returns only exported variables', () => {
    const actualCode = `const x = 42;
      export const y = 53;
    `
    const expectedCode = `function ${iifeIdentifier}() {
        const x = 42;
        const y = 53;
        return pair(null, list(pair("y", y)));
      }
    `
    assertASTsAreEquivalent(actualCode, expectedCode)
  })

  it('returns only exported functions', () => {
    const actualCode = `function id(x) {
        return x;
      }
      export function square(x) {
        return x * x;
      }
    `
    const expectedCode = `function ${iifeIdentifier}() {
        function id(x) {
          return x;
        }
        function square(x) {
          return x * x;
        }
        return pair(null, list(pair("square", square)));
      }
    `
    assertASTsAreEquivalent(actualCode, expectedCode)
  })

  it('returns only exported arrow functions', () => {
    const actualCode = `const id = x => x;
      export const square = x => x * x;
    `
    const expectedCode = `function ${iifeIdentifier}() {
        const id = x => x;
        const square = x => x * x;
        return pair(null, list(pair("square", square)));
      }
    `
    assertASTsAreEquivalent(actualCode, expectedCode)
  })

  it('returns all exported names when there are multiple', () => {
    const actualCode = `export const x = 42;
      export function id(x) {
        return x;
      }
      export const square = x => x * x;
    `
    const expectedCode = `function ${iifeIdentifier}() {
        const x = 42;
        function id(x) {
          return x;
        }
        const square = x => x * x;
        return pair(null, list(pair("x", x), pair("id", id), pair("square", square)));
      }
    `
    assertASTsAreEquivalent(actualCode, expectedCode)
  })

  it('returns all exported names in {}-notation', () => {
    const actualCode = `const x = 42;
      function id(x) {
        return x;
      }
      const square = x => x * x;
      export { x, id, square };
    `
    const expectedCode = `function ${iifeIdentifier}() {
        const x = 42;
        function id(x) {
          return x;
        }
        const square = x => x * x;
        return pair(null, list(pair("x", x), pair("id", id), pair("square", square)));
      }
    `
    assertASTsAreEquivalent(actualCode, expectedCode)
  })

  it('returns renamed exported names', () => {
    const actualCode = `const x = 42;
      function id(x) {
        return x;
      }
      const square = x => x * x;
      export { x as y, id as identity, square as sq };
    `
    const expectedCode = `function ${iifeIdentifier}() {
        const x = 42;
        function id(x) {
          return x;
        }
        const square = x => x * x;
        return pair(null, list(pair("y", x), pair("identity", id), pair("sq", square)));
      }
    `
    assertASTsAreEquivalent(actualCode, expectedCode)
  })

  // Default exports of variable declarations and arrow function declarations
  // is not allowed in ES6, and will be caught by the Acorn parser.
  it('returns default export of function declaration', () => {
    const actualCode = `function id(x) {
        return x;
      }
      export default function square(x) {
        return x * x;
      }
    `
    const expectedCode = `function ${iifeIdentifier}() {
        function id(x) {
          return x;
        }
        function square(x) {
          return x * x;
        }
        return pair(square, list());
      }
    `
    assertASTsAreEquivalent(actualCode, expectedCode)
  })
})

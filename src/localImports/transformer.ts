import es from 'estree'

// It is necessary to write this type guard like this as the 'type' of both
// 'Directive' & 'ExpressionStatement' is 'ExpressionStatement'.
//
// export interface Directive extends BaseNode {
//   type: "ExpressionStatement";
//   expression: Literal;
//   directive: string;
// }
//
// export interface ExpressionStatement extends BaseStatement {
//   type: "ExpressionStatement";
//   expression: Expression;
// }
//
// As such, we check whether the 'directive' property exists on the object
// instead in order to differentiate between the two.
const isDirective = (node: es.Node): node is es.Directive => {
  return 'directive' in node
}

const isModuleDeclaration = (node: es.Node): node is es.ModuleDeclaration => {
  return [
    'ImportDeclaration',
    'ExportNamedDeclaration',
    'ExportDefaultDeclaration',
    'ExportAllDeclaration'
  ].includes(node.type)
}

const isStatement = (
  node: es.Directive | es.Statement | es.ModuleDeclaration
): node is es.Statement => {
  return !isDirective(node) && !isModuleDeclaration(node)
}

const getExportedName = (node: es.Declaration): string | null => {
  switch (node.type) {
    case 'FunctionDeclaration':
      // node.id is null when a function declaration is a part of the export default function statement.
      if (node.id === null) {
        return null
      }
      return node.id.name
    case 'VariableDeclaration':
      const id = node.declarations[0].id
      // In Source, variable names are Identifiers.
      if (id.type !== 'Identifier') {
        throw new Error(`Expected variable name to be an Identifier, but was ${id.type} instead.`)
      }
      return id.name
    case 'ClassDeclaration':
      throw new Error('Exporting of class is not supported.')
  }
}

const getExportedNames = (nodes: es.ModuleDeclaration[]): Record<string, string> => {
  const exportedNameToIdentifierMap: Record<string, string> = {}
  nodes.forEach((node: es.ModuleDeclaration): void => {
    switch (node.type) {
      case 'ExportNamedDeclaration':
        if (node.declaration) {
          const exportedName = getExportedName(node.declaration)
          if (exportedName === null) {
            break
          }
          // When an ExportNamedDeclaration node has a declaration, the
          // identifier is the same as the exported name (i.e., no renaming).
          const identifier = exportedName
          exportedNameToIdentifierMap[exportedName] = identifier
        } else {
          // When an ExportNamedDeclaration node does not have a declaration,
          // it contains a list of names to export, i.e., export { a, b as c, d };.
          // Exported names can be renamed using the 'as' keyword. As such, the
          // exported names and their corresponding identifiers might be different.
          node.specifiers.forEach((node: es.ExportSpecifier): void => {
            const exportedName = node.exported.name
            const identifier = node.local.name
            exportedNameToIdentifierMap[exportedName] = identifier
          })
        }
        break
    }
  })
  return exportedNameToIdentifierMap
}

const createReturnListArguments = (
  exportedNameToIdentifierMap: Record<string, string>
): Array<es.Expression | es.SpreadElement> => {
  return Object.entries(exportedNameToIdentifierMap).map(
    ([exportedName, identifier]: [string, string]) => {
      const head: es.SimpleLiteral = {
        type: 'Literal',
        value: exportedName,
        raw: '"' + exportedName + '"'
      }
      const tail: es.Identifier = {
        type: 'Identifier',
        name: identifier
      }
      return {
        type: 'CallExpression',
        callee: {
          type: 'Identifier',
          name: 'pair'
        },
        arguments: [head, tail]
        // The 'optional' property is typed in ESTree, but does not exist
        // on SimpleCallExpression nodes in the AST generated by acorn parser.
      } as es.SimpleCallExpression
    }
  )
}

const removeDirectives = (
  nodes: Array<es.Directive | es.Statement | es.ModuleDeclaration>
): Array<es.Statement | es.ModuleDeclaration> => {
  return nodes.filter(
    (
      node: es.Directive | es.Statement | es.ModuleDeclaration
    ): node is es.Statement | es.ModuleDeclaration => !isDirective(node)
  )
}

const removeModuleDeclarations = (
  nodes: Array<es.Statement | es.ModuleDeclaration>
): es.Statement[] => {
  const statements: es.Statement[] = []
  nodes.forEach((node: es.Statement | es.ModuleDeclaration): void => {
    if (isStatement(node)) {
      statements.push(node)
      return
    }
    switch (node.type) {
      case 'ExportNamedDeclaration':
        if (node.declaration) {
          statements.push(node.declaration)
        }
        break
    }
  })
  return statements
}

export const transformImportedFile = (
  program: es.Program,
  iifeIdentifier: string
): es.FunctionDeclaration => {
  const moduleDeclarations = program.body.filter(isModuleDeclaration)
  const exportedNames = getExportedNames(moduleDeclarations)

  const returnStatement: es.ReturnStatement = {
    type: 'ReturnStatement',
    argument: {
      type: 'CallExpression',
      callee: {
        type: 'Identifier',
        name: 'pair'
      },
      arguments: [
        {
          type: 'Literal',
          value: null,
          raw: 'null'
        },
        // List of named exports. Each element of the list is a
        // mapping from the exported name to its corresponding identifier.
        {
          type: 'CallExpression',
          callee: {
            type: 'Identifier',
            name: 'list'
          },
          arguments: createReturnListArguments(exportedNames)
        }
      ]
      // The 'optional' property is typed in ESTree, but does not exist
      // on SimpleCallExpression nodes in the AST generated by acorn parser.
    } as es.SimpleCallExpression
  }

  const programStatements = removeModuleDeclarations(removeDirectives(program.body))
  // The 'expression' property is not typed in ESTree, but it exists
  // on FunctionDeclaration nodes in the AST generated by acorn parser.
  const iife: es.FunctionDeclaration & { expression?: boolean } = {
    type: 'FunctionDeclaration',
    expression: false,
    generator: false,
    id: {
      type: 'Identifier',
      name: iifeIdentifier
    },
    params: [],
    body: {
      type: 'BlockStatement',
      body: [...programStatements, returnStatement]
    }
  }
  // However, the extra properties on FunctionDeclaration nodes are unused
  // in the Source interpreter. As such, we can safely ignore their existence
  // outside of this function to make the typing cleaner. The alternative
  // would be to define our own AST node types based off the ESTree node types
  // and use our custom AST node types everywhere.
  return iife as es.FunctionDeclaration
}

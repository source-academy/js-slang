import es from 'estree'

// It is necessary to write this type guard like this as the 'type' of both
// 'Directive' & 'ExpressionStatement' is 'ExpressionStatement'.
//
// export interface Directive extends BaseNode {
//   type: "ExpressionStatement";
//   expression: Literal;
//   directive: string;
// }
//
// export interface ExpressionStatement extends BaseStatement {
//   type: "ExpressionStatement";
//   expression: Expression;
// }
//
// As such, we check whether the 'directive' property exists on the object
// instead in order to differentiate between the two.
const isDirective = (node: es.Node): node is es.Directive => {
  return 'directive' in node
}

const isModuleDeclaration = (node: es.Node): node is es.ModuleDeclaration => {
  return [
    'ImportDeclaration',
    'ExportNamedDeclaration',
    'ExportDefaultDeclaration',
    'ExportAllDeclaration'
  ].includes(node.type)
}

const isStatement = (
  node: es.Directive | es.Statement | es.ModuleDeclaration
): node is es.Statement => {
  return !isDirective(node) && !isModuleDeclaration(node)
}

export const transformImportedFile = (
  program: es.Program,
  iifeIdentifier: string
): es.FunctionDeclaration => {
  const programStatements = program.body.filter(isStatement)

  // TODO: Add exporting of names.
  const exportedNames: Array<es.Expression | es.SpreadElement> = []
  const returnStatement: es.ReturnStatement = {
    type: 'ReturnStatement',
    argument: {
      type: 'CallExpression',
      callee: {
        type: 'Identifier',
        name: 'list'
      },
      arguments: exportedNames
      // The 'optional' property is typed in ESTree, but does not exist
      // on SimpleCallExpression nodes in the AST generated by acorn parser.
    } as es.SimpleCallExpression
  }

  // The 'expression' property is not typed in ESTree, but it exists
  // on FunctionDeclaration nodes in the AST generated by acorn parser.
  const iife: es.FunctionDeclaration & { expression?: boolean } = {
    type: 'FunctionDeclaration',
    expression: false,
    generator: false,
    id: {
      type: 'Identifier',
      name: iifeIdentifier
    },
    params: [],
    body: {
      type: 'BlockStatement',
      body: [...programStatements, returnStatement]
    }
  }
  // However, the extra properties on FunctionDeclaration nodes are unused
  // in the Source interpreter. As such, we can safely ignore their existence
  // outside of this function to make the typing cleaner. The alternative
  // would be to define our own AST node types based off the ESTree node types
  // and use our custom AST node types everywhere.
  return iife as es.FunctionDeclaration
}

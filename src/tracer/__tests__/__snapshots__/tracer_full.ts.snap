// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`#1109: Empty function bodies don't break execution Constant declaration of lambda 1`] = `
"const a = () => {};\\"other statement\\";a();\\"Gets returned by normal run\\";
[noMarker] Start of evaluation

const a = () => {};\\"other statement\\";a();\\"Gets returned by normal run\\";
[beforeMarker] Constant a declared and substituted into the rest of block

\\"other statement\\";(() => {})();\\"Gets returned by normal run\\";
[afterMarker] Constant a declared and substituted into the rest of block

\\"other statement\\";(() => {})();\\"Gets returned by normal run\\";
[beforeMarker] () => {...} runs

\\"other statement\\";{};\\"Gets returned by normal run\\";
[afterMarker] () => {...} runs

\\"other statement\\";{};\\"Gets returned by normal run\\";
[beforeMarker] Empty block expression evaluated

\\"other statement\\";undefined;\\"Gets returned by normal run\\";
[afterMarker] Empty block expression evaluated

\\"other statement\\";undefined;\\"Gets returned by normal run\\";
[beforeMarker] \\"other statement\\" finished evaluating

undefined;\\"Gets returned by normal run\\";
[afterMarker] \\"other statement\\" finished evaluating

undefined;\\"Gets returned by normal run\\";
[beforeMarker] undefined finished evaluating

\\"Gets returned by normal run\\";
[afterMarker] undefined finished evaluating

\\"Gets returned by normal run\\";
[noMarker] Evaluation complete
"
`;

exports[`#1109: Empty function bodies don't break execution Function declaration 1`] = `
"function a() {}\\"other statement\\";a();\\"Gets returned by normal run\\";
[noMarker] Start of evaluation

function a() {}\\"other statement\\";a();\\"Gets returned by normal run\\";
[beforeMarker] Function a declared, parameter(s)  required

\\"other statement\\";(() => {})();\\"Gets returned by normal run\\";
[afterMarker] Function a declared, parameter(s)  required

\\"other statement\\";(() => {})();\\"Gets returned by normal run\\";
[beforeMarker] () => {...} runs

\\"other statement\\";{};\\"Gets returned by normal run\\";
[afterMarker] () => {...} runs

\\"other statement\\";{};\\"Gets returned by normal run\\";
[beforeMarker] Empty block expression evaluated

\\"other statement\\";undefined;\\"Gets returned by normal run\\";
[afterMarker] Empty block expression evaluated

\\"other statement\\";undefined;\\"Gets returned by normal run\\";
[beforeMarker] \\"other statement\\" finished evaluating

undefined;\\"Gets returned by normal run\\";
[afterMarker] \\"other statement\\" finished evaluating

undefined;\\"Gets returned by normal run\\";
[beforeMarker] undefined finished evaluating

\\"Gets returned by normal run\\";
[afterMarker] undefined finished evaluating

\\"Gets returned by normal run\\";
[noMarker] Evaluation complete
"
`;

exports[`#1342: Test the fix of #1341: Stepper limit off by one Program steps equal to Stepper limit 1`] = `
"function factorial(n) { return n === 1 ? 1 : n * factorial(n - 1);}factorial(100);
[noMarker] Start of evaluation

function factorial(n) { return n === 1 ? 1 : n * factorial(n - 1);}factorial(100);
[beforeMarker] Function factorial declared, parameter(s) n required

(n => { return n === 1 ? 1 : n * factorial(n - 1);})(100);
[afterMarker] Function factorial declared, parameter(s) n required

(n => { return n === 1 ? 1 : n * factorial(n - 1);})(100);
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 100

100 === 1 ? 1 : 100 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(100 - 1);
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 100

100 === 1 ? 1 : 100 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(100 - 1);
[beforeMarker] Binary expression 100 === 1 evaluated

false ? 1 : 100 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(100 - 1);
[afterMarker] Binary expression 100 === 1 evaluated

false ? 1 : 100 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(100 - 1);
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(100 - 1);
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(100 - 1);
[beforeMarker] Binary expression 100 - 1 evaluated

100 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(99);
[afterMarker] Binary expression 100 - 1 evaluated

100 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(99);
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 99

100 * (99 === 1 ? 1 : 99 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(99 - 1));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 99

100 * (99 === 1 ? 1 : 99 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(99 - 1));
[beforeMarker] Binary expression 99 === 1 evaluated

100 * (false ? 1 : 99 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(99 - 1));
[afterMarker] Binary expression 99 === 1 evaluated

100 * (false ? 1 : 99 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(99 - 1));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(99 - 1));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(99 - 1));
[beforeMarker] Binary expression 99 - 1 evaluated

100 * (99 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(98));
[afterMarker] Binary expression 99 - 1 evaluated

100 * (99 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(98));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 98

100 * (99 * (98 === 1 ? 1 : 98 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(98 - 1)));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 98

100 * (99 * (98 === 1 ? 1 : 98 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(98 - 1)));
[beforeMarker] Binary expression 98 === 1 evaluated

100 * (99 * (false ? 1 : 98 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(98 - 1)));
[afterMarker] Binary expression 98 === 1 evaluated

100 * (99 * (false ? 1 : 98 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(98 - 1)));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(98 - 1)));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(98 - 1)));
[beforeMarker] Binary expression 98 - 1 evaluated

100 * (99 * (98 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(97)));
[afterMarker] Binary expression 98 - 1 evaluated

100 * (99 * (98 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(97)));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 97

100 * (99 * (98 * (97 === 1 ? 1 : 97 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(97 - 1))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 97

100 * (99 * (98 * (97 === 1 ? 1 : 97 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(97 - 1))));
[beforeMarker] Binary expression 97 === 1 evaluated

100 * (99 * (98 * (false ? 1 : 97 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(97 - 1))));
[afterMarker] Binary expression 97 === 1 evaluated

100 * (99 * (98 * (false ? 1 : 97 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(97 - 1))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(97 - 1))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(97 - 1))));
[beforeMarker] Binary expression 97 - 1 evaluated

100 * (99 * (98 * (97 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(96))));
[afterMarker] Binary expression 97 - 1 evaluated

100 * (99 * (98 * (97 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(96))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 96

100 * (99 * (98 * (97 * (96 === 1 ? 1 : 96 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(96 - 1)))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 96

100 * (99 * (98 * (97 * (96 === 1 ? 1 : 96 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(96 - 1)))));
[beforeMarker] Binary expression 96 === 1 evaluated

100 * (99 * (98 * (97 * (false ? 1 : 96 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(96 - 1)))));
[afterMarker] Binary expression 96 === 1 evaluated

100 * (99 * (98 * (97 * (false ? 1 : 96 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(96 - 1)))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(96 - 1)))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(96 - 1)))));
[beforeMarker] Binary expression 96 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(95)))));
[afterMarker] Binary expression 96 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(95)))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 95

100 * (99 * (98 * (97 * (96 * (95 === 1 ? 1 : 95 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(95 - 1))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 95

100 * (99 * (98 * (97 * (96 * (95 === 1 ? 1 : 95 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(95 - 1))))));
[beforeMarker] Binary expression 95 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (false ? 1 : 95 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(95 - 1))))));
[afterMarker] Binary expression 95 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (false ? 1 : 95 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(95 - 1))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(95 - 1))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(95 - 1))))));
[beforeMarker] Binary expression 95 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(94))))));
[afterMarker] Binary expression 95 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(94))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 94

100 * (99 * (98 * (97 * (96 * (95 * (94 === 1 ? 1 : 94 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(94 - 1)))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 94

100 * (99 * (98 * (97 * (96 * (95 * (94 === 1 ? 1 : 94 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(94 - 1)))))));
[beforeMarker] Binary expression 94 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (false ? 1 : 94 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(94 - 1)))))));
[afterMarker] Binary expression 94 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (false ? 1 : 94 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(94 - 1)))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(94 - 1)))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(94 - 1)))))));
[beforeMarker] Binary expression 94 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(93)))))));
[afterMarker] Binary expression 94 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(93)))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 93

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 === 1 ? 1 : 93 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(93 - 1))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 93

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 === 1 ? 1 : 93 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(93 - 1))))))));
[beforeMarker] Binary expression 93 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (false ? 1 : 93 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(93 - 1))))))));
[afterMarker] Binary expression 93 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (false ? 1 : 93 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(93 - 1))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(93 - 1))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(93 - 1))))))));
[beforeMarker] Binary expression 93 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(92))))))));
[afterMarker] Binary expression 93 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(92))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 92

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 === 1 ? 1 : 92 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(92 - 1)))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 92

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 === 1 ? 1 : 92 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(92 - 1)))))))));
[beforeMarker] Binary expression 92 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (false ? 1 : 92 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(92 - 1)))))))));
[afterMarker] Binary expression 92 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (false ? 1 : 92 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(92 - 1)))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(92 - 1)))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(92 - 1)))))))));
[beforeMarker] Binary expression 92 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(91)))))))));
[afterMarker] Binary expression 92 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(91)))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 91

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 === 1 ? 1 : 91 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(91 - 1))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 91

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 === 1 ? 1 : 91 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(91 - 1))))))))));
[beforeMarker] Binary expression 91 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (false ? 1 : 91 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(91 - 1))))))))));
[afterMarker] Binary expression 91 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (false ? 1 : 91 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(91 - 1))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(91 - 1))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(91 - 1))))))))));
[beforeMarker] Binary expression 91 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(90))))))))));
[afterMarker] Binary expression 91 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(90))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 90

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 === 1 ? 1 : 90 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(90 - 1)))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 90

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 === 1 ? 1 : 90 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(90 - 1)))))))))));
[beforeMarker] Binary expression 90 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (false ? 1 : 90 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(90 - 1)))))))))));
[afterMarker] Binary expression 90 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (false ? 1 : 90 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(90 - 1)))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(90 - 1)))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(90 - 1)))))))))));
[beforeMarker] Binary expression 90 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(89)))))))))));
[afterMarker] Binary expression 90 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(89)))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 89

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 === 1 ? 1 : 89 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(89 - 1))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 89

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 === 1 ? 1 : 89 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(89 - 1))))))))))));
[beforeMarker] Binary expression 89 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (false ? 1 : 89 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(89 - 1))))))))))));
[afterMarker] Binary expression 89 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (false ? 1 : 89 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(89 - 1))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(89 - 1))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(89 - 1))))))))))));
[beforeMarker] Binary expression 89 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(88))))))))))));
[afterMarker] Binary expression 89 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(88))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 88

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 === 1 ? 1 : 88 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(88 - 1)))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 88

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 === 1 ? 1 : 88 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(88 - 1)))))))))))));
[beforeMarker] Binary expression 88 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (false ? 1 : 88 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(88 - 1)))))))))))));
[afterMarker] Binary expression 88 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (false ? 1 : 88 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(88 - 1)))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(88 - 1)))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(88 - 1)))))))))))));
[beforeMarker] Binary expression 88 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(87)))))))))))));
[afterMarker] Binary expression 88 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(87)))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 87

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 === 1 ? 1 : 87 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(87 - 1))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 87

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 === 1 ? 1 : 87 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(87 - 1))))))))))))));
[beforeMarker] Binary expression 87 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (false ? 1 : 87 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(87 - 1))))))))))))));
[afterMarker] Binary expression 87 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (false ? 1 : 87 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(87 - 1))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(87 - 1))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(87 - 1))))))))))))));
[beforeMarker] Binary expression 87 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(86))))))))))))));
[afterMarker] Binary expression 87 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(86))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 86

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 === 1 ? 1 : 86 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(86 - 1)))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 86

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 === 1 ? 1 : 86 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(86 - 1)))))))))))))));
[beforeMarker] Binary expression 86 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (false ? 1 : 86 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(86 - 1)))))))))))))));
[afterMarker] Binary expression 86 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (false ? 1 : 86 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(86 - 1)))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(86 - 1)))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(86 - 1)))))))))))))));
[beforeMarker] Binary expression 86 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(85)))))))))))))));
[afterMarker] Binary expression 86 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(85)))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 85

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 === 1 ? 1 : 85 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(85 - 1))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 85

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 === 1 ? 1 : 85 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(85 - 1))))))))))))))));
[beforeMarker] Binary expression 85 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (false ? 1 : 85 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(85 - 1))))))))))))))));
[afterMarker] Binary expression 85 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (false ? 1 : 85 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(85 - 1))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(85 - 1))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(85 - 1))))))))))))))));
[beforeMarker] Binary expression 85 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(84))))))))))))))));
[afterMarker] Binary expression 85 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(84))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 84

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 === 1 ? 1 : 84 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(84 - 1)))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 84

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 === 1 ? 1 : 84 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(84 - 1)))))))))))))))));
[beforeMarker] Binary expression 84 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (false ? 1 : 84 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(84 - 1)))))))))))))))));
[afterMarker] Binary expression 84 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (false ? 1 : 84 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(84 - 1)))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(84 - 1)))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(84 - 1)))))))))))))))));
[beforeMarker] Binary expression 84 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(83)))))))))))))))));
[afterMarker] Binary expression 84 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(83)))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 83

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 === 1 ? 1 : 83 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(83 - 1))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 83

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 === 1 ? 1 : 83 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(83 - 1))))))))))))))))));
[beforeMarker] Binary expression 83 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (false ? 1 : 83 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(83 - 1))))))))))))))))));
[afterMarker] Binary expression 83 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (false ? 1 : 83 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(83 - 1))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(83 - 1))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(83 - 1))))))))))))))))));
[beforeMarker] Binary expression 83 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(82))))))))))))))))));
[afterMarker] Binary expression 83 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(82))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 82

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 === 1 ? 1 : 82 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(82 - 1)))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 82

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 === 1 ? 1 : 82 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(82 - 1)))))))))))))))))));
[beforeMarker] Binary expression 82 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (false ? 1 : 82 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(82 - 1)))))))))))))))))));
[afterMarker] Binary expression 82 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (false ? 1 : 82 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(82 - 1)))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(82 - 1)))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(82 - 1)))))))))))))))))));
[beforeMarker] Binary expression 82 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(81)))))))))))))))))));
[afterMarker] Binary expression 82 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(81)))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 81

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 === 1 ? 1 : 81 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(81 - 1))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 81

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 === 1 ? 1 : 81 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(81 - 1))))))))))))))))))));
[beforeMarker] Binary expression 81 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (false ? 1 : 81 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(81 - 1))))))))))))))))))));
[afterMarker] Binary expression 81 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (false ? 1 : 81 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(81 - 1))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(81 - 1))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(81 - 1))))))))))))))))))));
[beforeMarker] Binary expression 81 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(80))))))))))))))))))));
[afterMarker] Binary expression 81 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(80))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 80

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 === 1 ? 1 : 80 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(80 - 1)))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 80

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 === 1 ? 1 : 80 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(80 - 1)))))))))))))))))))));
[beforeMarker] Binary expression 80 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (false ? 1 : 80 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(80 - 1)))))))))))))))))))));
[afterMarker] Binary expression 80 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (false ? 1 : 80 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(80 - 1)))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(80 - 1)))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(80 - 1)))))))))))))))))))));
[beforeMarker] Binary expression 80 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(79)))))))))))))))))))));
[afterMarker] Binary expression 80 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(79)))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 79

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 === 1 ? 1 : 79 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(79 - 1))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 79

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 === 1 ? 1 : 79 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(79 - 1))))))))))))))))))))));
[beforeMarker] Binary expression 79 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (false ? 1 : 79 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(79 - 1))))))))))))))))))))));
[afterMarker] Binary expression 79 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (false ? 1 : 79 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(79 - 1))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(79 - 1))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(79 - 1))))))))))))))))))))));
[beforeMarker] Binary expression 79 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(78))))))))))))))))))))));
[afterMarker] Binary expression 79 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(78))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 78

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 === 1 ? 1 : 78 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(78 - 1)))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 78

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 === 1 ? 1 : 78 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(78 - 1)))))))))))))))))))))));
[beforeMarker] Binary expression 78 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (false ? 1 : 78 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(78 - 1)))))))))))))))))))))));
[afterMarker] Binary expression 78 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (false ? 1 : 78 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(78 - 1)))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(78 - 1)))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(78 - 1)))))))))))))))))))))));
[beforeMarker] Binary expression 78 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(77)))))))))))))))))))))));
[afterMarker] Binary expression 78 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(77)))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 77

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 === 1 ? 1 : 77 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(77 - 1))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 77

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 === 1 ? 1 : 77 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(77 - 1))))))))))))))))))))))));
[beforeMarker] Binary expression 77 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (false ? 1 : 77 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(77 - 1))))))))))))))))))))))));
[afterMarker] Binary expression 77 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (false ? 1 : 77 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(77 - 1))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(77 - 1))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(77 - 1))))))))))))))))))))))));
[beforeMarker] Binary expression 77 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(76))))))))))))))))))))))));
[afterMarker] Binary expression 77 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(76))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 76

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 === 1 ? 1 : 76 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(76 - 1)))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 76

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 === 1 ? 1 : 76 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(76 - 1)))))))))))))))))))))))));
[beforeMarker] Binary expression 76 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (false ? 1 : 76 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(76 - 1)))))))))))))))))))))))));
[afterMarker] Binary expression 76 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (false ? 1 : 76 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(76 - 1)))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(76 - 1)))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(76 - 1)))))))))))))))))))))))));
[beforeMarker] Binary expression 76 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(75)))))))))))))))))))))))));
[afterMarker] Binary expression 76 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(75)))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 75

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 === 1 ? 1 : 75 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(75 - 1))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 75

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 === 1 ? 1 : 75 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(75 - 1))))))))))))))))))))))))));
[beforeMarker] Binary expression 75 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (false ? 1 : 75 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(75 - 1))))))))))))))))))))))))));
[afterMarker] Binary expression 75 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (false ? 1 : 75 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(75 - 1))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(75 - 1))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(75 - 1))))))))))))))))))))))))));
[beforeMarker] Binary expression 75 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(74))))))))))))))))))))))))));
[afterMarker] Binary expression 75 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(74))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 74

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 === 1 ? 1 : 74 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(74 - 1)))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 74

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 === 1 ? 1 : 74 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(74 - 1)))))))))))))))))))))))))));
[beforeMarker] Binary expression 74 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (false ? 1 : 74 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(74 - 1)))))))))))))))))))))))))));
[afterMarker] Binary expression 74 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (false ? 1 : 74 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(74 - 1)))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(74 - 1)))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(74 - 1)))))))))))))))))))))))))));
[beforeMarker] Binary expression 74 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(73)))))))))))))))))))))))))));
[afterMarker] Binary expression 74 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(73)))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 73

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 === 1 ? 1 : 73 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(73 - 1))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 73

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 === 1 ? 1 : 73 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(73 - 1))))))))))))))))))))))))))));
[beforeMarker] Binary expression 73 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (false ? 1 : 73 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(73 - 1))))))))))))))))))))))))))));
[afterMarker] Binary expression 73 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (false ? 1 : 73 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(73 - 1))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(73 - 1))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(73 - 1))))))))))))))))))))))))))));
[beforeMarker] Binary expression 73 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(72))))))))))))))))))))))))))));
[afterMarker] Binary expression 73 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(72))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 72

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 === 1 ? 1 : 72 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(72 - 1)))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 72

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 === 1 ? 1 : 72 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(72 - 1)))))))))))))))))))))))))))));
[beforeMarker] Binary expression 72 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (false ? 1 : 72 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(72 - 1)))))))))))))))))))))))))))));
[afterMarker] Binary expression 72 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (false ? 1 : 72 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(72 - 1)))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(72 - 1)))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(72 - 1)))))))))))))))))))))))))))));
[beforeMarker] Binary expression 72 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(71)))))))))))))))))))))))))))));
[afterMarker] Binary expression 72 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(71)))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 71

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 === 1 ? 1 : 71 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(71 - 1))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 71

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 === 1 ? 1 : 71 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(71 - 1))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 71 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (false ? 1 : 71 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(71 - 1))))))))))))))))))))))))))))));
[afterMarker] Binary expression 71 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (false ? 1 : 71 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(71 - 1))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(71 - 1))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(71 - 1))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 71 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(70))))))))))))))))))))))))))))));
[afterMarker] Binary expression 71 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(70))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 70

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 === 1 ? 1 : 70 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(70 - 1)))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 70

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 === 1 ? 1 : 70 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(70 - 1)))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 70 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (false ? 1 : 70 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(70 - 1)))))))))))))))))))))))))))))));
[afterMarker] Binary expression 70 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (false ? 1 : 70 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(70 - 1)))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(70 - 1)))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(70 - 1)))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 70 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(69)))))))))))))))))))))))))))))));
[afterMarker] Binary expression 70 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(69)))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 69

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 === 1 ? 1 : 69 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(69 - 1))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 69

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 === 1 ? 1 : 69 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(69 - 1))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 69 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (false ? 1 : 69 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(69 - 1))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 69 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (false ? 1 : 69 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(69 - 1))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(69 - 1))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(69 - 1))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 69 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(68))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 69 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(68))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 68

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 === 1 ? 1 : 68 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(68 - 1)))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 68

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 === 1 ? 1 : 68 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(68 - 1)))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 68 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (false ? 1 : 68 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(68 - 1)))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 68 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (false ? 1 : 68 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(68 - 1)))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(68 - 1)))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(68 - 1)))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 68 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(67)))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 68 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(67)))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 67

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 === 1 ? 1 : 67 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(67 - 1))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 67

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 === 1 ? 1 : 67 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(67 - 1))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 67 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (false ? 1 : 67 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(67 - 1))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 67 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (false ? 1 : 67 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(67 - 1))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(67 - 1))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(67 - 1))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 67 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(66))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 67 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(66))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 66

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 === 1 ? 1 : 66 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(66 - 1)))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 66

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 === 1 ? 1 : 66 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(66 - 1)))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 66 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (false ? 1 : 66 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(66 - 1)))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 66 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (false ? 1 : 66 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(66 - 1)))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(66 - 1)))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(66 - 1)))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 66 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(65)))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 66 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(65)))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 65

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 === 1 ? 1 : 65 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(65 - 1))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 65

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 === 1 ? 1 : 65 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(65 - 1))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 65 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (false ? 1 : 65 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(65 - 1))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 65 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (false ? 1 : 65 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(65 - 1))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(65 - 1))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(65 - 1))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 65 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(64))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 65 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(64))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 64

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 === 1 ? 1 : 64 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(64 - 1)))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 64

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 === 1 ? 1 : 64 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(64 - 1)))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 64 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (false ? 1 : 64 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(64 - 1)))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 64 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (false ? 1 : 64 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(64 - 1)))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(64 - 1)))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(64 - 1)))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 64 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(63)))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 64 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(63)))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 63

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 === 1 ? 1 : 63 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(63 - 1))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 63

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 === 1 ? 1 : 63 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(63 - 1))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 63 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (false ? 1 : 63 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(63 - 1))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 63 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (false ? 1 : 63 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(63 - 1))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(63 - 1))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(63 - 1))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 63 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(62))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 63 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(62))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 62

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 === 1 ? 1 : 62 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(62 - 1)))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 62

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 === 1 ? 1 : 62 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(62 - 1)))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 62 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (false ? 1 : 62 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(62 - 1)))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 62 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (false ? 1 : 62 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(62 - 1)))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(62 - 1)))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(62 - 1)))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 62 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(61)))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 62 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(61)))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 61

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 === 1 ? 1 : 61 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(61 - 1))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 61

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 === 1 ? 1 : 61 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(61 - 1))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 61 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (false ? 1 : 61 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(61 - 1))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 61 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (false ? 1 : 61 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(61 - 1))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(61 - 1))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(61 - 1))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 61 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(60))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 61 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(60))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 60

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 === 1 ? 1 : 60 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(60 - 1)))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 60

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 === 1 ? 1 : 60 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(60 - 1)))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 60 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (false ? 1 : 60 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(60 - 1)))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 60 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (false ? 1 : 60 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(60 - 1)))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(60 - 1)))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(60 - 1)))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 60 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(59)))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 60 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(59)))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 59

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 === 1 ? 1 : 59 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(59 - 1))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 59

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 === 1 ? 1 : 59 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(59 - 1))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 59 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (false ? 1 : 59 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(59 - 1))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 59 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (false ? 1 : 59 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(59 - 1))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(59 - 1))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(59 - 1))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 59 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(58))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 59 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(58))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 58

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 === 1 ? 1 : 58 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(58 - 1)))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 58

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 === 1 ? 1 : 58 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(58 - 1)))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 58 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (false ? 1 : 58 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(58 - 1)))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 58 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (false ? 1 : 58 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(58 - 1)))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(58 - 1)))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(58 - 1)))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 58 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(57)))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 58 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(57)))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 57

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 === 1 ? 1 : 57 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(57 - 1))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 57

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 === 1 ? 1 : 57 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(57 - 1))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 57 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (false ? 1 : 57 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(57 - 1))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 57 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (false ? 1 : 57 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(57 - 1))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(57 - 1))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(57 - 1))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 57 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(56))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 57 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(56))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 56

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 === 1 ? 1 : 56 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(56 - 1)))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 56

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 === 1 ? 1 : 56 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(56 - 1)))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 56 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (false ? 1 : 56 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(56 - 1)))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 56 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (false ? 1 : 56 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(56 - 1)))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(56 - 1)))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(56 - 1)))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 56 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(55)))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 56 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(55)))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 55

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 === 1 ? 1 : 55 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(55 - 1))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 55

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 === 1 ? 1 : 55 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(55 - 1))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 55 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (false ? 1 : 55 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(55 - 1))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 55 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (false ? 1 : 55 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(55 - 1))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(55 - 1))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(55 - 1))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 55 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(54))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 55 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(54))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 54

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 === 1 ? 1 : 54 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(54 - 1)))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 54

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 === 1 ? 1 : 54 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(54 - 1)))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 54 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (false ? 1 : 54 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(54 - 1)))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 54 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (false ? 1 : 54 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(54 - 1)))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(54 - 1)))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(54 - 1)))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 54 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(53)))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 54 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(53)))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 53

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 === 1 ? 1 : 53 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(53 - 1))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 53

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 === 1 ? 1 : 53 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(53 - 1))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 53 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (false ? 1 : 53 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(53 - 1))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 53 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (false ? 1 : 53 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(53 - 1))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(53 - 1))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(53 - 1))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 53 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(52))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 53 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(52))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 52

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 === 1 ? 1 : 52 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(52 - 1)))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 52

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 === 1 ? 1 : 52 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(52 - 1)))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 52 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (false ? 1 : 52 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(52 - 1)))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 52 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (false ? 1 : 52 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(52 - 1)))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(52 - 1)))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(52 - 1)))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 52 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(51)))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 52 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(51)))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 51

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 === 1 ? 1 : 51 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(51 - 1))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 51

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 === 1 ? 1 : 51 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(51 - 1))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 51 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (false ? 1 : 51 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(51 - 1))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 51 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (false ? 1 : 51 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(51 - 1))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(51 - 1))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(51 - 1))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 51 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(50))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 51 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(50))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 50

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 === 1 ? 1 : 50 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(50 - 1)))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 50

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 === 1 ? 1 : 50 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(50 - 1)))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 50 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (false ? 1 : 50 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(50 - 1)))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 50 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (false ? 1 : 50 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(50 - 1)))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(50 - 1)))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(50 - 1)))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 50 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(49)))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 50 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(49)))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 49

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 === 1 ? 1 : 49 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(49 - 1))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 49

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 === 1 ? 1 : 49 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(49 - 1))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 49 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (false ? 1 : 49 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(49 - 1))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 49 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (false ? 1 : 49 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(49 - 1))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(49 - 1))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(49 - 1))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 49 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(48))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 49 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(48))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 48

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 === 1 ? 1 : 48 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(48 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 48

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 === 1 ? 1 : 48 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(48 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 48 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (false ? 1 : 48 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(48 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 48 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (false ? 1 : 48 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(48 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(48 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(48 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 48 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(47)))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 48 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(47)))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 47

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 === 1 ? 1 : 47 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(47 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 47

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 === 1 ? 1 : 47 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(47 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 47 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (false ? 1 : 47 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(47 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 47 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (false ? 1 : 47 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(47 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(47 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(47 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 47 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(46))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 47 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(46))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 46

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 === 1 ? 1 : 46 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(46 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 46

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 === 1 ? 1 : 46 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(46 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 46 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (false ? 1 : 46 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(46 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 46 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (false ? 1 : 46 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(46 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(46 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(46 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 46 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(45)))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 46 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(45)))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 45

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 === 1 ? 1 : 45 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(45 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 45

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 === 1 ? 1 : 45 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(45 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 45 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (false ? 1 : 45 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(45 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 45 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (false ? 1 : 45 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(45 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(45 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(45 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 45 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(44))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 45 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(44))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 44

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 === 1 ? 1 : 44 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(44 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 44

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 === 1 ? 1 : 44 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(44 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 44 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (false ? 1 : 44 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(44 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 44 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (false ? 1 : 44 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(44 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(44 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(44 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 44 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(43)))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 44 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(43)))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 43

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 === 1 ? 1 : 43 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(43 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 43

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 === 1 ? 1 : 43 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(43 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 43 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (false ? 1 : 43 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(43 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 43 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (false ? 1 : 43 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(43 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(43 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(43 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 43 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(42))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 43 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(42))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 42

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 === 1 ? 1 : 42 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(42 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 42

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 === 1 ? 1 : 42 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(42 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 42 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (false ? 1 : 42 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(42 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 42 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (false ? 1 : 42 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(42 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(42 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(42 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 42 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(41)))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 42 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(41)))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 41

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 === 1 ? 1 : 41 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(41 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 41

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 === 1 ? 1 : 41 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(41 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 41 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (false ? 1 : 41 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(41 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 41 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (false ? 1 : 41 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(41 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(41 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(41 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 41 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(40))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 41 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(40))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 40

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 === 1 ? 1 : 40 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(40 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 40

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 === 1 ? 1 : 40 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(40 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 40 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (false ? 1 : 40 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(40 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 40 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (false ? 1 : 40 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(40 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(40 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(40 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 40 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(39)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 40 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(39)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 39

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 === 1 ? 1 : 39 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(39 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 39

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 === 1 ? 1 : 39 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(39 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 39 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (false ? 1 : 39 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(39 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 39 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (false ? 1 : 39 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(39 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(39 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(39 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 39 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(38))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 39 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(38))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 38

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 === 1 ? 1 : 38 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(38 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 38

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 === 1 ? 1 : 38 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(38 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 38 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (false ? 1 : 38 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(38 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 38 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (false ? 1 : 38 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(38 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(38 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(38 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 38 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(37)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 38 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(37)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 37

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 === 1 ? 1 : 37 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(37 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 37

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 === 1 ? 1 : 37 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(37 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 37 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (false ? 1 : 37 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(37 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 37 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (false ? 1 : 37 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(37 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(37 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(37 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 37 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(36))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 37 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(36))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 36

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 === 1 ? 1 : 36 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(36 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 36

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 === 1 ? 1 : 36 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(36 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 36 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (false ? 1 : 36 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(36 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 36 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (false ? 1 : 36 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(36 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(36 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(36 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 36 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(35)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 36 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(35)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 35

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 === 1 ? 1 : 35 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(35 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 35

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 === 1 ? 1 : 35 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(35 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 35 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (false ? 1 : 35 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(35 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 35 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (false ? 1 : 35 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(35 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(35 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(35 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 35 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(34))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 35 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(34))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 34

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 === 1 ? 1 : 34 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(34 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 34

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 === 1 ? 1 : 34 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(34 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 34 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (false ? 1 : 34 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(34 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 34 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (false ? 1 : 34 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(34 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(34 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(34 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 34 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(33)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 34 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(33)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 33

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 === 1 ? 1 : 33 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(33 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 33

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 === 1 ? 1 : 33 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(33 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 33 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (false ? 1 : 33 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(33 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 33 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (false ? 1 : 33 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(33 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(33 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(33 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 33 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(32))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 33 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(32))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 32

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 === 1 ? 1 : 32 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(32 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 32

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 === 1 ? 1 : 32 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(32 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 32 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (false ? 1 : 32 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(32 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 32 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (false ? 1 : 32 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(32 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(32 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(32 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 32 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(31)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 32 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(31)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 31

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 === 1 ? 1 : 31 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(31 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 31

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 === 1 ? 1 : 31 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(31 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 31 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (false ? 1 : 31 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(31 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 31 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (false ? 1 : 31 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(31 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(31 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(31 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 31 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(30))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 31 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(30))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 30

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 === 1 ? 1 : 30 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(30 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 30

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 === 1 ? 1 : 30 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(30 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 30 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (false ? 1 : 30 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(30 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 30 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (false ? 1 : 30 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(30 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(30 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(30 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 30 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(29)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 30 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(29)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 29

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 === 1 ? 1 : 29 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(29 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 29

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 === 1 ? 1 : 29 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(29 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 29 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (false ? 1 : 29 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(29 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 29 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (false ? 1 : 29 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(29 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(29 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(29 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 29 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(28))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 29 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(28))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 28

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 === 1 ? 1 : 28 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(28 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 28

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 === 1 ? 1 : 28 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(28 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 28 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (false ? 1 : 28 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(28 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 28 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (false ? 1 : 28 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(28 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(28 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(28 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 28 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(27)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 28 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(27)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 27

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 === 1 ? 1 : 27 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(27 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 27

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 === 1 ? 1 : 27 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(27 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 27 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (false ? 1 : 27 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(27 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 27 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (false ? 1 : 27 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(27 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(27 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(27 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 27 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(26))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 27 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(26))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 26

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 === 1 ? 1 : 26 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(26 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 26

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 === 1 ? 1 : 26 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(26 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 26 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (false ? 1 : 26 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(26 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 26 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (false ? 1 : 26 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(26 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(26 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(26 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 26 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(25)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 26 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(25)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 25

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 === 1 ? 1 : 25 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(25 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 25

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 === 1 ? 1 : 25 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(25 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 25 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (false ? 1 : 25 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(25 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 25 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (false ? 1 : 25 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(25 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(25 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(25 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 25 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(24))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 25 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(24))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 24

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 === 1 ? 1 : 24 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(24 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 24

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 === 1 ? 1 : 24 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(24 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 24 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (false ? 1 : 24 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(24 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 24 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (false ? 1 : 24 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(24 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(24 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(24 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 24 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(23)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 24 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(23)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 23

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 === 1 ? 1 : 23 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(23 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 23

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 === 1 ? 1 : 23 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(23 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 23 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (false ? 1 : 23 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(23 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 23 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (false ? 1 : 23 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(23 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(23 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(23 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 23 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(22))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 23 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(22))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 22

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 === 1 ? 1 : 22 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(22 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 22

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 === 1 ? 1 : 22 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(22 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 22 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (false ? 1 : 22 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(22 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 22 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (false ? 1 : 22 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(22 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(22 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(22 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 22 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(21)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 22 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(21)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 21

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 === 1 ? 1 : 21 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(21 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 21

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 === 1 ? 1 : 21 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(21 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 21 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (false ? 1 : 21 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(21 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 21 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (false ? 1 : 21 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(21 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(21 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(21 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 21 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(20))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 21 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(20))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 20

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 === 1 ? 1 : 20 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(20 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 20

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 === 1 ? 1 : 20 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(20 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 20 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (false ? 1 : 20 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(20 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 20 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (false ? 1 : 20 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(20 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(20 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(20 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 20 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(19)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 20 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(19)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 19

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 === 1 ? 1 : 19 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(19 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 19

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 === 1 ? 1 : 19 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(19 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 19 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (false ? 1 : 19 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(19 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 19 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (false ? 1 : 19 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(19 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(19 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(19 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 19 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(18))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 19 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(18))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 18

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 === 1 ? 1 : 18 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(18 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 18

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 === 1 ? 1 : 18 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(18 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 18 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (false ? 1 : 18 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(18 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 18 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (false ? 1 : 18 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(18 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(18 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(18 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 18 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(17)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 18 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(17)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 17

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 === 1 ? 1 : 17 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(17 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 17

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 === 1 ? 1 : 17 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(17 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 17 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (false ? 1 : 17 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(17 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 17 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (false ? 1 : 17 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(17 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(17 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(17 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 17 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(16))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 17 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(16))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 16

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 === 1 ? 1 : 16 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(16 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 16

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 === 1 ? 1 : 16 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(16 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 16 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (false ? 1 : 16 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(16 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 16 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (false ? 1 : 16 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(16 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(16 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(16 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 16 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(15)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 16 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(15)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 15

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 === 1 ? 1 : 15 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(15 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 15

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 === 1 ? 1 : 15 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(15 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 15 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (false ? 1 : 15 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(15 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 15 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (false ? 1 : 15 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(15 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(15 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(15 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 15 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(14))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 15 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(14))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 14

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 === 1 ? 1 : 14 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(14 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 14

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 === 1 ? 1 : 14 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(14 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 14 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (false ? 1 : 14 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(14 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 14 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (false ? 1 : 14 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(14 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(14 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(14 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 14 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(13)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 14 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(13)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 13

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 === 1 ? 1 : 13 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(13 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 13

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 === 1 ? 1 : 13 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(13 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 13 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (false ? 1 : 13 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(13 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 13 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (false ? 1 : 13 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(13 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(13 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(13 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 13 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(12))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 13 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(12))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 12

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 === 1 ? 1 : 12 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(12 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 12

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 === 1 ? 1 : 12 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(12 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 12 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (false ? 1 : 12 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(12 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 12 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (false ? 1 : 12 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(12 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(12 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(12 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 12 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(11)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 12 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(11)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 11

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 === 1 ? 1 : 11 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(11 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 11

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 === 1 ? 1 : 11 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(11 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 11 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (false ? 1 : 11 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(11 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 11 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (false ? 1 : 11 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(11 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(11 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(11 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 11 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(10))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 11 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(10))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 10

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 === 1 ? 1 : 10 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(10 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 10

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 === 1 ? 1 : 10 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(10 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 10 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (false ? 1 : 10 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(10 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 10 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (false ? 1 : 10 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(10 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(10 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(10 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 10 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(9)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 10 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(9)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 9

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 === 1 ? 1 : 9 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(9 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 9

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 === 1 ? 1 : 9 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(9 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 9 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (false ? 1 : 9 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(9 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 9 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (false ? 1 : 9 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(9 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(9 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(9 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 9 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(8))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 9 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(8))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 8

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 === 1 ? 1 : 8 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(8 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 8

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 === 1 ? 1 : 8 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(8 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 8 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (false ? 1 : 8 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(8 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 8 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (false ? 1 : 8 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(8 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(8 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(8 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 8 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(7)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 8 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(7)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 7

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 === 1 ? 1 : 7 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(7 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 7

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 === 1 ? 1 : 7 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(7 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 7 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (false ? 1 : 7 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(7 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 7 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (false ? 1 : 7 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(7 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(7 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(7 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 7 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(6))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 7 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(6))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 6

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 === 1 ? 1 : 6 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(6 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 6

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 === 1 ? 1 : 6 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(6 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 6 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (false ? 1 : 6 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(6 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 6 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (false ? 1 : 6 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(6 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(6 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(6 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 6 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(5)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 6 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(5)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 5

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 === 1 ? 1 : 5 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(5 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 5

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 === 1 ? 1 : 5 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(5 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 5 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (false ? 1 : 5 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(5 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 5 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (false ? 1 : 5 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(5 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(5 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(5 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 5 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(4))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 5 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(4))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 4

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 === 1 ? 1 : 4 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(4 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 4

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 === 1 ? 1 : 4 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(4 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 4 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (false ? 1 : 4 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(4 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 4 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (false ? 1 : 4 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(4 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(4 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(4 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 4 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(3)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 4 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(3)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 3

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 === 1 ? 1 : 3 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(3 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 3

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 === 1 ? 1 : 3 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(3 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 3 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (false ? 1 : 3 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(3 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 3 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (false ? 1 : 3 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(3 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(3 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(3 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 3 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(2))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 3 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(2))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 2

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * (2 === 1 ? 1 : 2 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(2 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 2

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * (2 === 1 ? 1 : 2 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(2 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 2 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * (false ? 1 : 2 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(2 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 2 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * (false ? 1 : 2 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(2 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * (2 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(2 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * (2 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(2 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 2 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * (2 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 2 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * (2 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial, defined as n => {...}, takes in n as input 1

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * (2 * (1 === 1 ? 1 : 1 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(1 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial, defined as n => {...}, takes in n as input 1

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * (2 * (1 === 1 ? 1 : 1 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(1 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 1 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * (2 * (true ? 1 : 1 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(1 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 1 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * (2 * (true ? 1 : 1 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(1 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * (2 * 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * (2 * 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 2 * 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * 2)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 2 * 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * 2)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 3 * 2 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * 6))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 3 * 2 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * 6))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 4 * 6 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * 24)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 4 * 6 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * 24)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 5 * 24 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * 120))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 5 * 24 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * 120))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 6 * 120 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * 720)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 6 * 120 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * 720)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 7 * 720 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * 5040))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 7 * 720 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * 5040))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 8 * 5040 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * 40320)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 8 * 5040 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * 40320)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 9 * 40320 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * 362880))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 9 * 40320 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * 362880))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 10 * 362880 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * 3628800)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 10 * 362880 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * 3628800)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 11 * 3628800 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * 39916800))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 11 * 3628800 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * 39916800))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 12 * 39916800 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * 479001600)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 12 * 39916800 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * 479001600)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 13 * 479001600 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * 6227020800))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 13 * 479001600 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * 6227020800))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 14 * 6227020800 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * 87178291200)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 14 * 6227020800 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * 87178291200)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 15 * 87178291200 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * 1307674368000))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 15 * 87178291200 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * 1307674368000))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 16 * 1307674368000 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * 20922789888000)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 16 * 1307674368000 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * 20922789888000)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 17 * 20922789888000 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * 355687428096000))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 17 * 20922789888000 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * 355687428096000))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 18 * 355687428096000 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * 6402373705728000)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 18 * 355687428096000 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * 6402373705728000)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 19 * 6402373705728000 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * 121645100408832000))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 19 * 6402373705728000 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * 121645100408832000))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 20 * 121645100408832000 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * 2432902008176640000)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 20 * 121645100408832000 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * 2432902008176640000)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 21 * 2432902008176640000 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * 51090942171709440000))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 21 * 2432902008176640000 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * 51090942171709440000))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 22 * 51090942171709440000 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * 1.1240007277776077e+21)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 22 * 51090942171709440000 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * 1.1240007277776077e+21)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 23 * 1.1240007277776077e+21 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * 2.585201673888498e+22))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 23 * 1.1240007277776077e+21 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * 2.585201673888498e+22))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 24 * 2.585201673888498e+22 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * 6.204484017332394e+23)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 24 * 2.585201673888498e+22 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * 6.204484017332394e+23)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 25 * 6.204484017332394e+23 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * 1.5511210043330986e+25))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 25 * 6.204484017332394e+23 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * 1.5511210043330986e+25))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 26 * 1.5511210043330986e+25 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * 4.0329146112660565e+26)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 26 * 1.5511210043330986e+25 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * 4.0329146112660565e+26)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 27 * 4.0329146112660565e+26 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * 1.0888869450418352e+28))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 27 * 4.0329146112660565e+26 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * 1.0888869450418352e+28))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 28 * 1.0888869450418352e+28 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * 3.0488834461171384e+29)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 28 * 1.0888869450418352e+28 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * 3.0488834461171384e+29)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 29 * 3.0488834461171384e+29 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * 8.841761993739701e+30))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 29 * 3.0488834461171384e+29 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * 8.841761993739701e+30))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 30 * 8.841761993739701e+30 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * 2.6525285981219103e+32)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 30 * 8.841761993739701e+30 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * 2.6525285981219103e+32)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 31 * 2.6525285981219103e+32 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * 8.222838654177922e+33))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 31 * 2.6525285981219103e+32 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * 8.222838654177922e+33))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 32 * 8.222838654177922e+33 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * 2.631308369336935e+35)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 32 * 8.222838654177922e+33 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * 2.631308369336935e+35)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 33 * 2.631308369336935e+35 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * 8.683317618811886e+36))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 33 * 2.631308369336935e+35 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * 8.683317618811886e+36))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 34 * 8.683317618811886e+36 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * 2.9523279903960412e+38)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 34 * 8.683317618811886e+36 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * 2.9523279903960412e+38)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 35 * 2.9523279903960412e+38 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * 1.0333147966386144e+40))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 35 * 2.9523279903960412e+38 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * 1.0333147966386144e+40))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 36 * 1.0333147966386144e+40 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * 3.719933267899012e+41)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 36 * 1.0333147966386144e+40 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * 3.719933267899012e+41)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 37 * 3.719933267899012e+41 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * 1.3763753091226343e+43))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 37 * 3.719933267899012e+41 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * 1.3763753091226343e+43))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 38 * 1.3763753091226343e+43 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * 5.23022617466601e+44)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 38 * 1.3763753091226343e+43 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * 5.23022617466601e+44)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 39 * 5.23022617466601e+44 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * 2.0397882081197442e+46))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 39 * 5.23022617466601e+44 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * 2.0397882081197442e+46))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 40 * 2.0397882081197442e+46 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * 8.159152832478977e+47)))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 40 * 2.0397882081197442e+46 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * 8.159152832478977e+47)))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 41 * 8.159152832478977e+47 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * 3.3452526613163803e+49))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 41 * 8.159152832478977e+47 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * 3.3452526613163803e+49))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 42 * 3.3452526613163803e+49 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * 1.4050061177528798e+51)))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 42 * 3.3452526613163803e+49 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * 1.4050061177528798e+51)))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 43 * 1.4050061177528798e+51 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * 6.041526306337383e+52))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 43 * 1.4050061177528798e+51 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * 6.041526306337383e+52))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 44 * 6.041526306337383e+52 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * 2.6582715747884485e+54)))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 44 * 6.041526306337383e+52 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * 2.6582715747884485e+54)))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 45 * 2.6582715747884485e+54 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * 1.1962222086548019e+56))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 45 * 2.6582715747884485e+54 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * 1.1962222086548019e+56))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 46 * 1.1962222086548019e+56 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * 5.5026221598120885e+57)))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 46 * 1.1962222086548019e+56 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * 5.5026221598120885e+57)))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 47 * 5.5026221598120885e+57 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * 2.5862324151116818e+59))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 47 * 5.5026221598120885e+57 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * 2.5862324151116818e+59))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 48 * 2.5862324151116818e+59 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * 1.2413915592536073e+61)))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 48 * 2.5862324151116818e+59 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * 1.2413915592536073e+61)))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 49 * 1.2413915592536073e+61 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * 6.082818640342675e+62))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 49 * 1.2413915592536073e+61 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * 6.082818640342675e+62))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 50 * 6.082818640342675e+62 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * 3.0414093201713376e+64)))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 50 * 6.082818640342675e+62 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * 3.0414093201713376e+64)))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 51 * 3.0414093201713376e+64 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * 1.5511187532873822e+66))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 51 * 3.0414093201713376e+64 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * 1.5511187532873822e+66))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 52 * 1.5511187532873822e+66 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * 8.065817517094388e+67)))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 52 * 1.5511187532873822e+66 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * 8.065817517094388e+67)))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 53 * 8.065817517094388e+67 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * 4.2748832840600255e+69))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 53 * 8.065817517094388e+67 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * 4.2748832840600255e+69))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 54 * 4.2748832840600255e+69 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * 2.308436973392414e+71)))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 54 * 4.2748832840600255e+69 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * 2.308436973392414e+71)))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 55 * 2.308436973392414e+71 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * 1.2696403353658276e+73))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 55 * 2.308436973392414e+71 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * 1.2696403353658276e+73))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 56 * 1.2696403353658276e+73 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * 7.109985878048635e+74)))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 56 * 1.2696403353658276e+73 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * 7.109985878048635e+74)))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 57 * 7.109985878048635e+74 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * 4.052691950487722e+76))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 57 * 7.109985878048635e+74 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * 4.052691950487722e+76))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 58 * 4.052691950487722e+76 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * 2.350561331282879e+78)))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 58 * 4.052691950487722e+76 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * 2.350561331282879e+78)))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 59 * 2.350561331282879e+78 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * 1.3868311854568986e+80))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 59 * 2.350561331282879e+78 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * 1.3868311854568986e+80))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 60 * 1.3868311854568986e+80 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * 8.320987112741392e+81)))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 60 * 1.3868311854568986e+80 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * 8.320987112741392e+81)))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 61 * 8.320987112741392e+81 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * 5.075802138772248e+83))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 61 * 8.320987112741392e+81 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * 5.075802138772248e+83))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 62 * 5.075802138772248e+83 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * 3.146997326038794e+85)))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 62 * 5.075802138772248e+83 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * 3.146997326038794e+85)))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 63 * 3.146997326038794e+85 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * 1.98260831540444e+87))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 63 * 3.146997326038794e+85 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * 1.98260831540444e+87))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 64 * 1.98260831540444e+87 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * 1.2688693218588417e+89)))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 64 * 1.98260831540444e+87 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * 1.2688693218588417e+89)))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 65 * 1.2688693218588417e+89 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * 8.247650592082472e+90))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 65 * 1.2688693218588417e+89 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * 8.247650592082472e+90))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 66 * 8.247650592082472e+90 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * 5.443449390774431e+92)))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 66 * 8.247650592082472e+90 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * 5.443449390774431e+92)))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 67 * 5.443449390774431e+92 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * 3.647111091818868e+94))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 67 * 5.443449390774431e+92 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * 3.647111091818868e+94))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 68 * 3.647111091818868e+94 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * 2.4800355424368305e+96)))))))))))))))))))))))))))))));
[afterMarker] Binary expression 68 * 3.647111091818868e+94 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * 2.4800355424368305e+96)))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 69 * 2.4800355424368305e+96 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * 1.711224524281413e+98))))))))))))))))))))))))))))));
[afterMarker] Binary expression 69 * 2.4800355424368305e+96 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * 1.711224524281413e+98))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 70 * 1.711224524281413e+98 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * 1.197857166996989e+100)))))))))))))))))))))))))))));
[afterMarker] Binary expression 70 * 1.711224524281413e+98 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * 1.197857166996989e+100)))))))))))))))))))))))))))));
[beforeMarker] Binary expression 71 * 1.197857166996989e+100 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * 8.504785885678622e+101))))))))))))))))))))))))))));
[afterMarker] Binary expression 71 * 1.197857166996989e+100 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * 8.504785885678622e+101))))))))))))))))))))))))))));
[beforeMarker] Binary expression 72 * 8.504785885678622e+101 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * 6.123445837688608e+103)))))))))))))))))))))))))));
[afterMarker] Binary expression 72 * 8.504785885678622e+101 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * 6.123445837688608e+103)))))))))))))))))))))))))));
[beforeMarker] Binary expression 73 * 6.123445837688608e+103 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * 4.4701154615126834e+105))))))))))))))))))))))))));
[afterMarker] Binary expression 73 * 6.123445837688608e+103 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * 4.4701154615126834e+105))))))))))))))))))))))))));
[beforeMarker] Binary expression 74 * 4.4701154615126834e+105 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * 3.3078854415193856e+107)))))))))))))))))))))))));
[afterMarker] Binary expression 74 * 4.4701154615126834e+105 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * 3.3078854415193856e+107)))))))))))))))))))))))));
[beforeMarker] Binary expression 75 * 3.3078854415193856e+107 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * 2.480914081139539e+109))))))))))))))))))))))));
[afterMarker] Binary expression 75 * 3.3078854415193856e+107 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * 2.480914081139539e+109))))))))))))))))))))))));
[beforeMarker] Binary expression 76 * 2.480914081139539e+109 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * 1.8854947016660498e+111)))))))))))))))))))))));
[afterMarker] Binary expression 76 * 2.480914081139539e+109 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * 1.8854947016660498e+111)))))))))))))))))))))));
[beforeMarker] Binary expression 77 * 1.8854947016660498e+111 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * 1.4518309202828584e+113))))))))))))))))))))));
[afterMarker] Binary expression 77 * 1.8854947016660498e+111 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * 1.4518309202828584e+113))))))))))))))))))))));
[beforeMarker] Binary expression 78 * 1.4518309202828584e+113 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * 1.1324281178206295e+115)))))))))))))))))))));
[afterMarker] Binary expression 78 * 1.4518309202828584e+113 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * 1.1324281178206295e+115)))))))))))))))))))));
[beforeMarker] Binary expression 79 * 1.1324281178206295e+115 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * 8.946182130782973e+116))))))))))))))))))));
[afterMarker] Binary expression 79 * 1.1324281178206295e+115 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * 8.946182130782973e+116))))))))))))))))))));
[beforeMarker] Binary expression 80 * 8.946182130782973e+116 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * 7.156945704626378e+118)))))))))))))))))));
[afterMarker] Binary expression 80 * 8.946182130782973e+116 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * 7.156945704626378e+118)))))))))))))))))));
[beforeMarker] Binary expression 81 * 7.156945704626378e+118 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * 5.797126020747366e+120))))))))))))))))));
[afterMarker] Binary expression 81 * 7.156945704626378e+118 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * 5.797126020747366e+120))))))))))))))))));
[beforeMarker] Binary expression 82 * 5.797126020747366e+120 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * 4.75364333701284e+122)))))))))))))))));
[afterMarker] Binary expression 82 * 5.797126020747366e+120 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * 4.75364333701284e+122)))))))))))))))));
[beforeMarker] Binary expression 83 * 4.75364333701284e+122 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * 3.945523969720657e+124))))))))))))))));
[afterMarker] Binary expression 83 * 4.75364333701284e+122 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * 3.945523969720657e+124))))))))))))))));
[beforeMarker] Binary expression 84 * 3.945523969720657e+124 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * 3.314240134565352e+126)))))))))))))));
[afterMarker] Binary expression 84 * 3.945523969720657e+124 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * 3.314240134565352e+126)))))))))))))));
[beforeMarker] Binary expression 85 * 3.314240134565352e+126 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * 2.8171041143805494e+128))))))))))))));
[afterMarker] Binary expression 85 * 3.314240134565352e+126 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * 2.8171041143805494e+128))))))))))))));
[beforeMarker] Binary expression 86 * 2.8171041143805494e+128 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * 2.4227095383672724e+130)))))))))))));
[afterMarker] Binary expression 86 * 2.8171041143805494e+128 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * 2.4227095383672724e+130)))))))))))));
[beforeMarker] Binary expression 87 * 2.4227095383672724e+130 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * 2.107757298379527e+132))))))))))));
[afterMarker] Binary expression 87 * 2.4227095383672724e+130 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * 2.107757298379527e+132))))))))))));
[beforeMarker] Binary expression 88 * 2.107757298379527e+132 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * 1.8548264225739836e+134)))))))))));
[afterMarker] Binary expression 88 * 2.107757298379527e+132 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * 1.8548264225739836e+134)))))))))));
[beforeMarker] Binary expression 89 * 1.8548264225739836e+134 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * 1.6507955160908452e+136))))))))));
[afterMarker] Binary expression 89 * 1.8548264225739836e+134 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * 1.6507955160908452e+136))))))))));
[beforeMarker] Binary expression 90 * 1.6507955160908452e+136 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * 1.4857159644817607e+138)))))))));
[afterMarker] Binary expression 90 * 1.6507955160908452e+136 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * 1.4857159644817607e+138)))))))));
[beforeMarker] Binary expression 91 * 1.4857159644817607e+138 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * 1.3520015276784023e+140))))))));
[afterMarker] Binary expression 91 * 1.4857159644817607e+138 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * 1.3520015276784023e+140))))))));
[beforeMarker] Binary expression 92 * 1.3520015276784023e+140 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * 1.24384140546413e+142)))))));
[afterMarker] Binary expression 92 * 1.3520015276784023e+140 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * 1.24384140546413e+142)))))));
[beforeMarker] Binary expression 93 * 1.24384140546413e+142 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * 1.1567725070816409e+144))))));
[afterMarker] Binary expression 93 * 1.24384140546413e+142 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * 1.1567725070816409e+144))))));
[beforeMarker] Binary expression 94 * 1.1567725070816409e+144 evaluated

100 * (99 * (98 * (97 * (96 * (95 * 1.0873661566567424e+146)))));
[afterMarker] Binary expression 94 * 1.1567725070816409e+144 evaluated

100 * (99 * (98 * (97 * (96 * (95 * 1.0873661566567424e+146)))));
[beforeMarker] Binary expression 95 * 1.0873661566567424e+146 evaluated

100 * (99 * (98 * (97 * (96 * 1.0329978488239052e+148))));
[afterMarker] Binary expression 95 * 1.0873661566567424e+146 evaluated

100 * (99 * (98 * (97 * (96 * 1.0329978488239052e+148))));
[beforeMarker] Binary expression 96 * 1.0329978488239052e+148 evaluated

100 * (99 * (98 * (97 * 9.916779348709491e+149)));
[afterMarker] Binary expression 96 * 1.0329978488239052e+148 evaluated

100 * (99 * (98 * (97 * 9.916779348709491e+149)));
[beforeMarker] Binary expression 97 * 9.916779348709491e+149 evaluated

100 * (99 * (98 * 9.619275968248206e+151));
[afterMarker] Binary expression 97 * 9.916779348709491e+149 evaluated

100 * (99 * (98 * 9.619275968248206e+151));
[beforeMarker] Binary expression 98 * 9.619275968248206e+151 evaluated

100 * (99 * 9.426890448883242e+153);
[afterMarker] Binary expression 98 * 9.619275968248206e+151 evaluated

100 * (99 * 9.426890448883242e+153);
[beforeMarker] Binary expression 99 * 9.426890448883242e+153 evaluated

100 * 9.33262154439441e+155;
[afterMarker] Binary expression 99 * 9.426890448883242e+153 evaluated

100 * 9.33262154439441e+155;
[beforeMarker] Binary expression 100 * 9.33262154439441e+155 evaluated

9.33262154439441e+157;
[afterMarker] Binary expression 100 * 9.33262154439441e+155 evaluated

9.33262154439441e+157;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming Avoiding naming conflicts 1`] = `
"const f = (x_1, x_3, x_2) => g();const g = () => x_1 + x_3 + x_2;const x_1 = 1;const x_3 = 3;const x_2 = 2;f(0, 1, 2);
[noMarker] Start of evaluation

const f = (x_1, x_3, x_2) => g();const g = () => x_1 + x_3 + x_2;const x_1 = 1;const x_3 = 3;const x_2 = 2;f(0, 1, 2);
[beforeMarker] Constant f declared and substituted into the rest of block

const g = () => x_1 + x_3 + x_2;const x_1 = 1;const x_3 = 3;const x_2 = 2;((x_1, x_3, x_2) => g())(0, 1, 2);
[afterMarker] Constant f declared and substituted into the rest of block

const g = () => x_1 + x_3 + x_2;const x_1 = 1;const x_3 = 3;const x_2 = 2;((x_1, x_3, x_2) => g())(0, 1, 2);
[beforeMarker] Constant g declared and substituted into the rest of block

const x_1 = 1;const x_3 = 3;const x_2 = 2;((x_4, x_5, x_6) => (() => x_1 + x_3 + x_2)())(0, 1, 2);
[afterMarker] Constant g declared and substituted into the rest of block

const x_1 = 1;const x_3 = 3;const x_2 = 2;((x_4, x_5, x_6) => (() => x_1 + x_3 + x_2)())(0, 1, 2);
[beforeMarker] Constant x_1 declared and substituted into the rest of block

const x_3 = 3;const x_2 = 2;((x_4, x_5, x_6) => (() => 1 + x_3 + x_2)())(0, 1, 2);
[afterMarker] Constant x_1 declared and substituted into the rest of block

const x_3 = 3;const x_2 = 2;((x_4, x_5, x_6) => (() => 1 + x_3 + x_2)())(0, 1, 2);
[beforeMarker] Constant x_3 declared and substituted into the rest of block

const x_2 = 2;((x_4, x_5, x_6) => (() => 1 + 3 + x_2)())(0, 1, 2);
[afterMarker] Constant x_3 declared and substituted into the rest of block

const x_2 = 2;((x_4, x_5, x_6) => (() => 1 + 3 + x_2)())(0, 1, 2);
[beforeMarker] Constant x_2 declared and substituted into the rest of block

((x_4, x_5, x_6) => (() => 1 + 3 + 2)())(0, 1, 2);
[afterMarker] Constant x_2 declared and substituted into the rest of block

((x_4, x_5, x_6) => (() => 1 + 3 + 2)())(0, 1, 2);
[beforeMarker] 0, 1, 2 substituted into x_4, x_5, x_6 of (x_4, x_5, x_6) => (() => 1 + 3 + 2)()

(() => 1 + 3 + 2)();
[afterMarker] 0, 1, 2 substituted into x_4, x_5, x_6 of (x_4, x_5, x_6) => (() => 1 + 3 + 2)()

(() => 1 + 3 + 2)();
[beforeMarker] () => 1 + 3 + 2 runs

1 + 3 + 2;
[afterMarker] () => 1 + 3 + 2 runs

1 + 3 + 2;
[beforeMarker] Binary expression 1 + 3 evaluated

4 + 2;
[afterMarker] Binary expression 1 + 3 evaluated

4 + 2;
[beforeMarker] Binary expression 4 + 2 evaluated

6;
[afterMarker] Binary expression 4 + 2 evaluated

6;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming Basic 1`] = `
"const f = x => g();const g = () => x;const x = 1;f(0);
[noMarker] Start of evaluation

const f = x => g();const g = () => x;const x = 1;f(0);
[beforeMarker] Constant f declared and substituted into the rest of block

const g = () => x;const x = 1;(x => g())(0);
[afterMarker] Constant f declared and substituted into the rest of block

const g = () => x;const x = 1;(x => g())(0);
[beforeMarker] Constant g declared and substituted into the rest of block

const x = 1;(x_1 => (() => x)())(0);
[afterMarker] Constant g declared and substituted into the rest of block

const x = 1;(x_1 => (() => x)())(0);
[beforeMarker] Constant x declared and substituted into the rest of block

(x_1 => (() => 1)())(0);
[afterMarker] Constant x declared and substituted into the rest of block

(x_1 => (() => 1)())(0);
[beforeMarker] 0 substituted into x_1 of x_1 => (() => 1)()

(() => 1)();
[afterMarker] 0 substituted into x_1 of x_1 => (() => 1)()

(() => 1)();
[beforeMarker] () => 1 runs

1;
[afterMarker] () => 1 runs

1;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming multiple clash 2 for function declaration 1`] = `
"function g() { return x + x_1;}function f(x) { function h(x_1) { return x_2 + g(); } return h;}const x_2 = 0;const x_1 = 2;const x = 1;f(1)(1);
[noMarker] Start of evaluation

function g() { return x + x_1;}function f(x) { function h(x_1) { return x_2 + g(); } return h;}const x_2 = 0;const x_1 = 2;const x = 1;f(1)(1);
[beforeMarker] Function g declared, parameter(s)  required

function f(x_3) { function h(x_3) { return x_2 + (() => { return x + x_1; })(); } return h;}const x_2 = 0;const x_1 = 2;const x = 1;f(1)(1);
[afterMarker] Function g declared, parameter(s)  required

function f(x_3) { function h(x_3) { return x_2 + (() => { return x + x_1; })(); } return h;}const x_2 = 0;const x_1 = 2;const x = 1;f(1)(1);
[beforeMarker] Function f declared, parameter(s) x_3 required

const x_2 = 0;const x_1 = 2;const x = 1;(x_3 => { function h(x_3) { return x_2 + (() => { return x + x_1; })(); } return h;})(1)(1);
[afterMarker] Function f declared, parameter(s) x_3 required

const x_2 = 0;const x_1 = 2;const x = 1;(x_3 => { function h(x_3) { return x_2 + (() => { return x + x_1; })(); } return h;})(1)(1);
[beforeMarker] Constant x_2 declared and substituted into the rest of block

const x_1 = 2;const x = 1;(x_3 => { function h(x_3) { return 0 + (() => { return x + x_1; })(); } return h;})(1)(1);
[afterMarker] Constant x_2 declared and substituted into the rest of block

const x_1 = 2;const x = 1;(x_3 => { function h(x_3) { return 0 + (() => { return x + x_1; })(); } return h;})(1)(1);
[beforeMarker] Constant x_1 declared and substituted into the rest of block

const x = 1;(x_3 => { function h(x_3) { return 0 + (() => { return x + 2; })(); } return h;})(1)(1);
[afterMarker] Constant x_1 declared and substituted into the rest of block

const x = 1;(x_3 => { function h(x_3) { return 0 + (() => { return x + 2; })(); } return h;})(1)(1);
[beforeMarker] Constant x declared and substituted into the rest of block

(x_3 => { function h(x_3) { return 0 + (() => { return 1 + 2; })(); } return h;})(1)(1);
[afterMarker] Constant x declared and substituted into the rest of block

(x_3 => { function h(x_3) { return 0 + (() => { return 1 + 2; })(); } return h;})(1)(1);
[beforeMarker] Function f, defined as x_3 => {...}, takes in x_3 as input 1

{ function h(x_3) { return 0 + (() => { return 1 + 2; })(); } return h;}(1);
[afterMarker] Function f, defined as x_3 => {...}, takes in x_3 as input 1

{ function h(x_3) { return 0 + (() => { return 1 + 2; })(); } return h;}(1);
[beforeMarker] Function h declared, parameter(s) x_3 required

{ return x_3 => { return 0 + (() => { return 1 + 2; })(); };}(1);
[afterMarker] Function h declared, parameter(s) x_3 required

{ return x_3 => { return 0 + (() => { return 1 + 2; })(); };}(1);
[beforeMarker] x_3 => {
  return 0 + (() => {
    return 1 + 2;
  })();
} returned

(x_3 => { return 0 + (() => { return 1 + 2; })();})(1);
[afterMarker] x_3 => {
  return 0 + (() => {
    return 1 + 2;
  })();
} returned

(x_3 => { return 0 + (() => { return 1 + 2; })();})(1);
[beforeMarker] Function h, defined as x_3 => {...}, takes in x_3 as input 1

0 + (() => { return 1 + 2;})();
[afterMarker] Function h, defined as x_3 => {...}, takes in x_3 as input 1

0 + (() => { return 1 + 2;})();
[beforeMarker] () => {...} runs

0 + (1 + 2);
[afterMarker] () => {...} runs

0 + (1 + 2);
[beforeMarker] Binary expression 1 + 2 evaluated

0 + 3;
[afterMarker] Binary expression 1 + 2 evaluated

0 + 3;
[beforeMarker] Binary expression 0 + 3 evaluated

3;
[afterMarker] Binary expression 0 + 3 evaluated

3;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming multiple clash 2 for function expression 1`] = `
"function f(x) { function h(x_1) { return x_2 + g(); } return h;}function g() { return x + x_1;}const x_2 = 0;const x_1 = 2;const x = 1;f(1)(1);
[noMarker] Start of evaluation

function f(x) { function h(x_1) { return x_2 + g(); } return h;}function g() { return x + x_1;}const x_2 = 0;const x_1 = 2;const x = 1;f(1)(1);
[beforeMarker] Function f declared, parameter(s) x required

function g() { return x + x_1;}const x_2 = 0;const x_1 = 2;const x = 1;(x => { function h(x_1) { return x_2 + g(); } return h;})(1)(1);
[afterMarker] Function f declared, parameter(s) x required

function g() { return x + x_1;}const x_2 = 0;const x_1 = 2;const x = 1;(x => { function h(x_1) { return x_2 + g(); } return h;})(1)(1);
[beforeMarker] Function g declared, parameter(s)  required

const x_2 = 0;const x_1 = 2;const x = 1;(x_3 => { function h(x_3) { return x_2 + (() => { return x + x_1; })(); } return h;})(1)(1);
[afterMarker] Function g declared, parameter(s)  required

const x_2 = 0;const x_1 = 2;const x = 1;(x_3 => { function h(x_3) { return x_2 + (() => { return x + x_1; })(); } return h;})(1)(1);
[beforeMarker] Constant x_2 declared and substituted into the rest of block

const x_1 = 2;const x = 1;(x_3 => { function h(x_3) { return 0 + (() => { return x + x_1; })(); } return h;})(1)(1);
[afterMarker] Constant x_2 declared and substituted into the rest of block

const x_1 = 2;const x = 1;(x_3 => { function h(x_3) { return 0 + (() => { return x + x_1; })(); } return h;})(1)(1);
[beforeMarker] Constant x_1 declared and substituted into the rest of block

const x = 1;(x_3 => { function h(x_3) { return 0 + (() => { return x + 2; })(); } return h;})(1)(1);
[afterMarker] Constant x_1 declared and substituted into the rest of block

const x = 1;(x_3 => { function h(x_3) { return 0 + (() => { return x + 2; })(); } return h;})(1)(1);
[beforeMarker] Constant x declared and substituted into the rest of block

(x_3 => { function h(x_3) { return 0 + (() => { return 1 + 2; })(); } return h;})(1)(1);
[afterMarker] Constant x declared and substituted into the rest of block

(x_3 => { function h(x_3) { return 0 + (() => { return 1 + 2; })(); } return h;})(1)(1);
[beforeMarker] Function f, defined as x_3 => {...}, takes in x_3 as input 1

{ function h(x_3) { return 0 + (() => { return 1 + 2; })(); } return h;}(1);
[afterMarker] Function f, defined as x_3 => {...}, takes in x_3 as input 1

{ function h(x_3) { return 0 + (() => { return 1 + 2; })(); } return h;}(1);
[beforeMarker] Function h declared, parameter(s) x_3 required

{ return x_3 => { return 0 + (() => { return 1 + 2; })(); };}(1);
[afterMarker] Function h declared, parameter(s) x_3 required

{ return x_3 => { return 0 + (() => { return 1 + 2; })(); };}(1);
[beforeMarker] x_3 => {
  return 0 + (() => {
    return 1 + 2;
  })();
} returned

(x_3 => { return 0 + (() => { return 1 + 2; })();})(1);
[afterMarker] x_3 => {
  return 0 + (() => {
    return 1 + 2;
  })();
} returned

(x_3 => { return 0 + (() => { return 1 + 2; })();})(1);
[beforeMarker] Function h, defined as x_3 => {...}, takes in x_3 as input 1

0 + (() => { return 1 + 2;})();
[afterMarker] Function h, defined as x_3 => {...}, takes in x_3 as input 1

0 + (() => { return 1 + 2;})();
[beforeMarker] () => {...} runs

0 + (1 + 2);
[afterMarker] () => {...} runs

0 + (1 + 2);
[beforeMarker] Binary expression 1 + 2 evaluated

0 + 3;
[afterMarker] Binary expression 1 + 2 evaluated

0 + 3;
[beforeMarker] Binary expression 0 + 3 evaluated

3;
[afterMarker] Binary expression 0 + 3 evaluated

3;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming multiple clash 2 for lambda function 1`] = `
"const f = x => x_1 => x_2 + g();const g = () => x + x_1;const x_2 = 0;const x_1 = 2;const x = 1;f(1)(1);
[noMarker] Start of evaluation

const f = x => x_1 => x_2 + g();const g = () => x + x_1;const x_2 = 0;const x_1 = 2;const x = 1;f(1)(1);
[beforeMarker] Constant f declared and substituted into the rest of block

const g = () => x + x_1;const x_2 = 0;const x_1 = 2;const x = 1;(x => x_1 => x_2 + g())(1)(1);
[afterMarker] Constant f declared and substituted into the rest of block

const g = () => x + x_1;const x_2 = 0;const x_1 = 2;const x = 1;(x => x_1 => x_2 + g())(1)(1);
[beforeMarker] Constant g declared and substituted into the rest of block

const x_2 = 0;const x_1 = 2;const x = 1;(x_3 => x_4 => x_2 + (() => x + x_1)())(1)(1);
[afterMarker] Constant g declared and substituted into the rest of block

const x_2 = 0;const x_1 = 2;const x = 1;(x_3 => x_4 => x_2 + (() => x + x_1)())(1)(1);
[beforeMarker] Constant x_2 declared and substituted into the rest of block

const x_1 = 2;const x = 1;(x_3 => x_4 => 0 + (() => x + x_1)())(1)(1);
[afterMarker] Constant x_2 declared and substituted into the rest of block

const x_1 = 2;const x = 1;(x_3 => x_4 => 0 + (() => x + x_1)())(1)(1);
[beforeMarker] Constant x_1 declared and substituted into the rest of block

const x = 1;(x_3 => x_4 => 0 + (() => x + 2)())(1)(1);
[afterMarker] Constant x_1 declared and substituted into the rest of block

const x = 1;(x_3 => x_4 => 0 + (() => x + 2)())(1)(1);
[beforeMarker] Constant x declared and substituted into the rest of block

(x_3 => x_4 => 0 + (() => 1 + 2)())(1)(1);
[afterMarker] Constant x declared and substituted into the rest of block

(x_3 => x_4 => 0 + (() => 1 + 2)())(1)(1);
[beforeMarker] 1 substituted into x_3 of x_3 => x_4 => 0 + (() => 1 + 2)()

(x_4 => 0 + (() => 1 + 2)())(1);
[afterMarker] 1 substituted into x_3 of x_3 => x_4 => 0 + (() => 1 + 2)()

(x_4 => 0 + (() => 1 + 2)())(1);
[beforeMarker] 1 substituted into x_4 of x_4 => 0 + (() => 1 + 2)()

0 + (() => 1 + 2)();
[afterMarker] 1 substituted into x_4 of x_4 => 0 + (() => 1 + 2)()

0 + (() => 1 + 2)();
[beforeMarker] () => 1 + 2 runs

0 + (1 + 2);
[afterMarker] () => 1 + 2 runs

0 + (1 + 2);
[beforeMarker] Binary expression 1 + 2 evaluated

0 + 3;
[afterMarker] Binary expression 1 + 2 evaluated

0 + 3;
[beforeMarker] Binary expression 0 + 3 evaluated

3;
[afterMarker] Binary expression 0 + 3 evaluated

3;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming multiple clash for function declaration 1`] = `
"function g() { return x_2 + x_3;}function f(x_2) { function h(x_3) { return x_4 + g(); } return h;}const x_3 = 0;const x_2 = 2;const x_4 = 2;f(1)(1);
[noMarker] Start of evaluation

function g() { return x_2 + x_3;}function f(x_2) { function h(x_3) { return x_4 + g(); } return h;}const x_3 = 0;const x_2 = 2;const x_4 = 2;f(1)(1);
[beforeMarker] Function g declared, parameter(s)  required

function f(x_5) { function h(x_5) { return x_4 + (() => { return x_2 + x_3; })(); } return h;}const x_3 = 0;const x_2 = 2;const x_4 = 2;f(1)(1);
[afterMarker] Function g declared, parameter(s)  required

function f(x_5) { function h(x_5) { return x_4 + (() => { return x_2 + x_3; })(); } return h;}const x_3 = 0;const x_2 = 2;const x_4 = 2;f(1)(1);
[beforeMarker] Function f declared, parameter(s) x_5 required

const x_3 = 0;const x_2 = 2;const x_4 = 2;(x_5 => { function h(x_5) { return x_4 + (() => { return x_2 + x_3; })(); } return h;})(1)(1);
[afterMarker] Function f declared, parameter(s) x_5 required

const x_3 = 0;const x_2 = 2;const x_4 = 2;(x_5 => { function h(x_5) { return x_4 + (() => { return x_2 + x_3; })(); } return h;})(1)(1);
[beforeMarker] Constant x_3 declared and substituted into the rest of block

const x_2 = 2;const x_4 = 2;(x_5 => { function h(x_5) { return x_4 + (() => { return x_2 + 0; })(); } return h;})(1)(1);
[afterMarker] Constant x_3 declared and substituted into the rest of block

const x_2 = 2;const x_4 = 2;(x_5 => { function h(x_5) { return x_4 + (() => { return x_2 + 0; })(); } return h;})(1)(1);
[beforeMarker] Constant x_2 declared and substituted into the rest of block

const x_4 = 2;(x_5 => { function h(x_5) { return x_4 + (() => { return 2 + 0; })(); } return h;})(1)(1);
[afterMarker] Constant x_2 declared and substituted into the rest of block

const x_4 = 2;(x_5 => { function h(x_5) { return x_4 + (() => { return 2 + 0; })(); } return h;})(1)(1);
[beforeMarker] Constant x_4 declared and substituted into the rest of block

(x_5 => { function h(x_5) { return 2 + (() => { return 2 + 0; })(); } return h;})(1)(1);
[afterMarker] Constant x_4 declared and substituted into the rest of block

(x_5 => { function h(x_5) { return 2 + (() => { return 2 + 0; })(); } return h;})(1)(1);
[beforeMarker] Function f, defined as x_5 => {...}, takes in x_5 as input 1

{ function h(x_5) { return 2 + (() => { return 2 + 0; })(); } return h;}(1);
[afterMarker] Function f, defined as x_5 => {...}, takes in x_5 as input 1

{ function h(x_5) { return 2 + (() => { return 2 + 0; })(); } return h;}(1);
[beforeMarker] Function h declared, parameter(s) x_5 required

{ return x_5 => { return 2 + (() => { return 2 + 0; })(); };}(1);
[afterMarker] Function h declared, parameter(s) x_5 required

{ return x_5 => { return 2 + (() => { return 2 + 0; })(); };}(1);
[beforeMarker] x_5 => {
  return 2 + (() => {
    return 2 + 0;
  })();
} returned

(x_5 => { return 2 + (() => { return 2 + 0; })();})(1);
[afterMarker] x_5 => {
  return 2 + (() => {
    return 2 + 0;
  })();
} returned

(x_5 => { return 2 + (() => { return 2 + 0; })();})(1);
[beforeMarker] Function h, defined as x_5 => {...}, takes in x_5 as input 1

2 + (() => { return 2 + 0;})();
[afterMarker] Function h, defined as x_5 => {...}, takes in x_5 as input 1

2 + (() => { return 2 + 0;})();
[beforeMarker] () => {...} runs

2 + (2 + 0);
[afterMarker] () => {...} runs

2 + (2 + 0);
[beforeMarker] Binary expression 2 + 0 evaluated

2 + 2;
[afterMarker] Binary expression 2 + 0 evaluated

2 + 2;
[beforeMarker] Binary expression 2 + 2 evaluated

4;
[afterMarker] Binary expression 2 + 2 evaluated

4;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming multiple clash for function expression 1`] = `
"function f(x_2) { function h(x_3) { return x_4 + g(); } return h;}function g() { return x_2 + x_3;}const x_3 = 0;const x_2 = 2;const x_4 = 2;f(1)(1);
[noMarker] Start of evaluation

function f(x_2) { function h(x_3) { return x_4 + g(); } return h;}function g() { return x_2 + x_3;}const x_3 = 0;const x_2 = 2;const x_4 = 2;f(1)(1);
[beforeMarker] Function f declared, parameter(s) x_2 required

function g() { return x_2 + x_3;}const x_3 = 0;const x_2 = 2;const x_4 = 2;(x_2 => { function h(x_3) { return x_4 + g(); } return h;})(1)(1);
[afterMarker] Function f declared, parameter(s) x_2 required

function g() { return x_2 + x_3;}const x_3 = 0;const x_2 = 2;const x_4 = 2;(x_2 => { function h(x_3) { return x_4 + g(); } return h;})(1)(1);
[beforeMarker] Function g declared, parameter(s)  required

const x_3 = 0;const x_2 = 2;const x_4 = 2;(x_5 => { function h(x_5) { return x_4 + (() => { return x_2 + x_3; })(); } return h;})(1)(1);
[afterMarker] Function g declared, parameter(s)  required

const x_3 = 0;const x_2 = 2;const x_4 = 2;(x_5 => { function h(x_5) { return x_4 + (() => { return x_2 + x_3; })(); } return h;})(1)(1);
[beforeMarker] Constant x_3 declared and substituted into the rest of block

const x_2 = 2;const x_4 = 2;(x_5 => { function h(x_5) { return x_4 + (() => { return x_2 + 0; })(); } return h;})(1)(1);
[afterMarker] Constant x_3 declared and substituted into the rest of block

const x_2 = 2;const x_4 = 2;(x_5 => { function h(x_5) { return x_4 + (() => { return x_2 + 0; })(); } return h;})(1)(1);
[beforeMarker] Constant x_2 declared and substituted into the rest of block

const x_4 = 2;(x_5 => { function h(x_5) { return x_4 + (() => { return 2 + 0; })(); } return h;})(1)(1);
[afterMarker] Constant x_2 declared and substituted into the rest of block

const x_4 = 2;(x_5 => { function h(x_5) { return x_4 + (() => { return 2 + 0; })(); } return h;})(1)(1);
[beforeMarker] Constant x_4 declared and substituted into the rest of block

(x_5 => { function h(x_5) { return 2 + (() => { return 2 + 0; })(); } return h;})(1)(1);
[afterMarker] Constant x_4 declared and substituted into the rest of block

(x_5 => { function h(x_5) { return 2 + (() => { return 2 + 0; })(); } return h;})(1)(1);
[beforeMarker] Function f, defined as x_5 => {...}, takes in x_5 as input 1

{ function h(x_5) { return 2 + (() => { return 2 + 0; })(); } return h;}(1);
[afterMarker] Function f, defined as x_5 => {...}, takes in x_5 as input 1

{ function h(x_5) { return 2 + (() => { return 2 + 0; })(); } return h;}(1);
[beforeMarker] Function h declared, parameter(s) x_5 required

{ return x_5 => { return 2 + (() => { return 2 + 0; })(); };}(1);
[afterMarker] Function h declared, parameter(s) x_5 required

{ return x_5 => { return 2 + (() => { return 2 + 0; })(); };}(1);
[beforeMarker] x_5 => {
  return 2 + (() => {
    return 2 + 0;
  })();
} returned

(x_5 => { return 2 + (() => { return 2 + 0; })();})(1);
[afterMarker] x_5 => {
  return 2 + (() => {
    return 2 + 0;
  })();
} returned

(x_5 => { return 2 + (() => { return 2 + 0; })();})(1);
[beforeMarker] Function h, defined as x_5 => {...}, takes in x_5 as input 1

2 + (() => { return 2 + 0;})();
[afterMarker] Function h, defined as x_5 => {...}, takes in x_5 as input 1

2 + (() => { return 2 + 0;})();
[beforeMarker] () => {...} runs

2 + (2 + 0);
[afterMarker] () => {...} runs

2 + (2 + 0);
[beforeMarker] Binary expression 2 + 0 evaluated

2 + 2;
[afterMarker] Binary expression 2 + 0 evaluated

2 + 2;
[beforeMarker] Binary expression 2 + 2 evaluated

4;
[afterMarker] Binary expression 2 + 2 evaluated

4;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming multiple clash for lambda function 1`] = `
"const f = x_2 => x_3 => x_4 + g();const g = () => x_2 + x_3;const x_3 = 0;const x_2 = 2;const x_4 = 2;f(1)(1);
[noMarker] Start of evaluation

const f = x_2 => x_3 => x_4 + g();const g = () => x_2 + x_3;const x_3 = 0;const x_2 = 2;const x_4 = 2;f(1)(1);
[beforeMarker] Constant f declared and substituted into the rest of block

const g = () => x_2 + x_3;const x_3 = 0;const x_2 = 2;const x_4 = 2;(x_2 => x_3 => x_4 + g())(1)(1);
[afterMarker] Constant f declared and substituted into the rest of block

const g = () => x_2 + x_3;const x_3 = 0;const x_2 = 2;const x_4 = 2;(x_2 => x_3 => x_4 + g())(1)(1);
[beforeMarker] Constant g declared and substituted into the rest of block

const x_3 = 0;const x_2 = 2;const x_4 = 2;(x_5 => x_6 => x_4 + (() => x_2 + x_3)())(1)(1);
[afterMarker] Constant g declared and substituted into the rest of block

const x_3 = 0;const x_2 = 2;const x_4 = 2;(x_5 => x_6 => x_4 + (() => x_2 + x_3)())(1)(1);
[beforeMarker] Constant x_3 declared and substituted into the rest of block

const x_2 = 2;const x_4 = 2;(x_5 => x_6 => x_4 + (() => x_2 + 0)())(1)(1);
[afterMarker] Constant x_3 declared and substituted into the rest of block

const x_2 = 2;const x_4 = 2;(x_5 => x_6 => x_4 + (() => x_2 + 0)())(1)(1);
[beforeMarker] Constant x_2 declared and substituted into the rest of block

const x_4 = 2;(x_5 => x_6 => x_4 + (() => 2 + 0)())(1)(1);
[afterMarker] Constant x_2 declared and substituted into the rest of block

const x_4 = 2;(x_5 => x_6 => x_4 + (() => 2 + 0)())(1)(1);
[beforeMarker] Constant x_4 declared and substituted into the rest of block

(x_5 => x_6 => 2 + (() => 2 + 0)())(1)(1);
[afterMarker] Constant x_4 declared and substituted into the rest of block

(x_5 => x_6 => 2 + (() => 2 + 0)())(1)(1);
[beforeMarker] 1 substituted into x_5 of x_5 => x_6 => 2 + (() => 2 + 0)()

(x_6 => 2 + (() => 2 + 0)())(1);
[afterMarker] 1 substituted into x_5 of x_5 => x_6 => 2 + (() => 2 + 0)()

(x_6 => 2 + (() => 2 + 0)())(1);
[beforeMarker] 1 substituted into x_6 of x_6 => 2 + (() => 2 + 0)()

2 + (() => 2 + 0)();
[afterMarker] 1 substituted into x_6 of x_6 => 2 + (() => 2 + 0)()

2 + (() => 2 + 0)();
[beforeMarker] () => 2 + 0 runs

2 + (2 + 0);
[afterMarker] () => 2 + 0 runs

2 + (2 + 0);
[beforeMarker] Binary expression 2 + 0 evaluated

2 + 2;
[afterMarker] Binary expression 2 + 0 evaluated

2 + 2;
[beforeMarker] Binary expression 2 + 2 evaluated

4;
[afterMarker] Binary expression 2 + 2 evaluated

4;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming multiple clash for lambda function with block expression 1`] = `
"const f = x => { const x_1 = 1; return x_1 => x_2 + g();};const g = () => x + x_1;const x_2 = 0;const x_1 = 2;const x = 1;f(1)(1);
[noMarker] Start of evaluation

const f = x => { const x_1 = 1; return x_1 => x_2 + g();};const g = () => x + x_1;const x_2 = 0;const x_1 = 2;const x = 1;f(1)(1);
[beforeMarker] Constant f declared and substituted into the rest of block

const g = () => x + x_1;const x_2 = 0;const x_1 = 2;const x = 1;(x => { const x_1 = 1; return x_1 => x_2 + g();})(1)(1);
[afterMarker] Constant f declared and substituted into the rest of block

const g = () => x + x_1;const x_2 = 0;const x_1 = 2;const x = 1;(x => { const x_1 = 1; return x_1 => x_2 + g();})(1)(1);
[beforeMarker] Constant g declared and substituted into the rest of block

const x_2 = 0;const x_1 = 2;const x = 1;(x_3 => { const x_4 = 1; return x_4 => x_2 + (() => x + x_1)();})(1)(1);
[afterMarker] Constant g declared and substituted into the rest of block

const x_2 = 0;const x_1 = 2;const x = 1;(x_3 => { const x_4 = 1; return x_4 => x_2 + (() => x + x_1)();})(1)(1);
[beforeMarker] Constant x_2 declared and substituted into the rest of block

const x_1 = 2;const x = 1;(x_3 => { const x_4 = 1; return x_4 => 0 + (() => x + x_1)();})(1)(1);
[afterMarker] Constant x_2 declared and substituted into the rest of block

const x_1 = 2;const x = 1;(x_3 => { const x_4 = 1; return x_4 => 0 + (() => x + x_1)();})(1)(1);
[beforeMarker] Constant x_1 declared and substituted into the rest of block

const x = 1;(x_3 => { const x_4 = 1; return x_4 => 0 + (() => x + 2)();})(1)(1);
[afterMarker] Constant x_1 declared and substituted into the rest of block

const x = 1;(x_3 => { const x_4 = 1; return x_4 => 0 + (() => x + 2)();})(1)(1);
[beforeMarker] Constant x declared and substituted into the rest of block

(x_3 => { const x_4 = 1; return x_4 => 0 + (() => 1 + 2)();})(1)(1);
[afterMarker] Constant x declared and substituted into the rest of block

(x_3 => { const x_4 = 1; return x_4 => 0 + (() => 1 + 2)();})(1)(1);
[beforeMarker] Function f, defined as x_3 => {...}, takes in x_3 as input 1

{ const x_4 = 1; return x_4 => 0 + (() => 1 + 2)();}(1);
[afterMarker] Function f, defined as x_3 => {...}, takes in x_3 as input 1

{ const x_4 = 1; return x_4 => 0 + (() => 1 + 2)();}(1);
[beforeMarker] Constant x_4 declared and substituted into the rest of block

{ return x_4 => 0 + (() => 1 + 2)();}(1);
[afterMarker] Constant x_4 declared and substituted into the rest of block

{ return x_4 => 0 + (() => 1 + 2)();}(1);
[beforeMarker] x_4 => 0 + (() => 1 + 2)() returned

(x_4 => 0 + (() => 1 + 2)())(1);
[afterMarker] x_4 => 0 + (() => 1 + 2)() returned

(x_4 => 0 + (() => 1 + 2)())(1);
[beforeMarker] 1 substituted into x_4 of x_4 => 0 + (() => 1 + 2)()

0 + (() => 1 + 2)();
[afterMarker] 1 substituted into x_4 of x_4 => 0 + (() => 1 + 2)()

0 + (() => 1 + 2)();
[beforeMarker] () => 1 + 2 runs

0 + (1 + 2);
[afterMarker] () => 1 + 2 runs

0 + (1 + 2);
[beforeMarker] Binary expression 1 + 2 evaluated

0 + 3;
[afterMarker] Binary expression 1 + 2 evaluated

0 + 3;
[beforeMarker] Binary expression 0 + 3 evaluated

3;
[afterMarker] Binary expression 0 + 3 evaluated

3;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming renaming clash in replacement for function declaration 1`] = `
"function g() { return x_1 + x_2;}function f(x_1) { function h(x_2) { return g(); } return h;}const x_1 = 0;const x_2 = 0;f(1)(1);
[noMarker] Start of evaluation

function g() { return x_1 + x_2;}function f(x_1) { function h(x_2) { return g(); } return h;}const x_1 = 0;const x_2 = 0;f(1)(1);
[beforeMarker] Function g declared, parameter(s)  required

function f(x_3) { function h(x_3) { return (() => { return x_1 + x_2; })(); } return h;}const x_1 = 0;const x_2 = 0;f(1)(1);
[afterMarker] Function g declared, parameter(s)  required

function f(x_3) { function h(x_3) { return (() => { return x_1 + x_2; })(); } return h;}const x_1 = 0;const x_2 = 0;f(1)(1);
[beforeMarker] Function f declared, parameter(s) x_3 required

const x_1 = 0;const x_2 = 0;(x_3 => { function h(x_3) { return (() => { return x_1 + x_2; })(); } return h;})(1)(1);
[afterMarker] Function f declared, parameter(s) x_3 required

const x_1 = 0;const x_2 = 0;(x_3 => { function h(x_3) { return (() => { return x_1 + x_2; })(); } return h;})(1)(1);
[beforeMarker] Constant x_1 declared and substituted into the rest of block

const x_2 = 0;(x_3 => { function h(x_3) { return (() => { return 0 + x_2; })(); } return h;})(1)(1);
[afterMarker] Constant x_1 declared and substituted into the rest of block

const x_2 = 0;(x_3 => { function h(x_3) { return (() => { return 0 + x_2; })(); } return h;})(1)(1);
[beforeMarker] Constant x_2 declared and substituted into the rest of block

(x_3 => { function h(x_3) { return (() => { return 0 + 0; })(); } return h;})(1)(1);
[afterMarker] Constant x_2 declared and substituted into the rest of block

(x_3 => { function h(x_3) { return (() => { return 0 + 0; })(); } return h;})(1)(1);
[beforeMarker] Function f, defined as x_3 => {...}, takes in x_3 as input 1

{ function h(x_3) { return (() => { return 0 + 0; })(); } return h;}(1);
[afterMarker] Function f, defined as x_3 => {...}, takes in x_3 as input 1

{ function h(x_3) { return (() => { return 0 + 0; })(); } return h;}(1);
[beforeMarker] Function h declared, parameter(s) x_3 required

{ return x_3 => { return (() => { return 0 + 0; })(); };}(1);
[afterMarker] Function h declared, parameter(s) x_3 required

{ return x_3 => { return (() => { return 0 + 0; })(); };}(1);
[beforeMarker] x_3 => {
  return (() => {
    return 0 + 0;
  })();
} returned

(x_3 => { return (() => { return 0 + 0; })();})(1);
[afterMarker] x_3 => {
  return (() => {
    return 0 + 0;
  })();
} returned

(x_3 => { return (() => { return 0 + 0; })();})(1);
[beforeMarker] Function h, defined as x_3 => {...}, takes in x_3 as input 1

(() => { return 0 + 0;})();
[afterMarker] Function h, defined as x_3 => {...}, takes in x_3 as input 1

(() => { return 0 + 0;})();
[beforeMarker] () => {...} runs

0 + 0;
[afterMarker] () => {...} runs

0 + 0;
[beforeMarker] Binary expression 0 + 0 evaluated

0;
[afterMarker] Binary expression 0 + 0 evaluated

0;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming renaming clash in replacement for function expression 1`] = `
"function f(x_1) { function h(x_2) { return g(); } return h;}function g() { return x_1 + x_2;}const x_1 = 0;const x_2 = 0;f(1)(1);
[noMarker] Start of evaluation

function f(x_1) { function h(x_2) { return g(); } return h;}function g() { return x_1 + x_2;}const x_1 = 0;const x_2 = 0;f(1)(1);
[beforeMarker] Function f declared, parameter(s) x_1 required

function g() { return x_1 + x_2;}const x_1 = 0;const x_2 = 0;(x_1 => { function h(x_2) { return g(); } return h;})(1)(1);
[afterMarker] Function f declared, parameter(s) x_1 required

function g() { return x_1 + x_2;}const x_1 = 0;const x_2 = 0;(x_1 => { function h(x_2) { return g(); } return h;})(1)(1);
[beforeMarker] Function g declared, parameter(s)  required

const x_1 = 0;const x_2 = 0;(x_3 => { function h(x_3) { return (() => { return x_1 + x_2; })(); } return h;})(1)(1);
[afterMarker] Function g declared, parameter(s)  required

const x_1 = 0;const x_2 = 0;(x_3 => { function h(x_3) { return (() => { return x_1 + x_2; })(); } return h;})(1)(1);
[beforeMarker] Constant x_1 declared and substituted into the rest of block

const x_2 = 0;(x_3 => { function h(x_3) { return (() => { return 0 + x_2; })(); } return h;})(1)(1);
[afterMarker] Constant x_1 declared and substituted into the rest of block

const x_2 = 0;(x_3 => { function h(x_3) { return (() => { return 0 + x_2; })(); } return h;})(1)(1);
[beforeMarker] Constant x_2 declared and substituted into the rest of block

(x_3 => { function h(x_3) { return (() => { return 0 + 0; })(); } return h;})(1)(1);
[afterMarker] Constant x_2 declared and substituted into the rest of block

(x_3 => { function h(x_3) { return (() => { return 0 + 0; })(); } return h;})(1)(1);
[beforeMarker] Function f, defined as x_3 => {...}, takes in x_3 as input 1

{ function h(x_3) { return (() => { return 0 + 0; })(); } return h;}(1);
[afterMarker] Function f, defined as x_3 => {...}, takes in x_3 as input 1

{ function h(x_3) { return (() => { return 0 + 0; })(); } return h;}(1);
[beforeMarker] Function h declared, parameter(s) x_3 required

{ return x_3 => { return (() => { return 0 + 0; })(); };}(1);
[afterMarker] Function h declared, parameter(s) x_3 required

{ return x_3 => { return (() => { return 0 + 0; })(); };}(1);
[beforeMarker] x_3 => {
  return (() => {
    return 0 + 0;
  })();
} returned

(x_3 => { return (() => { return 0 + 0; })();})(1);
[afterMarker] x_3 => {
  return (() => {
    return 0 + 0;
  })();
} returned

(x_3 => { return (() => { return 0 + 0; })();})(1);
[beforeMarker] Function h, defined as x_3 => {...}, takes in x_3 as input 1

(() => { return 0 + 0;})();
[afterMarker] Function h, defined as x_3 => {...}, takes in x_3 as input 1

(() => { return 0 + 0;})();
[beforeMarker] () => {...} runs

0 + 0;
[afterMarker] () => {...} runs

0 + 0;
[beforeMarker] Binary expression 0 + 0 evaluated

0;
[afterMarker] Binary expression 0 + 0 evaluated

0;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming renaming clash in replacement for lambda function 1`] = `
"const g = () => x_1 + x_2;const f = x_1 => x_2 => g();const x_1 = 0;const x_2 = 0;f(1)(1);
[noMarker] Start of evaluation

const g = () => x_1 + x_2;const f = x_1 => x_2 => g();const x_1 = 0;const x_2 = 0;f(1)(1);
[beforeMarker] Constant g declared and substituted into the rest of block

const f = x_3 => x_4 => (() => x_1 + x_2)();const x_1 = 0;const x_2 = 0;f(1)(1);
[afterMarker] Constant g declared and substituted into the rest of block

const f = x_3 => x_4 => (() => x_1 + x_2)();const x_1 = 0;const x_2 = 0;f(1)(1);
[beforeMarker] Constant f declared and substituted into the rest of block

const x_1 = 0;const x_2 = 0;(x_3 => x_4 => (() => x_1 + x_2)())(1)(1);
[afterMarker] Constant f declared and substituted into the rest of block

const x_1 = 0;const x_2 = 0;(x_3 => x_4 => (() => x_1 + x_2)())(1)(1);
[beforeMarker] Constant x_1 declared and substituted into the rest of block

const x_2 = 0;(x_3 => x_4 => (() => 0 + x_2)())(1)(1);
[afterMarker] Constant x_1 declared and substituted into the rest of block

const x_2 = 0;(x_3 => x_4 => (() => 0 + x_2)())(1)(1);
[beforeMarker] Constant x_2 declared and substituted into the rest of block

(x_3 => x_4 => (() => 0 + 0)())(1)(1);
[afterMarker] Constant x_2 declared and substituted into the rest of block

(x_3 => x_4 => (() => 0 + 0)())(1)(1);
[beforeMarker] 1 substituted into x_3 of x_3 => x_4 => (() => 0 + 0)()

(x_4 => (() => 0 + 0)())(1);
[afterMarker] 1 substituted into x_3 of x_3 => x_4 => (() => 0 + 0)()

(x_4 => (() => 0 + 0)())(1);
[beforeMarker] 1 substituted into x_4 of x_4 => (() => 0 + 0)()

(() => 0 + 0)();
[afterMarker] 1 substituted into x_4 of x_4 => (() => 0 + 0)()

(() => 0 + 0)();
[beforeMarker] () => 0 + 0 runs

0 + 0;
[afterMarker] () => 0 + 0 runs

0 + 0;
[beforeMarker] Binary expression 0 + 0 evaluated

0;
[afterMarker] Binary expression 0 + 0 evaluated

0;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming renaming clash test for functions 1`] = `
"function f(w_8) { function h(w_9) { return w_8 + w_9 + g(); } return h;}function g() { return w_9;}const w_9 = 0;f(1)(2);
[noMarker] Start of evaluation

function f(w_8) { function h(w_9) { return w_8 + w_9 + g(); } return h;}function g() { return w_9;}const w_9 = 0;f(1)(2);
[beforeMarker] Function f declared, parameter(s) w_8 required

function g() { return w_9;}const w_9 = 0;(w_8 => { function h(w_9) { return w_8 + w_9 + g(); } return h;})(1)(2);
[afterMarker] Function f declared, parameter(s) w_8 required

function g() { return w_9;}const w_9 = 0;(w_8 => { function h(w_9) { return w_8 + w_9 + g(); } return h;})(1)(2);
[beforeMarker] Function g declared, parameter(s)  required

const w_9 = 0;(w_8 => { function h(w_10) { return w_8 + w_10 + (() => { return w_9; })(); } return h;})(1)(2);
[afterMarker] Function g declared, parameter(s)  required

const w_9 = 0;(w_8 => { function h(w_10) { return w_8 + w_10 + (() => { return w_9; })(); } return h;})(1)(2);
[beforeMarker] Constant w_9 declared and substituted into the rest of block

(w_8 => { function h(w_10) { return w_8 + w_10 + (() => { return 0; })(); } return h;})(1)(2);
[afterMarker] Constant w_9 declared and substituted into the rest of block

(w_8 => { function h(w_10) { return w_8 + w_10 + (() => { return 0; })(); } return h;})(1)(2);
[beforeMarker] Function f, defined as w_8 => {...}, takes in w_8 as input 1

{ function h(w_10) { return 1 + w_10 + (() => { return 0; })(); } return h;}(2);
[afterMarker] Function f, defined as w_8 => {...}, takes in w_8 as input 1

{ function h(w_10) { return 1 + w_10 + (() => { return 0; })(); } return h;}(2);
[beforeMarker] Function h declared, parameter(s) w_10 required

{ return w_10 => { return 1 + w_10 + (() => { return 0; })(); };}(2);
[afterMarker] Function h declared, parameter(s) w_10 required

{ return w_10 => { return 1 + w_10 + (() => { return 0; })(); };}(2);
[beforeMarker] w_10 => {
  return 1 + w_10 + (() => {
    return 0;
  })();
} returned

(w_10 => { return 1 + w_10 + (() => { return 0; })();})(2);
[afterMarker] w_10 => {
  return 1 + w_10 + (() => {
    return 0;
  })();
} returned

(w_10 => { return 1 + w_10 + (() => { return 0; })();})(2);
[beforeMarker] Function h, defined as w_10 => {...}, takes in w_10 as input 2

1 + 2 + (() => { return 0;})();
[afterMarker] Function h, defined as w_10 => {...}, takes in w_10 as input 2

1 + 2 + (() => { return 0;})();
[beforeMarker] Binary expression 1 + 2 evaluated

3 + (() => { return 0;})();
[afterMarker] Binary expression 1 + 2 evaluated

3 + (() => { return 0;})();
[beforeMarker] () => {...} runs

3 + 0;
[afterMarker] () => {...} runs

3 + 0;
[beforeMarker] Binary expression 3 + 0 evaluated

3;
[afterMarker] Binary expression 3 + 0 evaluated

3;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming renaming clash test for lambda function 1`] = `
"const f = w_11 => w_10 => w_11 + w_10 + g();const g = () => w_10;const w_10 = 0;f(1)(2);
[noMarker] Start of evaluation

const f = w_11 => w_10 => w_11 + w_10 + g();const g = () => w_10;const w_10 = 0;f(1)(2);
[beforeMarker] Constant f declared and substituted into the rest of block

const g = () => w_10;const w_10 = 0;(w_11 => w_10 => w_11 + w_10 + g())(1)(2);
[afterMarker] Constant f declared and substituted into the rest of block

const g = () => w_10;const w_10 = 0;(w_11 => w_10 => w_11 + w_10 + g())(1)(2);
[beforeMarker] Constant g declared and substituted into the rest of block

const w_10 = 0;(w_11 => w_12 => w_11 + w_12 + (() => w_10)())(1)(2);
[afterMarker] Constant g declared and substituted into the rest of block

const w_10 = 0;(w_11 => w_12 => w_11 + w_12 + (() => w_10)())(1)(2);
[beforeMarker] Constant w_10 declared and substituted into the rest of block

(w_11 => w_12 => w_11 + w_12 + (() => 0)())(1)(2);
[afterMarker] Constant w_10 declared and substituted into the rest of block

(w_11 => w_12 => w_11 + w_12 + (() => 0)())(1)(2);
[beforeMarker] 1 substituted into w_11 of w_11 => w_12 => w_11 + w_12 + (() => 0)()

(w_12 => 1 + w_12 + (() => 0)())(2);
[afterMarker] 1 substituted into w_11 of w_11 => w_12 => w_11 + w_12 + (() => 0)()

(w_12 => 1 + w_12 + (() => 0)())(2);
[beforeMarker] 2 substituted into w_12 of w_12 => 1 + w_12 + (() => 0)()

1 + 2 + (() => 0)();
[afterMarker] 2 substituted into w_12 of w_12 => 1 + w_12 + (() => 0)()

1 + 2 + (() => 0)();
[beforeMarker] Binary expression 1 + 2 evaluated

3 + (() => 0)();
[afterMarker] Binary expression 1 + 2 evaluated

3 + (() => 0)();
[beforeMarker] () => 0 runs

3 + 0;
[afterMarker] () => 0 runs

3 + 0;
[beforeMarker] Binary expression 3 + 0 evaluated

3;
[afterMarker] Binary expression 3 + 0 evaluated

3;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming renaming clash with declaration in replacement for function declaration 1`] = `
"function g() { const x_2 = 2; return x_1 + x_2 + x;}function f(x) { function h(x_1) { return x + g(); } return h;}const x_1 = 0;const x = 0;f(1)(1);
[noMarker] Start of evaluation

function g() { const x_2 = 2; return x_1 + x_2 + x;}function f(x) { function h(x_1) { return x + g(); } return h;}const x_1 = 0;const x = 0;f(1)(1);
[beforeMarker] Function g declared, parameter(s)  required

function f(x_2) { function h(x_3) { return x_2 + (() => { const x_2 = 2; return x_1 + x_2 + x; })(); } return h;}const x_1 = 0;const x = 0;f(1)(1);
[afterMarker] Function g declared, parameter(s)  required

function f(x_2) { function h(x_3) { return x_2 + (() => { const x_2 = 2; return x_1 + x_2 + x; })(); } return h;}const x_1 = 0;const x = 0;f(1)(1);
[beforeMarker] Function f declared, parameter(s) x_2 required

const x_1 = 0;const x = 0;(x_2 => { function h(x_3) { return x_2 + (() => { const x_2 = 2; return x_1 + x_2 + x; })(); } return h;})(1)(1);
[afterMarker] Function f declared, parameter(s) x_2 required

const x_1 = 0;const x = 0;(x_2 => { function h(x_3) { return x_2 + (() => { const x_2 = 2; return x_1 + x_2 + x; })(); } return h;})(1)(1);
[beforeMarker] Constant x_1 declared and substituted into the rest of block

const x = 0;(x_2 => { function h(x_3) { return x_2 + (() => { const x_2 = 2; return 0 + x_2 + x; })(); } return h;})(1)(1);
[afterMarker] Constant x_1 declared and substituted into the rest of block

const x = 0;(x_2 => { function h(x_3) { return x_2 + (() => { const x_2 = 2; return 0 + x_2 + x; })(); } return h;})(1)(1);
[beforeMarker] Constant x declared and substituted into the rest of block

(x_2 => { function h(x_3) { return x_2 + (() => { const x_2 = 2; return 0 + x_2 + 0; })(); } return h;})(1)(1);
[afterMarker] Constant x declared and substituted into the rest of block

(x_2 => { function h(x_3) { return x_2 + (() => { const x_2 = 2; return 0 + x_2 + 0; })(); } return h;})(1)(1);
[beforeMarker] Function f, defined as x_2 => {...}, takes in x_2 as input 1

{ function h(x_3) { return 1 + (() => { const x_2 = 2; return 0 + x_2 + 0; })(); } return h;}(1);
[afterMarker] Function f, defined as x_2 => {...}, takes in x_2 as input 1

{ function h(x_3) { return 1 + (() => { const x_2 = 2; return 0 + x_2 + 0; })(); } return h;}(1);
[beforeMarker] Function h declared, parameter(s) x_3 required

{ return x_3 => { return 1 + (() => { const x_2 = 2; return 0 + x_2 + 0; })(); };}(1);
[afterMarker] Function h declared, parameter(s) x_3 required

{ return x_3 => { return 1 + (() => { const x_2 = 2; return 0 + x_2 + 0; })(); };}(1);
[beforeMarker] x_3 => {
  return 1 + (() => {
    const x_2 = 2;
    return 0 + x_2 + 0;
  })();
} returned

(x_3 => { return 1 + (() => { const x_2 = 2; return 0 + x_2 + 0; })();})(1);
[afterMarker] x_3 => {
  return 1 + (() => {
    const x_2 = 2;
    return 0 + x_2 + 0;
  })();
} returned

(x_3 => { return 1 + (() => { const x_2 = 2; return 0 + x_2 + 0; })();})(1);
[beforeMarker] Function h, defined as x_3 => {...}, takes in x_3 as input 1

1 + (() => { const x_2 = 2; return 0 + x_2 + 0;})();
[afterMarker] Function h, defined as x_3 => {...}, takes in x_3 as input 1

1 + (() => { const x_2 = 2; return 0 + x_2 + 0;})();
[beforeMarker] () => {...} runs

1 + { const x_2 = 2; return 0 + x_2 + 0;};
[afterMarker] () => {...} runs

1 + { const x_2 = 2; return 0 + x_2 + 0;};
[beforeMarker] Constant x_2 declared and substituted into the rest of block

1 + { return 0 + 2 + 0;};
[afterMarker] Constant x_2 declared and substituted into the rest of block

1 + { return 0 + 2 + 0;};
[beforeMarker] 0 + 2 + 0 returned

1 + (0 + 2 + 0);
[afterMarker] 0 + 2 + 0 returned

1 + (0 + 2 + 0);
[beforeMarker] Binary expression 0 + 2 evaluated

1 + (2 + 0);
[afterMarker] Binary expression 0 + 2 evaluated

1 + (2 + 0);
[beforeMarker] Binary expression 2 + 0 evaluated

1 + 2;
[afterMarker] Binary expression 2 + 0 evaluated

1 + 2;
[beforeMarker] Binary expression 1 + 2 evaluated

3;
[afterMarker] Binary expression 1 + 2 evaluated

3;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming renaming clash with declaration in replacement for function expression 1`] = `
"function f(x) { function h(x_1) { return g(); } return h;}function g() { const x_2 = 2; return x_1 + x_2 + x;}const x_1 = 0;const x = 0;f(1)(1);
[noMarker] Start of evaluation

function f(x) { function h(x_1) { return g(); } return h;}function g() { const x_2 = 2; return x_1 + x_2 + x;}const x_1 = 0;const x = 0;f(1)(1);
[beforeMarker] Function f declared, parameter(s) x required

function g() { const x_2 = 2; return x_1 + x_2 + x;}const x_1 = 0;const x = 0;(x => { function h(x_1) { return g(); } return h;})(1)(1);
[afterMarker] Function f declared, parameter(s) x required

function g() { const x_2 = 2; return x_1 + x_2 + x;}const x_1 = 0;const x = 0;(x => { function h(x_1) { return g(); } return h;})(1)(1);
[beforeMarker] Function g declared, parameter(s)  required

const x_1 = 0;const x = 0;(x_2 => { function h(x_2) { return (() => { const x_2 = 2; return x_1 + x_2 + x; })(); } return h;})(1)(1);
[afterMarker] Function g declared, parameter(s)  required

const x_1 = 0;const x = 0;(x_2 => { function h(x_2) { return (() => { const x_2 = 2; return x_1 + x_2 + x; })(); } return h;})(1)(1);
[beforeMarker] Constant x_1 declared and substituted into the rest of block

const x = 0;(x_2 => { function h(x_2) { return (() => { const x_2 = 2; return 0 + x_2 + x; })(); } return h;})(1)(1);
[afterMarker] Constant x_1 declared and substituted into the rest of block

const x = 0;(x_2 => { function h(x_2) { return (() => { const x_2 = 2; return 0 + x_2 + x; })(); } return h;})(1)(1);
[beforeMarker] Constant x declared and substituted into the rest of block

(x_2 => { function h(x_2) { return (() => { const x_2 = 2; return 0 + x_2 + 0; })(); } return h;})(1)(1);
[afterMarker] Constant x declared and substituted into the rest of block

(x_2 => { function h(x_2) { return (() => { const x_2 = 2; return 0 + x_2 + 0; })(); } return h;})(1)(1);
[beforeMarker] Function f, defined as x_2 => {...}, takes in x_2 as input 1

{ function h(x_2) { return (() => { const x_2 = 2; return 0 + x_2 + 0; })(); } return h;}(1);
[afterMarker] Function f, defined as x_2 => {...}, takes in x_2 as input 1

{ function h(x_2) { return (() => { const x_2 = 2; return 0 + x_2 + 0; })(); } return h;}(1);
[beforeMarker] Function h declared, parameter(s) x_2 required

{ return x_2 => { return (() => { const x_2 = 2; return 0 + x_2 + 0; })(); };}(1);
[afterMarker] Function h declared, parameter(s) x_2 required

{ return x_2 => { return (() => { const x_2 = 2; return 0 + x_2 + 0; })(); };}(1);
[beforeMarker] x_2 => {
  return (() => {
    const x_2 = 2;
    return 0 + x_2 + 0;
  })();
} returned

(x_2 => { return (() => { const x_2 = 2; return 0 + x_2 + 0; })();})(1);
[afterMarker] x_2 => {
  return (() => {
    const x_2 = 2;
    return 0 + x_2 + 0;
  })();
} returned

(x_2 => { return (() => { const x_2 = 2; return 0 + x_2 + 0; })();})(1);
[beforeMarker] Function h, defined as x_2 => {...}, takes in x_2 as input 1

(() => { const x_2 = 2; return 0 + x_2 + 0;})();
[afterMarker] Function h, defined as x_2 => {...}, takes in x_2 as input 1

(() => { const x_2 = 2; return 0 + x_2 + 0;})();
[beforeMarker] () => {...} runs

{ const x_2 = 2; return 0 + x_2 + 0;};
[afterMarker] () => {...} runs

{ const x_2 = 2; return 0 + x_2 + 0;};
[beforeMarker] Constant x_2 declared and substituted into the rest of block

{ return 0 + 2 + 0;};
[afterMarker] Constant x_2 declared and substituted into the rest of block

{ return 0 + 2 + 0;};
[beforeMarker] 0 + 2 + 0 returned

0 + 2 + 0;
[afterMarker] 0 + 2 + 0 returned

0 + 2 + 0;
[beforeMarker] Binary expression 0 + 2 evaluated

2 + 0;
[afterMarker] Binary expression 0 + 2 evaluated

2 + 0;
[beforeMarker] Binary expression 2 + 0 evaluated

2;
[afterMarker] Binary expression 2 + 0 evaluated

2;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming renaming clash with declaration in replacement for lambda function 1`] = `
"const f = x => x_1 => g();const g = () => { const x_2 = 2; return x_1 + x + x_2;};const x = 0;const x_1 = 0;f(1)(1);
[noMarker] Start of evaluation

const f = x => x_1 => g();const g = () => { const x_2 = 2; return x_1 + x + x_2;};const x = 0;const x_1 = 0;f(1)(1);
[beforeMarker] Constant f declared and substituted into the rest of block

const g = () => { const x_2 = 2; return x_1 + x + x_2;};const x = 0;const x_1 = 0;(x => x_1 => g())(1)(1);
[afterMarker] Constant f declared and substituted into the rest of block

const g = () => { const x_2 = 2; return x_1 + x + x_2;};const x = 0;const x_1 = 0;(x => x_1 => g())(1)(1);
[beforeMarker] Constant g declared and substituted into the rest of block

const x = 0;const x_1 = 0;(x_2 => x_3 => (() => { const x_2 = 2; return x_1 + x + x_2;})())(1)(1);
[afterMarker] Constant g declared and substituted into the rest of block

const x = 0;const x_1 = 0;(x_2 => x_3 => (() => { const x_2 = 2; return x_1 + x + x_2;})())(1)(1);
[beforeMarker] Constant x declared and substituted into the rest of block

const x_1 = 0;(x_2 => x_3 => (() => { const x_2 = 2; return x_1 + 0 + x_2;})())(1)(1);
[afterMarker] Constant x declared and substituted into the rest of block

const x_1 = 0;(x_2 => x_3 => (() => { const x_2 = 2; return x_1 + 0 + x_2;})())(1)(1);
[beforeMarker] Constant x_1 declared and substituted into the rest of block

(x_2 => x_3 => (() => { const x_2 = 2; return 0 + 0 + x_2;})())(1)(1);
[afterMarker] Constant x_1 declared and substituted into the rest of block

(x_2 => x_3 => (() => { const x_2 = 2; return 0 + 0 + x_2;})())(1)(1);
[beforeMarker] 1 substituted into x_2 of x_2 => x_3 => (() => {
  const x_2 = 2;
  return 0 + 0 + x_2;
})()

(x_3 => (() => { const x_2 = 2; return 0 + 0 + x_2;})())(1);
[afterMarker] 1 substituted into x_2 of x_2 => x_3 => (() => {
  const x_2 = 2;
  return 0 + 0 + x_2;
})()

(x_3 => (() => { const x_2 = 2; return 0 + 0 + x_2;})())(1);
[beforeMarker] 1 substituted into x_3 of x_3 => (() => {
  const x_2 = 2;
  return 0 + 0 + x_2;
})()

(() => { const x_2 = 2; return 0 + 0 + x_2;})();
[afterMarker] 1 substituted into x_3 of x_3 => (() => {
  const x_2 = 2;
  return 0 + 0 + x_2;
})()

(() => { const x_2 = 2; return 0 + 0 + x_2;})();
[beforeMarker] () => {...} runs

{ const x_2 = 2; return 0 + 0 + x_2;};
[afterMarker] () => {...} runs

{ const x_2 = 2; return 0 + 0 + x_2;};
[beforeMarker] Constant x_2 declared and substituted into the rest of block

{ return 0 + 0 + 2;};
[afterMarker] Constant x_2 declared and substituted into the rest of block

{ return 0 + 0 + 2;};
[beforeMarker] 0 + 0 + 2 returned

0 + 0 + 2;
[afterMarker] 0 + 0 + 2 returned

0 + 0 + 2;
[beforeMarker] Binary expression 0 + 0 evaluated

0 + 2;
[afterMarker] Binary expression 0 + 0 evaluated

0 + 2;
[beforeMarker] Binary expression 0 + 2 evaluated

2;
[afterMarker] Binary expression 0 + 2 evaluated

2;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming renaming clash with parameter of function declaration in block 1`] = `
"function g() { return x_1;}function f(x_1) { function h(x_2) { return x_1 + g(); } return h;}const x_1 = 1;f(3)(2);
[noMarker] Start of evaluation

function g() { return x_1;}function f(x_1) { function h(x_2) { return x_1 + g(); } return h;}const x_1 = 1;f(3)(2);
[beforeMarker] Function g declared, parameter(s)  required

function f(x_3) { function h(x_2) { return x_3 + (() => { return x_1; })(); } return h;}const x_1 = 1;f(3)(2);
[afterMarker] Function g declared, parameter(s)  required

function f(x_3) { function h(x_2) { return x_3 + (() => { return x_1; })(); } return h;}const x_1 = 1;f(3)(2);
[beforeMarker] Function f declared, parameter(s) x_3 required

const x_1 = 1;(x_3 => { function h(x_2) { return x_3 + (() => { return x_1; })(); } return h;})(3)(2);
[afterMarker] Function f declared, parameter(s) x_3 required

const x_1 = 1;(x_3 => { function h(x_2) { return x_3 + (() => { return x_1; })(); } return h;})(3)(2);
[beforeMarker] Constant x_1 declared and substituted into the rest of block

(x_3 => { function h(x_2) { return x_3 + (() => { return 1; })(); } return h;})(3)(2);
[afterMarker] Constant x_1 declared and substituted into the rest of block

(x_3 => { function h(x_2) { return x_3 + (() => { return 1; })(); } return h;})(3)(2);
[beforeMarker] Function f, defined as x_3 => {...}, takes in x_3 as input 3

{ function h(x_2) { return 3 + (() => { return 1; })(); } return h;}(2);
[afterMarker] Function f, defined as x_3 => {...}, takes in x_3 as input 3

{ function h(x_2) { return 3 + (() => { return 1; })(); } return h;}(2);
[beforeMarker] Function h declared, parameter(s) x_2 required

{ return x_2 => { return 3 + (() => { return 1; })(); };}(2);
[afterMarker] Function h declared, parameter(s) x_2 required

{ return x_2 => { return 3 + (() => { return 1; })(); };}(2);
[beforeMarker] x_2 => {
  return 3 + (() => {
    return 1;
  })();
} returned

(x_2 => { return 3 + (() => { return 1; })();})(2);
[afterMarker] x_2 => {
  return 3 + (() => {
    return 1;
  })();
} returned

(x_2 => { return 3 + (() => { return 1; })();})(2);
[beforeMarker] Function h, defined as x_2 => {...}, takes in x_2 as input 2

3 + (() => { return 1;})();
[afterMarker] Function h, defined as x_2 => {...}, takes in x_2 as input 2

3 + (() => { return 1;})();
[beforeMarker] () => {...} runs

3 + 1;
[afterMarker] () => {...} runs

3 + 1;
[beforeMarker] Binary expression 3 + 1 evaluated

4;
[afterMarker] Binary expression 3 + 1 evaluated

4;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming renaming clash with parameter of lambda function declaration in block 1`] = `
"const g = () => x_1;const f = x_1 => { const h = x_2 => x_1 + g(); return h;};const x_1 = 1;f(3)(2);
[noMarker] Start of evaluation

const g = () => x_1;const f = x_1 => { const h = x_2 => x_1 + g(); return h;};const x_1 = 1;f(3)(2);
[beforeMarker] Constant g declared and substituted into the rest of block

const f = x_3 => { const h = x_2 => x_3 + (() => x_1)(); return h;};const x_1 = 1;f(3)(2);
[afterMarker] Constant g declared and substituted into the rest of block

const f = x_3 => { const h = x_2 => x_3 + (() => x_1)(); return h;};const x_1 = 1;f(3)(2);
[beforeMarker] Constant f declared and substituted into the rest of block

const x_1 = 1;(x_3 => { const h = x_2 => x_3 + (() => x_1)(); return h;})(3)(2);
[afterMarker] Constant f declared and substituted into the rest of block

const x_1 = 1;(x_3 => { const h = x_2 => x_3 + (() => x_1)(); return h;})(3)(2);
[beforeMarker] Constant x_1 declared and substituted into the rest of block

(x_3 => { const h = x_2 => x_3 + (() => 1)(); return h;})(3)(2);
[afterMarker] Constant x_1 declared and substituted into the rest of block

(x_3 => { const h = x_2 => x_3 + (() => 1)(); return h;})(3)(2);
[beforeMarker] Function f, defined as x_3 => {...}, takes in x_3 as input 3

{ const h = x_2 => 3 + (() => 1)(); return h;}(2);
[afterMarker] Function f, defined as x_3 => {...}, takes in x_3 as input 3

{ const h = x_2 => 3 + (() => 1)(); return h;}(2);
[beforeMarker] Constant h declared and substituted into the rest of block

{ return x_2 => 3 + (() => 1)();}(2);
[afterMarker] Constant h declared and substituted into the rest of block

{ return x_2 => 3 + (() => 1)();}(2);
[beforeMarker] x_2 => 3 + (() => 1)() returned

(x_2 => 3 + (() => 1)())(2);
[afterMarker] x_2 => 3 + (() => 1)() returned

(x_2 => 3 + (() => 1)())(2);
[beforeMarker] 2 substituted into x_2 of x_2 => 3 + (() => 1)()

3 + (() => 1)();
[afterMarker] 2 substituted into x_2 of x_2 => 3 + (() => 1)()

3 + (() => 1)();
[beforeMarker] () => 1 runs

3 + 1;
[afterMarker] () => 1 runs

3 + 1;
[beforeMarker] Binary expression 3 + 1 evaluated

4;
[afterMarker] Binary expression 3 + 1 evaluated

4;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming renaming of outer parameter in lambda function 1`] = `
"const g = () => w_1;const f = w_1 => w_2 => w_1 + g();const w_1 = 0;f(1)(1);
[noMarker] Start of evaluation

const g = () => w_1;const f = w_1 => w_2 => w_1 + g();const w_1 = 0;f(1)(1);
[beforeMarker] Constant g declared and substituted into the rest of block

const f = w_3 => w_2 => w_3 + (() => w_1)();const w_1 = 0;f(1)(1);
[afterMarker] Constant g declared and substituted into the rest of block

const f = w_3 => w_2 => w_3 + (() => w_1)();const w_1 = 0;f(1)(1);
[beforeMarker] Constant f declared and substituted into the rest of block

const w_1 = 0;(w_3 => w_2 => w_3 + (() => w_1)())(1)(1);
[afterMarker] Constant f declared and substituted into the rest of block

const w_1 = 0;(w_3 => w_2 => w_3 + (() => w_1)())(1)(1);
[beforeMarker] Constant w_1 declared and substituted into the rest of block

(w_3 => w_2 => w_3 + (() => 0)())(1)(1);
[afterMarker] Constant w_1 declared and substituted into the rest of block

(w_3 => w_2 => w_3 + (() => 0)())(1)(1);
[beforeMarker] 1 substituted into w_3 of w_3 => w_2 => w_3 + (() => 0)()

(w_2 => 1 + (() => 0)())(1);
[afterMarker] 1 substituted into w_3 of w_3 => w_2 => w_3 + (() => 0)()

(w_2 => 1 + (() => 0)())(1);
[beforeMarker] 1 substituted into w_2 of w_2 => 1 + (() => 0)()

1 + (() => 0)();
[afterMarker] 1 substituted into w_2 of w_2 => 1 + (() => 0)()

1 + (() => 0)();
[beforeMarker] () => 0 runs

1 + 0;
[afterMarker] () => 0 runs

1 + 0;
[beforeMarker] Binary expression 1 + 0 evaluated

1;
[afterMarker] Binary expression 1 + 0 evaluated

1;
[noMarker] Evaluation complete
"
`;

exports[`Builtin math PI returns its value 1`] = `
"3.141592653589793;
[noMarker] Start of evaluation

3.141592653589793;
[noMarker] Evaluation complete
"
`;

exports[`Builtin math math_sin() returns NaN 1`] = `
"math_sin();
[noMarker] Start of evaluation

math_sin();
[beforeMarker] math_sin runs

NaN;
[afterMarker] math_sin runs

NaN;
[noMarker] Evaluation complete
"
`;

exports[`Builtin math negative numbers as arguments 1`] = `
"math_sin(-1);
[noMarker] Start of evaluation

math_sin(-1);
[beforeMarker] math_sin runs

-0.8414709848078965;
[afterMarker] math_sin runs

-0.8414709848078965;
[noMarker] Evaluation complete
"
`;

exports[`Church numerals 1`] = `
"const one = f => x => f(x);const inc = a => f => x => f(a(f)(x));const decode = a => a(x => x + 1)(0);decode(inc(inc(one))) === 3;
[noMarker] Start of evaluation

const one = f => x => f(x);const inc = a => f => x => f(a(f)(x));const decode = a => a(x => x + 1)(0);decode(inc(inc(one))) === 3;
[beforeMarker] Constant one declared and substituted into the rest of block

const inc = a => f => x => f(a(f)(x));const decode = a => a(x => x + 1)(0);decode(inc(inc(f => x => f(x)))) === 3;
[afterMarker] Constant one declared and substituted into the rest of block

const inc = a => f => x => f(a(f)(x));const decode = a => a(x => x + 1)(0);decode(inc(inc(f => x => f(x)))) === 3;
[beforeMarker] Constant inc declared and substituted into the rest of block

const decode = a => a(x => x + 1)(0);decode((a => f => x => f(a(f)(x)))((a => f => x => f(a(f)(x)))(f => x => f(x)))) === 3;
[afterMarker] Constant inc declared and substituted into the rest of block

const decode = a => a(x => x + 1)(0);decode((a => f => x => f(a(f)(x)))((a => f => x => f(a(f)(x)))(f => x => f(x)))) === 3;
[beforeMarker] Constant decode declared and substituted into the rest of block

(a => a(x => x + 1)(0))((a => f => x => f(a(f)(x)))((a => f => x => f(a(f)(x)))(f => x => f(x)))) === 3;
[afterMarker] Constant decode declared and substituted into the rest of block

(a => a(x => x + 1)(0))((a => f => x => f(a(f)(x)))((a => f => x => f(a(f)(x)))(f => x => f(x)))) === 3;
[beforeMarker] f => x => f(x) substituted into a of a => f => x => f(a(f)(x))

(a => a(x => x + 1)(0))((a => f => x => f(a(f)(x)))(f => x => f((f => x => f(x))(f)(x)))) === 3;
[afterMarker] f => x => f(x) substituted into a of a => f => x => f(a(f)(x))

(a => a(x => x + 1)(0))((a => f => x => f(a(f)(x)))(f => x => f((f => x => f(x))(f)(x)))) === 3;
[beforeMarker] f => x => f((f => x => f(x))(f)(x)) substituted into a of a => f => x => f(a(f)(x))

(a => a(x => x + 1)(0))(f => x => f((f => x => f((f => x => f(x))(f)(x)))(f)(x))) === 3;
[afterMarker] f => x => f((f => x => f(x))(f)(x)) substituted into a of a => f => x => f(a(f)(x))

(a => a(x => x + 1)(0))(f => x => f((f => x => f((f => x => f(x))(f)(x)))(f)(x))) === 3;
[beforeMarker] f => x => f((f => x => f((f => x => f(x))(f)(x)))(f)(x)) substituted into a of a => a(x => x + 1)(0)

(f => x => f((f => x => f((f => x => f(x))(f)(x)))(f)(x)))(x => x + 1)(0) === 3;
[afterMarker] f => x => f((f => x => f((f => x => f(x))(f)(x)))(f)(x)) substituted into a of a => a(x => x + 1)(0)

(f => x => f((f => x => f((f => x => f(x))(f)(x)))(f)(x)))(x => x + 1)(0) === 3;
[beforeMarker] x => x + 1 substituted into f of f => x => f((f => x => f((f => x => f(x))(f)(x)))(f)(x))

(x => (x => x + 1)((f => x => f((f => x => f(x))(f)(x)))(x => x + 1)(x)))(0) === 3;
[afterMarker] x => x + 1 substituted into f of f => x => f((f => x => f((f => x => f(x))(f)(x)))(f)(x))

(x => (x => x + 1)((f => x => f((f => x => f(x))(f)(x)))(x => x + 1)(x)))(0) === 3;
[beforeMarker] 0 substituted into x of x => (x => x + 1)((f => x => f((f => x => f(x))(f)(x)))(x => x + 1)(x))

(x => x + 1)((f => x => f((f => x => f(x))(f)(x)))(x => x + 1)(0)) === 3;
[afterMarker] 0 substituted into x of x => (x => x + 1)((f => x => f((f => x => f(x))(f)(x)))(x => x + 1)(x))

(x => x + 1)((f => x => f((f => x => f(x))(f)(x)))(x => x + 1)(0)) === 3;
[beforeMarker] x => x + 1 substituted into f of f => x => f((f => x => f(x))(f)(x))

(x => x + 1)((x => (x => x + 1)((f => x => f(x))(x => x + 1)(x)))(0)) === 3;
[afterMarker] x => x + 1 substituted into f of f => x => f((f => x => f(x))(f)(x))

(x => x + 1)((x => (x => x + 1)((f => x => f(x))(x => x + 1)(x)))(0)) === 3;
[beforeMarker] 0 substituted into x of x => (x => x + 1)((f => x => f(x))(x => x + 1)(x))

(x => x + 1)((x => x + 1)((f => x => f(x))(x => x + 1)(0))) === 3;
[afterMarker] 0 substituted into x of x => (x => x + 1)((f => x => f(x))(x => x + 1)(x))

(x => x + 1)((x => x + 1)((f => x => f(x))(x => x + 1)(0))) === 3;
[beforeMarker] x => x + 1 substituted into f of f => x => f(x)

(x => x + 1)((x => x + 1)((x => (x => x + 1)(x))(0))) === 3;
[afterMarker] x => x + 1 substituted into f of f => x => f(x)

(x => x + 1)((x => x + 1)((x => (x => x + 1)(x))(0))) === 3;
[beforeMarker] 0 substituted into x of x => (x => x + 1)(x)

(x => x + 1)((x => x + 1)((x => x + 1)(0))) === 3;
[afterMarker] 0 substituted into x of x => (x => x + 1)(x)

(x => x + 1)((x => x + 1)((x => x + 1)(0))) === 3;
[beforeMarker] 0 substituted into x of x => x + 1

(x => x + 1)((x => x + 1)(0 + 1)) === 3;
[afterMarker] 0 substituted into x of x => x + 1

(x => x + 1)((x => x + 1)(0 + 1)) === 3;
[beforeMarker] Binary expression 0 + 1 evaluated

(x => x + 1)((x => x + 1)(1)) === 3;
[afterMarker] Binary expression 0 + 1 evaluated

(x => x + 1)((x => x + 1)(1)) === 3;
[beforeMarker] 1 substituted into x of x => x + 1

(x => x + 1)(1 + 1) === 3;
[afterMarker] 1 substituted into x of x => x + 1

(x => x + 1)(1 + 1) === 3;
[beforeMarker] Binary expression 1 + 1 evaluated

(x => x + 1)(2) === 3;
[afterMarker] Binary expression 1 + 1 evaluated

(x => x + 1)(2) === 3;
[beforeMarker] 2 substituted into x of x => x + 1

2 + 1 === 3;
[afterMarker] 2 substituted into x of x => x + 1

2 + 1 === 3;
[beforeMarker] Binary expression 2 + 1 evaluated

3 === 3;
[afterMarker] Binary expression 2 + 1 evaluated

3 === 3;
[beforeMarker] Binary expression 3 === 3 evaluated

true;
[afterMarker] Binary expression 3 === 3 evaluated

true;
[noMarker] Evaluation complete
"
`;

exports[`Evaluation of empty code and imports Evaluate empty program 1`] = `
"
[noMarker] Start of evaluation

undefined;
[noMarker] Evaluation complete
"
`;

exports[`Expressions Conditional Expression 1`] = `
"-1 * 3 === 3 ? 2 * 4 - 7 : 1 + 3 * 6;
[noMarker] Start of evaluation
-1 * 3 === 3 ? 2 * 4 - 7 : 1 + 3 * 6;
[beforeMarker] Binary expression -1 * 3 evaluated
-3 === 3 ? 2 * 4 - 7 : 1 + 3 * 6;
[afterMarker] Binary expression -1 * 3 evaluated
-3 === 3 ? 2 * 4 - 7 : 1 + 3 * 6;
[beforeMarker] Binary expression -3 === 3 evaluated
false ? 2 * 4 - 7 : 1 + 3 * 6;
[afterMarker] Binary expression -3 === 3 evaluated
false ? 2 * 4 - 7 : 1 + 3 * 6;
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated
1 + 3 * 6;
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated
1 + 3 * 6;
[beforeMarker] Binary expression 3 * 6 evaluated
1 + 18;
[afterMarker] Binary expression 3 * 6 evaluated
1 + 18;
[beforeMarker] Binary expression 1 + 18 evaluated
19;
[afterMarker] Binary expression 1 + 18 evaluated
19;
[noMarker] Evaluation complete
"
`;

exports[`Expressions Extra step for UnaryExpression 1`] = `
"-(1 - 5);
[noMarker] Start of evaluation
-(1 - 5);
[beforeMarker] Binary expression 1 - 5 evaluated
--4;
[afterMarker] Binary expression 1 - 5 evaluated
--4;
[beforeMarker] Unary expression evaluated, value -4 negated.
4;
[afterMarker] Unary expression evaluated, value -4 negated.
4;
[noMarker] Evaluation complete
"
`;

exports[`Expressions Logical Expression 1`] = `
"!!!true || true;
[noMarker] Start of evaluation
!!!true || true;
[beforeMarker] Unary expression evaluated, boolean true negated.
!!false || true;
[afterMarker] Unary expression evaluated, boolean true negated.
!!false || true;
[beforeMarker] Unary expression evaluated, boolean false negated.
!true || true;
[afterMarker] Unary expression evaluated, boolean false negated.
!true || true;
[beforeMarker] Unary expression evaluated, boolean true negated.
false || true;
[afterMarker] Unary expression evaluated, boolean true negated.
false || true;
[beforeMarker] OR operation evaluated, left of operator is false, continue evaluating right of operator
true;
[afterMarker] OR operation evaluated, left of operator is false, continue evaluating right of operator
true;
[noMarker] Evaluation complete
"
`;

exports[`Expressions No extra step for UnaryExpression 1`] = `
"-(1 + 2);
[noMarker] Start of evaluation
-(1 + 2);
[beforeMarker] Binary expression 1 + 2 evaluated
-3;
[afterMarker] Binary expression 1 + 2 evaluated
-3;
[noMarker] Evaluation complete
"
`;

exports[`Expressions Unary and Binary Expressions 1`] = `
"-1 + 2 * 3 - (5 * 6 - 7);
[noMarker] Start of evaluation
-1 + 2 * 3 - (5 * 6 - 7);
[beforeMarker] Binary expression 2 * 3 evaluated
-1 + 6 - (5 * 6 - 7);
[afterMarker] Binary expression 2 * 3 evaluated
-1 + 6 - (5 * 6 - 7);
[beforeMarker] Binary expression -1 + 6 evaluated
5 - (5 * 6 - 7);
[afterMarker] Binary expression -1 + 6 evaluated
5 - (5 * 6 - 7);
[beforeMarker] Binary expression 5 * 6 evaluated
5 - (30 - 7);
[afterMarker] Binary expression 5 * 6 evaluated
5 - (30 - 7);
[beforeMarker] Binary expression 30 - 7 evaluated
5 - 23;
[afterMarker] Binary expression 30 - 7 evaluated
5 - 23;
[beforeMarker] Binary expression 5 - 23 evaluated
-18;
[afterMarker] Binary expression 5 - 23 evaluated
-18;
[noMarker] Evaluation complete
"
`;

exports[`Expressions: Binary operators And-shortcut-false test case 1`] = `
"if (false && 1 + 2 === 1 + 2) { 1;} else { 2;}
[noMarker] Start of evaluation

if (false && 1 + 2 === 1 + 2) { 1;} else { 2;}
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

if (false) { 1;} else { 2;}
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

if (false) { 1;} else { 2;}
[beforeMarker] ...

{ undefined; 2;}
[afterMarker] ...

{ undefined; 2;}
[beforeMarker] undefined finished evaluating

{ 2;}
[afterMarker] undefined finished evaluating

{ 2;}
[beforeMarker] 2; finished evaluating

2;
[afterMarker] 2; finished evaluating

2;
[noMarker] Evaluation complete
"
`;

exports[`Expressions: Binary operators And-shortcut-true test case 1`] = `
"if (true && 1 + 2 === 2 + 3) { 1;} else { 2;}
[noMarker] Start of evaluation

if (true && 1 + 2 === 2 + 3) { 1;} else { 2;}
[beforeMarker] AND operation evaluated, left of operator is false, stop evaluation

if (1 + 2 === 2 + 3) { 1;} else { 2;}
[afterMarker] AND operation evaluated, left of operator is false, stop evaluation

if (1 + 2 === 2 + 3) { 1;} else { 2;}
[beforeMarker] Binary expression 1 + 2 evaluated

if (3 === 2 + 3) { 1;} else { 2;}
[afterMarker] Binary expression 1 + 2 evaluated

if (3 === 2 + 3) { 1;} else { 2;}
[beforeMarker] Binary expression 2 + 3 evaluated

if (3 === 5) { 1;} else { 2;}
[afterMarker] Binary expression 2 + 3 evaluated

if (3 === 5) { 1;} else { 2;}
[beforeMarker] Binary expression 3 === 5 evaluated

if (false) { 1;} else { 2;}
[afterMarker] Binary expression 3 === 5 evaluated

if (false) { 1;} else { 2;}
[beforeMarker] ...

{ undefined; 2;}
[afterMarker] ...

{ undefined; 2;}
[beforeMarker] undefined finished evaluating

{ 2;}
[afterMarker] undefined finished evaluating

{ 2;}
[beforeMarker] 2; finished evaluating

2;
[afterMarker] 2; finished evaluating

2;
[noMarker] Evaluation complete
"
`;

exports[`Expressions: Binary operators Left-binary-reduce test case 1`] = `
"if (1 + 2 + 3 === 1 + 2 + 3) { 1;} else { 2;}
[noMarker] Start of evaluation

if (1 + 2 + 3 === 1 + 2 + 3) { 1;} else { 2;}
[beforeMarker] Binary expression 1 + 2 evaluated

if (3 + 3 === 1 + 2 + 3) { 1;} else { 2;}
[afterMarker] Binary expression 1 + 2 evaluated

if (3 + 3 === 1 + 2 + 3) { 1;} else { 2;}
[beforeMarker] Binary expression 3 + 3 evaluated

if (6 === 1 + 2 + 3) { 1;} else { 2;}
[afterMarker] Binary expression 3 + 3 evaluated

if (6 === 1 + 2 + 3) { 1;} else { 2;}
[beforeMarker] Binary expression 1 + 2 evaluated

if (6 === 3 + 3) { 1;} else { 2;}
[afterMarker] Binary expression 1 + 2 evaluated

if (6 === 3 + 3) { 1;} else { 2;}
[beforeMarker] Binary expression 3 + 3 evaluated

if (6 === 6) { 1;} else { 2;}
[afterMarker] Binary expression 3 + 3 evaluated

if (6 === 6) { 1;} else { 2;}
[beforeMarker] Binary expression 6 === 6 evaluated

if (true) { 1;} else { 2;}
[afterMarker] Binary expression 6 === 6 evaluated

if (true) { 1;} else { 2;}
[beforeMarker] ...

{ undefined; 1;}
[afterMarker] ...

{ undefined; 1;}
[beforeMarker] undefined finished evaluating

{ 1;}
[afterMarker] undefined finished evaluating

{ 1;}
[beforeMarker] 1; finished evaluating

1;
[afterMarker] 1; finished evaluating

1;
[noMarker] Evaluation complete
"
`;

exports[`Expressions: Binary operators Or-shortcut-false test case 1`] = `
"if (false || 1 + 2 === 1 + 2) { 1;} else { 2;}
[noMarker] Start of evaluation

if (false || 1 + 2 === 1 + 2) { 1;} else { 2;}
[beforeMarker] OR operation evaluated, left of operator is false, continue evaluating right of operator

if (1 + 2 === 1 + 2) { 1;} else { 2;}
[afterMarker] OR operation evaluated, left of operator is false, continue evaluating right of operator

if (1 + 2 === 1 + 2) { 1;} else { 2;}
[beforeMarker] Binary expression 1 + 2 evaluated

if (3 === 1 + 2) { 1;} else { 2;}
[afterMarker] Binary expression 1 + 2 evaluated

if (3 === 1 + 2) { 1;} else { 2;}
[beforeMarker] Binary expression 1 + 2 evaluated

if (3 === 3) { 1;} else { 2;}
[afterMarker] Binary expression 1 + 2 evaluated

if (3 === 3) { 1;} else { 2;}
[beforeMarker] Binary expression 3 === 3 evaluated

if (true) { 1;} else { 2;}
[afterMarker] Binary expression 3 === 3 evaluated

if (true) { 1;} else { 2;}
[beforeMarker] ...

{ undefined; 1;}
[afterMarker] ...

{ undefined; 1;}
[beforeMarker] undefined finished evaluating

{ 1;}
[afterMarker] undefined finished evaluating

{ 1;}
[beforeMarker] 1; finished evaluating

1;
[afterMarker] 1; finished evaluating

1;
[noMarker] Evaluation complete
"
`;

exports[`Expressions: Binary operators Or-shortcut-true test case 1`] = `
"if (true || 1 + 2 === 2 + 3) { 1;} else { 2;}
[noMarker] Start of evaluation

if (true || 1 + 2 === 2 + 3) { 1;} else { 2;}
[beforeMarker] OR operation evaluated, left of operator is true, stop evaluation

if (true) { 1;} else { 2;}
[afterMarker] OR operation evaluated, left of operator is true, stop evaluation

if (true) { 1;} else { 2;}
[beforeMarker] ...

{ undefined; 1;}
[afterMarker] ...

{ undefined; 1;}
[beforeMarker] undefined finished evaluating

{ 1;}
[afterMarker] undefined finished evaluating

{ 1;}
[beforeMarker] 1; finished evaluating

1;
[afterMarker] 1; finished evaluating

1;
[noMarker] Evaluation complete
"
`;

exports[`Expressions: Binary operators Prim-binary-reduce test case 1`] = `
"if (1 >= 2) { 1;} else { 2;}
[noMarker] Start of evaluation

if (1 >= 2) { 1;} else { 2;}
[beforeMarker] Binary expression 1 >= 2 evaluated

if (false) { 1;} else { 2;}
[afterMarker] Binary expression 1 >= 2 evaluated

if (false) { 1;} else { 2;}
[beforeMarker] ...

{ undefined; 2;}
[afterMarker] ...

{ undefined; 2;}
[beforeMarker] undefined finished evaluating

{ 2;}
[afterMarker] undefined finished evaluating

{ 2;}
[beforeMarker] 2; finished evaluating

2;
[afterMarker] 2; finished evaluating

2;
[noMarker] Evaluation complete
"
`;

exports[`Expressions: Binary operators Right-binary-reduce test case 1`] = `
"if (1 >= 1 + 1) { 1;} else { 2;}
[noMarker] Start of evaluation

if (1 >= 1 + 1) { 1;} else { 2;}
[beforeMarker] Binary expression 1 + 1 evaluated

if (1 >= 2) { 1;} else { 2;}
[afterMarker] Binary expression 1 + 1 evaluated

if (1 >= 2) { 1;} else { 2;}
[beforeMarker] Binary expression 1 >= 2 evaluated

if (false) { 1;} else { 2;}
[afterMarker] Binary expression 1 >= 2 evaluated

if (false) { 1;} else { 2;}
[beforeMarker] ...

{ undefined; 2;}
[afterMarker] ...

{ undefined; 2;}
[beforeMarker] undefined finished evaluating

{ 2;}
[afterMarker] undefined finished evaluating

{ 2;}
[beforeMarker] 2; finished evaluating

2;
[afterMarker] 2; finished evaluating

2;
[noMarker] Evaluation complete
"
`;

exports[`Expressions: conditionals Conditional-false-reduce test case 1`] = `
"false ? 1 + 2 : 2 + 3;
[noMarker] Start of evaluation

false ? 1 + 2 : 2 + 3;
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

2 + 3;
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

2 + 3;
[beforeMarker] Binary expression 2 + 3 evaluated

5;
[afterMarker] Binary expression 2 + 3 evaluated

5;
[noMarker] Evaluation complete
"
`;

exports[`Expressions: conditionals Conditional-predicate-reduce test case 1`] = `
"1 + 1 === 2 ? 1 + 2 : 2 + 3;
[noMarker] Start of evaluation

1 + 1 === 2 ? 1 + 2 : 2 + 3;
[beforeMarker] Binary expression 1 + 1 evaluated

2 === 2 ? 1 + 2 : 2 + 3;
[afterMarker] Binary expression 1 + 1 evaluated

2 === 2 ? 1 + 2 : 2 + 3;
[beforeMarker] Binary expression 2 === 2 evaluated

true ? 1 + 2 : 2 + 3;
[afterMarker] Binary expression 2 === 2 evaluated

true ? 1 + 2 : 2 + 3;
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

1 + 2;
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

1 + 2;
[beforeMarker] Binary expression 1 + 2 evaluated

3;
[afterMarker] Binary expression 1 + 2 evaluated

3;
[noMarker] Evaluation complete
"
`;

exports[`Expressions: conditionals Conditional-true-reduce test case 1`] = `
"true ? 1 + 2 : 2 + 3;
[noMarker] Start of evaluation

true ? 1 + 2 : 2 + 3;
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

1 + 2;
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

1 + 2;
[beforeMarker] Binary expression 1 + 2 evaluated

3;
[afterMarker] Binary expression 1 + 2 evaluated

3;
[noMarker] Evaluation complete
"
`;

exports[`Expresssions: Blocks Block-expression-empty-reduce test case 1`] = `
"function foo(x) {}foo(0);
[noMarker] Start of evaluation

function foo(x) {}foo(0);
[beforeMarker] Function foo declared, parameter(s) x required

(x => {})(0);
[afterMarker] Function foo declared, parameter(s) x required

(x => {})(0);
[beforeMarker] Function foo, defined as x => {...}, takes in x as input 0

{};
[afterMarker] Function foo, defined as x => {...}, takes in x as input 0

{};
[beforeMarker] Empty block expression evaluated

undefined;
[afterMarker] Empty block expression evaluated

undefined;
[noMarker] Evaluation complete
"
`;

exports[`Expresssions: Blocks Block-expression-intro test case 1`] = `
"function foo(x) { 1 + 1;}foo(0);
[noMarker] Start of evaluation

function foo(x) { 1 + 1;}foo(0);
[beforeMarker] Function foo declared, parameter(s) x required

(x => { 1 + 1;})(0);
[afterMarker] Function foo declared, parameter(s) x required

(x => { 1 + 1;})(0);
[beforeMarker] Function foo, defined as x => {...}, takes in x as input 0

{ 1 + 1;};
[afterMarker] Function foo, defined as x => {...}, takes in x as input 0

{ 1 + 1;};
[beforeMarker] Binary expression 1 + 1 evaluated

{ 2;};
[afterMarker] Binary expression 1 + 1 evaluated

{ 2;};
[beforeMarker] 2; finished evaluating

undefined;
[afterMarker] 2; finished evaluating

undefined;
[noMarker] Evaluation complete
"
`;

exports[`Expresssions: Blocks Block-expression-single-reduce test case 1`] = `
"function foo(x) { 1;}foo(0);
[noMarker] Start of evaluation

function foo(x) { 1;}foo(0);
[beforeMarker] Function foo declared, parameter(s) x required

(x => { 1;})(0);
[afterMarker] Function foo declared, parameter(s) x required

(x => { 1;})(0);
[beforeMarker] Function foo, defined as x => {...}, takes in x as input 0

{ 1;};
[afterMarker] Function foo, defined as x => {...}, takes in x as input 0

{ 1;};
[beforeMarker] 1; finished evaluating

undefined;
[afterMarker] 1; finished evaluating

undefined;
[noMarker] Evaluation complete
"
`;

exports[`Function declaration with if else block 1`] = `
"function f() { const x = 2; if (true) { 5 + x; return 2; } else {}}f();
[noMarker] Start of evaluation

function f() { const x = 2; if (true) { 5 + x; return 2; } else {}}f();
[beforeMarker] Function f declared, parameter(s)  required

(() => { const x = 2; if (true) { 5 + x; return 2; } else {}})();
[afterMarker] Function f declared, parameter(s)  required

(() => { const x = 2; if (true) { 5 + x; return 2; } else {}})();
[beforeMarker] () => {...} runs

{ const x = 2; if (true) { 5 + x; return 2; } else {}};
[afterMarker] () => {...} runs

{ const x = 2; if (true) { 5 + x; return 2; } else {}};
[beforeMarker] Constant x declared and substituted into the rest of block

{ if (true) { 5 + 2; return 2; } else {}};
[afterMarker] Constant x declared and substituted into the rest of block

{ if (true) { 5 + 2; return 2; } else {}};
[beforeMarker] ...

{ { undefined; 5 + 2; return 2; }};
[afterMarker] ...

{ { undefined; 5 + 2; return 2; }};
[beforeMarker] Binary expression 5 + 2 evaluated

{ { undefined; 7; return 2; }};
[afterMarker] Binary expression 5 + 2 evaluated

{ { undefined; 7; return 2; }};
[beforeMarker] undefined finished evaluating

{ { 7; return 2; }};
[afterMarker] undefined finished evaluating

{ { 7; return 2; }};
[beforeMarker] 7 finished evaluating

{ { return 2; }};
[afterMarker] 7 finished evaluating

{ { return 2; }};
[beforeMarker] return 2; finished evaluating

{ return 2;};
[afterMarker] return 2; finished evaluating

{ return 2;};
[beforeMarker] 2 returned

2;
[afterMarker] 2 returned

2;
[noMarker] Evaluation complete
"
`;

exports[`Lambda expression Basic bi function 1`] = `
"const add = (x, y) => x + y;add(2, 3);
[noMarker] Start of evaluation

const add = (x, y) => x + y;add(2, 3);
[beforeMarker] Constant add declared and substituted into the rest of block

((x, y) => x + y)(2, 3);
[afterMarker] Constant add declared and substituted into the rest of block

((x, y) => x + y)(2, 3);
[beforeMarker] 2, 3 substituted into x, y of (x, y) => x + y

2 + 3;
[afterMarker] 2, 3 substituted into x, y of (x, y) => x + y

2 + 3;
[beforeMarker] Binary expression 2 + 3 evaluated

5;
[afterMarker] Binary expression 2 + 3 evaluated

5;
[noMarker] Evaluation complete
"
`;

exports[`Lambda expression Basic function 1`] = `
"const y = 2;const f = x => x + y;f(1);
[noMarker] Start of evaluation

const y = 2;const f = x => x + y;f(1);
[beforeMarker] Constant y declared and substituted into the rest of block

const f = x => x + 2;f(1);
[afterMarker] Constant y declared and substituted into the rest of block

const f = x => x + 2;f(1);
[beforeMarker] Constant f declared and substituted into the rest of block

(x => x + 2)(1);
[afterMarker] Constant f declared and substituted into the rest of block

(x => x + 2)(1);
[beforeMarker] 1 substituted into x of x => x + 2

1 + 2;
[afterMarker] 1 substituted into x of x => x + 2

1 + 2;
[beforeMarker] Binary expression 1 + 2 evaluated

3;
[afterMarker] Binary expression 1 + 2 evaluated

3;
[noMarker] Evaluation complete
"
`;

exports[`Lambda expression Currying 1`] = `
"const add = x => y => x + y;add(2)(3);
[noMarker] Start of evaluation

const add = x => y => x + y;add(2)(3);
[beforeMarker] Constant add declared and substituted into the rest of block

(x => y => x + y)(2)(3);
[afterMarker] Constant add declared and substituted into the rest of block

(x => y => x + y)(2)(3);
[beforeMarker] 2 substituted into x of x => y => x + y

(y => 2 + y)(3);
[afterMarker] 2 substituted into x of x => y => x + y

(y => 2 + y)(3);
[beforeMarker] 3 substituted into y of y => 2 + y

2 + 3;
[afterMarker] 3 substituted into y of y => 2 + y

2 + 3;
[beforeMarker] Binary expression 2 + 3 evaluated

5;
[afterMarker] Binary expression 2 + 3 evaluated

5;
[noMarker] Evaluation complete
"
`;

exports[`Lambda expression Recursive function call 1`] = `
"const factorial = n => n === 0 ? 1 : n * factorial(n - 1);factorial(2);
[noMarker] Start of evaluation

const factorial = n => n === 0 ? 1 : n * factorial(n - 1);factorial(2);
[beforeMarker] Constant factorial declared and substituted into the rest of block

(n => n === 0 ? 1 : n * factorial(n - 1))(2);
[afterMarker] Constant factorial declared and substituted into the rest of block

(n => n === 0 ? 1 : n * factorial(n - 1))(2);
[beforeMarker] 2 substituted into n of n => n === 0 ? 1 : n * factorial(n - 1)

2 === 0 ? 1 : 2 * (n => n === 0 ? 1 : n * factorial(n - 1))(2 - 1);
[afterMarker] 2 substituted into n of n => n === 0 ? 1 : n * factorial(n - 1)

2 === 0 ? 1 : 2 * (n => n === 0 ? 1 : n * factorial(n - 1))(2 - 1);
[beforeMarker] Binary expression 2 === 0 evaluated

false ? 1 : 2 * (n => n === 0 ? 1 : n * factorial(n - 1))(2 - 1);
[afterMarker] Binary expression 2 === 0 evaluated

false ? 1 : 2 * (n => n === 0 ? 1 : n * factorial(n - 1))(2 - 1);
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

2 * (n => n === 0 ? 1 : n * factorial(n - 1))(2 - 1);
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

2 * (n => n === 0 ? 1 : n * factorial(n - 1))(2 - 1);
[beforeMarker] Binary expression 2 - 1 evaluated

2 * (n => n === 0 ? 1 : n * factorial(n - 1))(1);
[afterMarker] Binary expression 2 - 1 evaluated

2 * (n => n === 0 ? 1 : n * factorial(n - 1))(1);
[beforeMarker] 1 substituted into n of n => n === 0 ? 1 : n * factorial(n - 1)

2 * (1 === 0 ? 1 : 1 * (n => n === 0 ? 1 : n * factorial(n - 1))(1 - 1));
[afterMarker] 1 substituted into n of n => n === 0 ? 1 : n * factorial(n - 1)

2 * (1 === 0 ? 1 : 1 * (n => n === 0 ? 1 : n * factorial(n - 1))(1 - 1));
[beforeMarker] Binary expression 1 === 0 evaluated

2 * (false ? 1 : 1 * (n => n === 0 ? 1 : n * factorial(n - 1))(1 - 1));
[afterMarker] Binary expression 1 === 0 evaluated

2 * (false ? 1 : 1 * (n => n === 0 ? 1 : n * factorial(n - 1))(1 - 1));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

2 * (1 * (n => n === 0 ? 1 : n * factorial(n - 1))(1 - 1));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

2 * (1 * (n => n === 0 ? 1 : n * factorial(n - 1))(1 - 1));
[beforeMarker] Binary expression 1 - 1 evaluated

2 * (1 * (n => n === 0 ? 1 : n * factorial(n - 1))(0));
[afterMarker] Binary expression 1 - 1 evaluated

2 * (1 * (n => n === 0 ? 1 : n * factorial(n - 1))(0));
[beforeMarker] 0 substituted into n of n => n === 0 ? 1 : n * factorial(n - 1)

2 * (1 * (0 === 0 ? 1 : 0 * (n => n === 0 ? 1 : n * factorial(n - 1))(0 - 1)));
[afterMarker] 0 substituted into n of n => n === 0 ? 1 : n * factorial(n - 1)

2 * (1 * (0 === 0 ? 1 : 0 * (n => n === 0 ? 1 : n * factorial(n - 1))(0 - 1)));
[beforeMarker] Binary expression 0 === 0 evaluated

2 * (1 * (true ? 1 : 0 * (n => n === 0 ? 1 : n * factorial(n - 1))(0 - 1)));
[afterMarker] Binary expression 0 === 0 evaluated

2 * (1 * (true ? 1 : 0 * (n => n === 0 ? 1 : n * factorial(n - 1))(0 - 1)));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

2 * (1 * 1);
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

2 * (1 * 1);
[beforeMarker] Binary expression 1 * 1 evaluated

2 * 1;
[afterMarker] Binary expression 1 * 1 evaluated

2 * 1;
[beforeMarker] Binary expression 2 * 1 evaluated

2;
[afterMarker] Binary expression 2 * 1 evaluated

2;
[noMarker] Evaluation complete
"
`;

exports[`List operations Append on list of null 1`] = `
"const a = list(null);append(a, a);
[noMarker] Start of evaluation

const a = list(null);append(a, a);
[beforeMarker] list runs

const a = [null, null];append(a, a);
[afterMarker] list runs

const a = [null, null];append(a, a);
[beforeMarker] Constant a declared and substituted into the rest of block

append([null, null], [null, null]);
[afterMarker] Constant a declared and substituted into the rest of block

append([null, null], [null, null]);
[beforeMarker] append runs

$append([null, null], [null, null], xs => xs);
[afterMarker] append runs

$append([null, null], [null, null], xs => xs);
[beforeMarker] $append runs

((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([null, null], [null, null], xs => xs);
[afterMarker] $append runs

((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([null, null], [null, null], xs => xs);
[beforeMarker] [null, null], [null, null], xs => xs substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

is_null([null, null]) ? (xs => xs)([null, null]) : $append(tail([null, null]), [null, null], zs => (xs => xs)(pair(head([null, null]), zs)));
[afterMarker] [null, null], [null, null], xs => xs substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

is_null([null, null]) ? (xs => xs)([null, null]) : $append(tail([null, null]), [null, null], zs => (xs => xs)(pair(head([null, null]), zs)));
[beforeMarker] is_null runs

false ? (xs => xs)([null, null]) : $append(tail([null, null]), [null, null], zs => (xs => xs)(pair(head([null, null]), zs)));
[afterMarker] is_null runs

false ? (xs => xs)([null, null]) : $append(tail([null, null]), [null, null], zs => (xs => xs)(pair(head([null, null]), zs)));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

$append(tail([null, null]), [null, null], zs => (xs => xs)(pair(head([null, null]), zs)));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

$append(tail([null, null]), [null, null], zs => (xs => xs)(pair(head([null, null]), zs)));
[beforeMarker] tail runs

$append(null, [null, null], zs => (xs => xs)(pair(head([null, null]), zs)));
[afterMarker] tail runs

$append(null, [null, null], zs => (xs => xs)(pair(head([null, null]), zs)));
[beforeMarker] $append runs

((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))(null, [null, null], zs => (xs => xs)(pair(head([null, null]), zs)));
[afterMarker] $append runs

((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))(null, [null, null], zs => (xs => xs)(pair(head([null, null]), zs)));
[beforeMarker] null, [null, null], zs => (xs => xs)(pair(head([null, null]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

is_null(null) ? (zs => (xs => xs)(pair(head([null, null]), zs)))([null, null]) : $append(tail(null), [null, null], zs => (zs => (xs => xs)(pair(head([null, null]), zs)))(pair(head(null), zs)));
[afterMarker] null, [null, null], zs => (xs => xs)(pair(head([null, null]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

is_null(null) ? (zs => (xs => xs)(pair(head([null, null]), zs)))([null, null]) : $append(tail(null), [null, null], zs => (zs => (xs => xs)(pair(head([null, null]), zs)))(pair(head(null), zs)));
[beforeMarker] is_null runs

true ? (zs => (xs => xs)(pair(head([null, null]), zs)))([null, null]) : $append(tail(null), [null, null], zs => (zs => (xs => xs)(pair(head([null, null]), zs)))(pair(head(null), zs)));
[afterMarker] is_null runs

true ? (zs => (xs => xs)(pair(head([null, null]), zs)))([null, null]) : $append(tail(null), [null, null], zs => (zs => (xs => xs)(pair(head([null, null]), zs)))(pair(head(null), zs)));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

(zs => (xs => xs)(pair(head([null, null]), zs)))([null, null]);
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

(zs => (xs => xs)(pair(head([null, null]), zs)))([null, null]);
[beforeMarker] [null, null] substituted into zs of zs => (xs => xs)(pair(head([null, null]), zs))

(xs => xs)(pair(head([null, null]), [null, null]));
[afterMarker] [null, null] substituted into zs of zs => (xs => xs)(pair(head([null, null]), zs))

(xs => xs)(pair(head([null, null]), [null, null]));
[beforeMarker] head runs

(xs => xs)(pair(null, [null, null]));
[afterMarker] head runs

(xs => xs)(pair(null, [null, null]));
[beforeMarker] pair runs

(xs => xs)([null, [null, null]]);
[afterMarker] pair runs

(xs => xs)([null, [null, null]]);
[beforeMarker] [null, [null, null]] substituted into xs of xs => xs

[null, [null, null]];
[afterMarker] [null, [null, null]] substituted into xs of xs => xs

[null, [null, null]];
[noMarker] Evaluation complete
"
`;

exports[`List operations accumulate on list 1`] = `
"accumulate((x, y) => x + y, 0, list(1, 2, 3));
[noMarker] Start of evaluation

accumulate((x, y) => x + y, 0, list(1, 2, 3));
[beforeMarker] list runs

accumulate((x, y) => x + y, 0, [1, [2, [3, null]]]);
[afterMarker] list runs

accumulate((x, y) => x + y, 0, [1, [2, [3, null]]]);
[beforeMarker] accumulate runs

$accumulate((x, y) => x + y, 0, [1, [2, [3, null]]], x => x);
[afterMarker] accumulate runs

$accumulate((x, y) => x + y, 0, [1, [2, [3, null]]], x => x);
[beforeMarker] $accumulate runs

((f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x))))((x, y) => x + y, 0, [1, [2, [3, null]]], x => x);
[afterMarker] $accumulate runs

((f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x))))((x, y) => x + y, 0, [1, [2, [3, null]]], x => x);
[beforeMarker] (x, y) => x + y, 0, [1, [2, [3, null]]], x => x substituted into f, initial, xs, cont of (f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x)))

is_null([1, [2, [3, null]]]) ? (x => x)(0) : $accumulate((x, y) => x + y, 0, tail([1, [2, [3, null]]]), x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)));
[afterMarker] (x, y) => x + y, 0, [1, [2, [3, null]]], x => x substituted into f, initial, xs, cont of (f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x)))

is_null([1, [2, [3, null]]]) ? (x => x)(0) : $accumulate((x, y) => x + y, 0, tail([1, [2, [3, null]]]), x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)));
[beforeMarker] is_null runs

false ? (x => x)(0) : $accumulate((x, y) => x + y, 0, tail([1, [2, [3, null]]]), x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)));
[afterMarker] is_null runs

false ? (x => x)(0) : $accumulate((x, y) => x + y, 0, tail([1, [2, [3, null]]]), x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

$accumulate((x, y) => x + y, 0, tail([1, [2, [3, null]]]), x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

$accumulate((x, y) => x + y, 0, tail([1, [2, [3, null]]]), x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)));
[beforeMarker] tail runs

$accumulate((x, y) => x + y, 0, [2, [3, null]], x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)));
[afterMarker] tail runs

$accumulate((x, y) => x + y, 0, [2, [3, null]], x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)));
[beforeMarker] $accumulate runs

((f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x))))((x, y) => x + y, 0, [2, [3, null]], x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)));
[afterMarker] $accumulate runs

((f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x))))((x, y) => x + y, 0, [2, [3, null]], x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)));
[beforeMarker] (x, y) => x + y, 0, [2, [3, null]], x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)) substituted into f, initial, xs, cont of (f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x)))

is_null([2, [3, null]]) ? (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(0) : $accumulate((x, y) => x + y, 0, tail([2, [3, null]]), x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)));
[afterMarker] (x, y) => x + y, 0, [2, [3, null]], x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)) substituted into f, initial, xs, cont of (f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x)))

is_null([2, [3, null]]) ? (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(0) : $accumulate((x, y) => x + y, 0, tail([2, [3, null]]), x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)));
[beforeMarker] is_null runs

false ? (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(0) : $accumulate((x, y) => x + y, 0, tail([2, [3, null]]), x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)));
[afterMarker] is_null runs

false ? (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(0) : $accumulate((x, y) => x + y, 0, tail([2, [3, null]]), x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

$accumulate((x, y) => x + y, 0, tail([2, [3, null]]), x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

$accumulate((x, y) => x + y, 0, tail([2, [3, null]]), x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)));
[beforeMarker] tail runs

$accumulate((x, y) => x + y, 0, [3, null], x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)));
[afterMarker] tail runs

$accumulate((x, y) => x + y, 0, [3, null], x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)));
[beforeMarker] $accumulate runs

((f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x))))((x, y) => x + y, 0, [3, null], x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)));
[afterMarker] $accumulate runs

((f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x))))((x, y) => x + y, 0, [3, null], x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)));
[beforeMarker] (x, y) => x + y, 0, [3, null], x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)) substituted into f, initial, xs, cont of (f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x)))

is_null([3, null]) ? (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(0) : $accumulate((x, y) => x + y, 0, tail([3, null]), x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x)));
[afterMarker] (x, y) => x + y, 0, [3, null], x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)) substituted into f, initial, xs, cont of (f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x)))

is_null([3, null]) ? (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(0) : $accumulate((x, y) => x + y, 0, tail([3, null]), x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x)));
[beforeMarker] is_null runs

false ? (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(0) : $accumulate((x, y) => x + y, 0, tail([3, null]), x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x)));
[afterMarker] is_null runs

false ? (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(0) : $accumulate((x, y) => x + y, 0, tail([3, null]), x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x)));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

$accumulate((x, y) => x + y, 0, tail([3, null]), x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x)));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

$accumulate((x, y) => x + y, 0, tail([3, null]), x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x)));
[beforeMarker] tail runs

$accumulate((x, y) => x + y, 0, null, x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x)));
[afterMarker] tail runs

$accumulate((x, y) => x + y, 0, null, x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x)));
[beforeMarker] $accumulate runs

((f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x))))((x, y) => x + y, 0, null, x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x)));
[afterMarker] $accumulate runs

((f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x))))((x, y) => x + y, 0, null, x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x)));
[beforeMarker] (x, y) => x + y, 0, null, x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x)) substituted into f, initial, xs, cont of (f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x)))

is_null(null) ? (x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x)))(0) : $accumulate((x, y) => x + y, 0, tail(null), x => (x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x)))(((x, y) => x + y)(head(null), x)));
[afterMarker] (x, y) => x + y, 0, null, x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x)) substituted into f, initial, xs, cont of (f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x)))

is_null(null) ? (x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x)))(0) : $accumulate((x, y) => x + y, 0, tail(null), x => (x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x)))(((x, y) => x + y)(head(null), x)));
[beforeMarker] is_null runs

true ? (x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x)))(0) : $accumulate((x, y) => x + y, 0, tail(null), x => (x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x)))(((x, y) => x + y)(head(null), x)));
[afterMarker] is_null runs

true ? (x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x)))(0) : $accumulate((x, y) => x + y, 0, tail(null), x => (x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x)))(((x, y) => x + y)(head(null), x)));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

(x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x)))(0);
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

(x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x)))(0);
[beforeMarker] 0 substituted into x of x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x))

(x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), 0));
[afterMarker] 0 substituted into x of x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x))

(x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), 0));
[beforeMarker] head runs

(x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(3, 0));
[afterMarker] head runs

(x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(3, 0));
[beforeMarker] 3, 0 substituted into x, y of (x, y) => x + y

(x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(3 + 0);
[afterMarker] 3, 0 substituted into x, y of (x, y) => x + y

(x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(3 + 0);
[beforeMarker] Binary expression 3 + 0 evaluated

(x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(3);
[afterMarker] Binary expression 3 + 0 evaluated

(x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(3);
[beforeMarker] 3 substituted into x of x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x))

(x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), 3));
[afterMarker] 3 substituted into x of x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x))

(x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), 3));
[beforeMarker] head runs

(x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(2, 3));
[afterMarker] head runs

(x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(2, 3));
[beforeMarker] 2, 3 substituted into x, y of (x, y) => x + y

(x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(2 + 3);
[afterMarker] 2, 3 substituted into x, y of (x, y) => x + y

(x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(2 + 3);
[beforeMarker] Binary expression 2 + 3 evaluated

(x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(5);
[afterMarker] Binary expression 2 + 3 evaluated

(x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(5);
[beforeMarker] 5 substituted into x of x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x))

(x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), 5));
[afterMarker] 5 substituted into x of x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x))

(x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), 5));
[beforeMarker] head runs

(x => x)(((x, y) => x + y)(1, 5));
[afterMarker] head runs

(x => x)(((x, y) => x + y)(1, 5));
[beforeMarker] 1, 5 substituted into x, y of (x, y) => x + y

(x => x)(1 + 5);
[afterMarker] 1, 5 substituted into x, y of (x, y) => x + y

(x => x)(1 + 5);
[beforeMarker] Binary expression 1 + 5 evaluated

(x => x)(6);
[afterMarker] Binary expression 1 + 5 evaluated

(x => x)(6);
[beforeMarker] 6 substituted into x of x => x

6;
[afterMarker] 6 substituted into x of x => x

6;
[noMarker] Evaluation complete
"
`;

exports[`List operations filter on list 1`] = `
"filter(x => x % 2 === 1, list(1, 2, 3));
[noMarker] Start of evaluation

filter(x => x % 2 === 1, list(1, 2, 3));
[beforeMarker] list runs

filter(x => x % 2 === 1, [1, [2, [3, null]]]);
[afterMarker] list runs

filter(x => x % 2 === 1, [1, [2, [3, null]]]);
[beforeMarker] filter runs

$filter(x => x % 2 === 1, [1, [2, [3, null]]], null);
[afterMarker] filter runs

$filter(x => x % 2 === 1, [1, [2, [3, null]]], null);
[beforeMarker] $filter runs

((pred, xs, acc) => is_null(xs) ? reverse(acc) : pred(head(xs)) ? $filter(pred, tail(xs), pair(head(xs), acc)) : $filter(pred, tail(xs), acc))(x => x % 2 === 1, [1, [2, [3, null]]], null);
[afterMarker] $filter runs

((pred, xs, acc) => is_null(xs) ? reverse(acc) : pred(head(xs)) ? $filter(pred, tail(xs), pair(head(xs), acc)) : $filter(pred, tail(xs), acc))(x => x % 2 === 1, [1, [2, [3, null]]], null);
[beforeMarker] x => x % 2 === 1, [1, [2, [3, null]]], null substituted into pred, xs, acc of (pred, xs, acc) => is_null(xs) ? reverse(acc) : pred(head(xs)) ? $filter(pred, tail(xs), pair(head(xs), acc)) : $filter(pred, tail(xs), acc)

is_null([1, [2, [3, null]]]) ? reverse(null) : (x => x % 2 === 1)(head([1, [2, [3, null]]])) ? $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), pair(head([1, [2, [3, null]]]), null)) : $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), null);
[afterMarker] x => x % 2 === 1, [1, [2, [3, null]]], null substituted into pred, xs, acc of (pred, xs, acc) => is_null(xs) ? reverse(acc) : pred(head(xs)) ? $filter(pred, tail(xs), pair(head(xs), acc)) : $filter(pred, tail(xs), acc)

is_null([1, [2, [3, null]]]) ? reverse(null) : (x => x % 2 === 1)(head([1, [2, [3, null]]])) ? $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), pair(head([1, [2, [3, null]]]), null)) : $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), null);
[beforeMarker] is_null runs

false ? reverse(null) : (x => x % 2 === 1)(head([1, [2, [3, null]]])) ? $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), pair(head([1, [2, [3, null]]]), null)) : $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), null);
[afterMarker] is_null runs

false ? reverse(null) : (x => x % 2 === 1)(head([1, [2, [3, null]]])) ? $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), pair(head([1, [2, [3, null]]]), null)) : $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), null);
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(x => x % 2 === 1)(head([1, [2, [3, null]]])) ? $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), pair(head([1, [2, [3, null]]]), null)) : $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), null);
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(x => x % 2 === 1)(head([1, [2, [3, null]]])) ? $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), pair(head([1, [2, [3, null]]]), null)) : $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), null);
[beforeMarker] head runs

(x => x % 2 === 1)(1) ? $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), pair(head([1, [2, [3, null]]]), null)) : $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), null);
[afterMarker] head runs

(x => x % 2 === 1)(1) ? $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), pair(head([1, [2, [3, null]]]), null)) : $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), null);
[beforeMarker] 1 substituted into x of x => x % 2 === 1

1 % 2 === 1 ? $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), pair(head([1, [2, [3, null]]]), null)) : $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), null);
[afterMarker] 1 substituted into x of x => x % 2 === 1

1 % 2 === 1 ? $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), pair(head([1, [2, [3, null]]]), null)) : $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), null);
[beforeMarker] Binary expression 1 % 2 evaluated

1 === 1 ? $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), pair(head([1, [2, [3, null]]]), null)) : $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), null);
[afterMarker] Binary expression 1 % 2 evaluated

1 === 1 ? $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), pair(head([1, [2, [3, null]]]), null)) : $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), null);
[beforeMarker] Binary expression 1 === 1 evaluated

true ? $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), pair(head([1, [2, [3, null]]]), null)) : $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), null);
[afterMarker] Binary expression 1 === 1 evaluated

true ? $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), pair(head([1, [2, [3, null]]]), null)) : $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), null);
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

$filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), pair(head([1, [2, [3, null]]]), null));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

$filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), pair(head([1, [2, [3, null]]]), null));
[beforeMarker] tail runs

$filter(x => x % 2 === 1, [2, [3, null]], pair(head([1, [2, [3, null]]]), null));
[afterMarker] tail runs

$filter(x => x % 2 === 1, [2, [3, null]], pair(head([1, [2, [3, null]]]), null));
[beforeMarker] head runs

$filter(x => x % 2 === 1, [2, [3, null]], pair(1, null));
[afterMarker] head runs

$filter(x => x % 2 === 1, [2, [3, null]], pair(1, null));
[beforeMarker] pair runs

$filter(x => x % 2 === 1, [2, [3, null]], [1, null]);
[afterMarker] pair runs

$filter(x => x % 2 === 1, [2, [3, null]], [1, null]);
[beforeMarker] $filter runs

((pred, xs, acc) => is_null(xs) ? reverse(acc) : pred(head(xs)) ? $filter(pred, tail(xs), pair(head(xs), acc)) : $filter(pred, tail(xs), acc))(x => x % 2 === 1, [2, [3, null]], [1, null]);
[afterMarker] $filter runs

((pred, xs, acc) => is_null(xs) ? reverse(acc) : pred(head(xs)) ? $filter(pred, tail(xs), pair(head(xs), acc)) : $filter(pred, tail(xs), acc))(x => x % 2 === 1, [2, [3, null]], [1, null]);
[beforeMarker] x => x % 2 === 1, [2, [3, null]], [1, null] substituted into pred, xs, acc of (pred, xs, acc) => is_null(xs) ? reverse(acc) : pred(head(xs)) ? $filter(pred, tail(xs), pair(head(xs), acc)) : $filter(pred, tail(xs), acc)

is_null([2, [3, null]]) ? reverse([1, null]) : (x => x % 2 === 1)(head([2, [3, null]])) ? $filter(x => x % 2 === 1, tail([2, [3, null]]), pair(head([2, [3, null]]), [1, null])) : $filter(x => x % 2 === 1, tail([2, [3, null]]), [1, null]);
[afterMarker] x => x % 2 === 1, [2, [3, null]], [1, null] substituted into pred, xs, acc of (pred, xs, acc) => is_null(xs) ? reverse(acc) : pred(head(xs)) ? $filter(pred, tail(xs), pair(head(xs), acc)) : $filter(pred, tail(xs), acc)

is_null([2, [3, null]]) ? reverse([1, null]) : (x => x % 2 === 1)(head([2, [3, null]])) ? $filter(x => x % 2 === 1, tail([2, [3, null]]), pair(head([2, [3, null]]), [1, null])) : $filter(x => x % 2 === 1, tail([2, [3, null]]), [1, null]);
[beforeMarker] is_null runs

false ? reverse([1, null]) : (x => x % 2 === 1)(head([2, [3, null]])) ? $filter(x => x % 2 === 1, tail([2, [3, null]]), pair(head([2, [3, null]]), [1, null])) : $filter(x => x % 2 === 1, tail([2, [3, null]]), [1, null]);
[afterMarker] is_null runs

false ? reverse([1, null]) : (x => x % 2 === 1)(head([2, [3, null]])) ? $filter(x => x % 2 === 1, tail([2, [3, null]]), pair(head([2, [3, null]]), [1, null])) : $filter(x => x % 2 === 1, tail([2, [3, null]]), [1, null]);
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(x => x % 2 === 1)(head([2, [3, null]])) ? $filter(x => x % 2 === 1, tail([2, [3, null]]), pair(head([2, [3, null]]), [1, null])) : $filter(x => x % 2 === 1, tail([2, [3, null]]), [1, null]);
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(x => x % 2 === 1)(head([2, [3, null]])) ? $filter(x => x % 2 === 1, tail([2, [3, null]]), pair(head([2, [3, null]]), [1, null])) : $filter(x => x % 2 === 1, tail([2, [3, null]]), [1, null]);
[beforeMarker] head runs

(x => x % 2 === 1)(2) ? $filter(x => x % 2 === 1, tail([2, [3, null]]), pair(head([2, [3, null]]), [1, null])) : $filter(x => x % 2 === 1, tail([2, [3, null]]), [1, null]);
[afterMarker] head runs

(x => x % 2 === 1)(2) ? $filter(x => x % 2 === 1, tail([2, [3, null]]), pair(head([2, [3, null]]), [1, null])) : $filter(x => x % 2 === 1, tail([2, [3, null]]), [1, null]);
[beforeMarker] 2 substituted into x of x => x % 2 === 1

2 % 2 === 1 ? $filter(x => x % 2 === 1, tail([2, [3, null]]), pair(head([2, [3, null]]), [1, null])) : $filter(x => x % 2 === 1, tail([2, [3, null]]), [1, null]);
[afterMarker] 2 substituted into x of x => x % 2 === 1

2 % 2 === 1 ? $filter(x => x % 2 === 1, tail([2, [3, null]]), pair(head([2, [3, null]]), [1, null])) : $filter(x => x % 2 === 1, tail([2, [3, null]]), [1, null]);
[beforeMarker] Binary expression 2 % 2 evaluated

0 === 1 ? $filter(x => x % 2 === 1, tail([2, [3, null]]), pair(head([2, [3, null]]), [1, null])) : $filter(x => x % 2 === 1, tail([2, [3, null]]), [1, null]);
[afterMarker] Binary expression 2 % 2 evaluated

0 === 1 ? $filter(x => x % 2 === 1, tail([2, [3, null]]), pair(head([2, [3, null]]), [1, null])) : $filter(x => x % 2 === 1, tail([2, [3, null]]), [1, null]);
[beforeMarker] Binary expression 0 === 1 evaluated

false ? $filter(x => x % 2 === 1, tail([2, [3, null]]), pair(head([2, [3, null]]), [1, null])) : $filter(x => x % 2 === 1, tail([2, [3, null]]), [1, null]);
[afterMarker] Binary expression 0 === 1 evaluated

false ? $filter(x => x % 2 === 1, tail([2, [3, null]]), pair(head([2, [3, null]]), [1, null])) : $filter(x => x % 2 === 1, tail([2, [3, null]]), [1, null]);
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

$filter(x => x % 2 === 1, tail([2, [3, null]]), [1, null]);
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

$filter(x => x % 2 === 1, tail([2, [3, null]]), [1, null]);
[beforeMarker] tail runs

$filter(x => x % 2 === 1, [3, null], [1, null]);
[afterMarker] tail runs

$filter(x => x % 2 === 1, [3, null], [1, null]);
[beforeMarker] $filter runs

((pred, xs, acc) => is_null(xs) ? reverse(acc) : pred(head(xs)) ? $filter(pred, tail(xs), pair(head(xs), acc)) : $filter(pred, tail(xs), acc))(x => x % 2 === 1, [3, null], [1, null]);
[afterMarker] $filter runs

((pred, xs, acc) => is_null(xs) ? reverse(acc) : pred(head(xs)) ? $filter(pred, tail(xs), pair(head(xs), acc)) : $filter(pred, tail(xs), acc))(x => x % 2 === 1, [3, null], [1, null]);
[beforeMarker] x => x % 2 === 1, [3, null], [1, null] substituted into pred, xs, acc of (pred, xs, acc) => is_null(xs) ? reverse(acc) : pred(head(xs)) ? $filter(pred, tail(xs), pair(head(xs), acc)) : $filter(pred, tail(xs), acc)

is_null([3, null]) ? reverse([1, null]) : (x => x % 2 === 1)(head([3, null])) ? $filter(x => x % 2 === 1, tail([3, null]), pair(head([3, null]), [1, null])) : $filter(x => x % 2 === 1, tail([3, null]), [1, null]);
[afterMarker] x => x % 2 === 1, [3, null], [1, null] substituted into pred, xs, acc of (pred, xs, acc) => is_null(xs) ? reverse(acc) : pred(head(xs)) ? $filter(pred, tail(xs), pair(head(xs), acc)) : $filter(pred, tail(xs), acc)

is_null([3, null]) ? reverse([1, null]) : (x => x % 2 === 1)(head([3, null])) ? $filter(x => x % 2 === 1, tail([3, null]), pair(head([3, null]), [1, null])) : $filter(x => x % 2 === 1, tail([3, null]), [1, null]);
[beforeMarker] is_null runs

false ? reverse([1, null]) : (x => x % 2 === 1)(head([3, null])) ? $filter(x => x % 2 === 1, tail([3, null]), pair(head([3, null]), [1, null])) : $filter(x => x % 2 === 1, tail([3, null]), [1, null]);
[afterMarker] is_null runs

false ? reverse([1, null]) : (x => x % 2 === 1)(head([3, null])) ? $filter(x => x % 2 === 1, tail([3, null]), pair(head([3, null]), [1, null])) : $filter(x => x % 2 === 1, tail([3, null]), [1, null]);
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(x => x % 2 === 1)(head([3, null])) ? $filter(x => x % 2 === 1, tail([3, null]), pair(head([3, null]), [1, null])) : $filter(x => x % 2 === 1, tail([3, null]), [1, null]);
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(x => x % 2 === 1)(head([3, null])) ? $filter(x => x % 2 === 1, tail([3, null]), pair(head([3, null]), [1, null])) : $filter(x => x % 2 === 1, tail([3, null]), [1, null]);
[beforeMarker] head runs

(x => x % 2 === 1)(3) ? $filter(x => x % 2 === 1, tail([3, null]), pair(head([3, null]), [1, null])) : $filter(x => x % 2 === 1, tail([3, null]), [1, null]);
[afterMarker] head runs

(x => x % 2 === 1)(3) ? $filter(x => x % 2 === 1, tail([3, null]), pair(head([3, null]), [1, null])) : $filter(x => x % 2 === 1, tail([3, null]), [1, null]);
[beforeMarker] 3 substituted into x of x => x % 2 === 1

3 % 2 === 1 ? $filter(x => x % 2 === 1, tail([3, null]), pair(head([3, null]), [1, null])) : $filter(x => x % 2 === 1, tail([3, null]), [1, null]);
[afterMarker] 3 substituted into x of x => x % 2 === 1

3 % 2 === 1 ? $filter(x => x % 2 === 1, tail([3, null]), pair(head([3, null]), [1, null])) : $filter(x => x % 2 === 1, tail([3, null]), [1, null]);
[beforeMarker] Binary expression 3 % 2 evaluated

1 === 1 ? $filter(x => x % 2 === 1, tail([3, null]), pair(head([3, null]), [1, null])) : $filter(x => x % 2 === 1, tail([3, null]), [1, null]);
[afterMarker] Binary expression 3 % 2 evaluated

1 === 1 ? $filter(x => x % 2 === 1, tail([3, null]), pair(head([3, null]), [1, null])) : $filter(x => x % 2 === 1, tail([3, null]), [1, null]);
[beforeMarker] Binary expression 1 === 1 evaluated

true ? $filter(x => x % 2 === 1, tail([3, null]), pair(head([3, null]), [1, null])) : $filter(x => x % 2 === 1, tail([3, null]), [1, null]);
[afterMarker] Binary expression 1 === 1 evaluated

true ? $filter(x => x % 2 === 1, tail([3, null]), pair(head([3, null]), [1, null])) : $filter(x => x % 2 === 1, tail([3, null]), [1, null]);
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

$filter(x => x % 2 === 1, tail([3, null]), pair(head([3, null]), [1, null]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

$filter(x => x % 2 === 1, tail([3, null]), pair(head([3, null]), [1, null]));
[beforeMarker] tail runs

$filter(x => x % 2 === 1, null, pair(head([3, null]), [1, null]));
[afterMarker] tail runs

$filter(x => x % 2 === 1, null, pair(head([3, null]), [1, null]));
[beforeMarker] head runs

$filter(x => x % 2 === 1, null, pair(3, [1, null]));
[afterMarker] head runs

$filter(x => x % 2 === 1, null, pair(3, [1, null]));
[beforeMarker] pair runs

$filter(x => x % 2 === 1, null, [3, [1, null]]);
[afterMarker] pair runs

$filter(x => x % 2 === 1, null, [3, [1, null]]);
[beforeMarker] $filter runs

((pred, xs, acc) => is_null(xs) ? reverse(acc) : pred(head(xs)) ? $filter(pred, tail(xs), pair(head(xs), acc)) : $filter(pred, tail(xs), acc))(x => x % 2 === 1, null, [3, [1, null]]);
[afterMarker] $filter runs

((pred, xs, acc) => is_null(xs) ? reverse(acc) : pred(head(xs)) ? $filter(pred, tail(xs), pair(head(xs), acc)) : $filter(pred, tail(xs), acc))(x => x % 2 === 1, null, [3, [1, null]]);
[beforeMarker] x => x % 2 === 1, null, [3, [1, null]] substituted into pred, xs, acc of (pred, xs, acc) => is_null(xs) ? reverse(acc) : pred(head(xs)) ? $filter(pred, tail(xs), pair(head(xs), acc)) : $filter(pred, tail(xs), acc)

is_null(null) ? reverse([3, [1, null]]) : (x => x % 2 === 1)(head(null)) ? $filter(x => x % 2 === 1, tail(null), pair(head(null), [3, [1, null]])) : $filter(x => x % 2 === 1, tail(null), [3, [1, null]]);
[afterMarker] x => x % 2 === 1, null, [3, [1, null]] substituted into pred, xs, acc of (pred, xs, acc) => is_null(xs) ? reverse(acc) : pred(head(xs)) ? $filter(pred, tail(xs), pair(head(xs), acc)) : $filter(pred, tail(xs), acc)

is_null(null) ? reverse([3, [1, null]]) : (x => x % 2 === 1)(head(null)) ? $filter(x => x % 2 === 1, tail(null), pair(head(null), [3, [1, null]])) : $filter(x => x % 2 === 1, tail(null), [3, [1, null]]);
[beforeMarker] is_null runs

true ? reverse([3, [1, null]]) : (x => x % 2 === 1)(head(null)) ? $filter(x => x % 2 === 1, tail(null), pair(head(null), [3, [1, null]])) : $filter(x => x % 2 === 1, tail(null), [3, [1, null]]);
[afterMarker] is_null runs

true ? reverse([3, [1, null]]) : (x => x % 2 === 1)(head(null)) ? $filter(x => x % 2 === 1, tail(null), pair(head(null), [3, [1, null]])) : $filter(x => x % 2 === 1, tail(null), [3, [1, null]]);
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

reverse([3, [1, null]]);
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

reverse([3, [1, null]]);
[beforeMarker] reverse runs

$reverse([3, [1, null]], null);
[afterMarker] reverse runs

$reverse([3, [1, null]], null);
[beforeMarker] $reverse runs

((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([3, [1, null]], null);
[afterMarker] $reverse runs

((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([3, [1, null]], null);
[beforeMarker] [3, [1, null]], null substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

is_null([3, [1, null]]) ? null : $reverse(tail([3, [1, null]]), pair(head([3, [1, null]]), null));
[afterMarker] [3, [1, null]], null substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

is_null([3, [1, null]]) ? null : $reverse(tail([3, [1, null]]), pair(head([3, [1, null]]), null));
[beforeMarker] is_null runs

false ? null : $reverse(tail([3, [1, null]]), pair(head([3, [1, null]]), null));
[afterMarker] is_null runs

false ? null : $reverse(tail([3, [1, null]]), pair(head([3, [1, null]]), null));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

$reverse(tail([3, [1, null]]), pair(head([3, [1, null]]), null));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

$reverse(tail([3, [1, null]]), pair(head([3, [1, null]]), null));
[beforeMarker] tail runs

$reverse([1, null], pair(head([3, [1, null]]), null));
[afterMarker] tail runs

$reverse([1, null], pair(head([3, [1, null]]), null));
[beforeMarker] head runs

$reverse([1, null], pair(3, null));
[afterMarker] head runs

$reverse([1, null], pair(3, null));
[beforeMarker] pair runs

$reverse([1, null], [3, null]);
[afterMarker] pair runs

$reverse([1, null], [3, null]);
[beforeMarker] $reverse runs

((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([1, null], [3, null]);
[afterMarker] $reverse runs

((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([1, null], [3, null]);
[beforeMarker] [1, null], [3, null] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

is_null([1, null]) ? [3, null] : $reverse(tail([1, null]), pair(head([1, null]), [3, null]));
[afterMarker] [1, null], [3, null] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

is_null([1, null]) ? [3, null] : $reverse(tail([1, null]), pair(head([1, null]), [3, null]));
[beforeMarker] is_null runs

false ? [3, null] : $reverse(tail([1, null]), pair(head([1, null]), [3, null]));
[afterMarker] is_null runs

false ? [3, null] : $reverse(tail([1, null]), pair(head([1, null]), [3, null]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

$reverse(tail([1, null]), pair(head([1, null]), [3, null]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

$reverse(tail([1, null]), pair(head([1, null]), [3, null]));
[beforeMarker] tail runs

$reverse(null, pair(head([1, null]), [3, null]));
[afterMarker] tail runs

$reverse(null, pair(head([1, null]), [3, null]));
[beforeMarker] head runs

$reverse(null, pair(1, [3, null]));
[afterMarker] head runs

$reverse(null, pair(1, [3, null]));
[beforeMarker] pair runs

$reverse(null, [1, [3, null]]);
[afterMarker] pair runs

$reverse(null, [1, [3, null]]);
[beforeMarker] $reverse runs

((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))(null, [1, [3, null]]);
[afterMarker] $reverse runs

((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))(null, [1, [3, null]]);
[beforeMarker] null, [1, [3, null]] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

is_null(null) ? [1, [3, null]] : $reverse(tail(null), pair(head(null), [1, [3, null]]));
[afterMarker] null, [1, [3, null]] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

is_null(null) ? [1, [3, null]] : $reverse(tail(null), pair(head(null), [1, [3, null]]));
[beforeMarker] is_null runs

true ? [1, [3, null]] : $reverse(tail(null), pair(head(null), [1, [3, null]]));
[afterMarker] is_null runs

true ? [1, [3, null]] : $reverse(tail(null), pair(head(null), [1, [3, null]]));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

[1, [3, null]];
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

[1, [3, null]];
[noMarker] Evaluation complete
"
`;

exports[`List operations flatmap 1`] = `
"const flatMap = (f, xs) => accumulate((acc, init) => append(f(acc), init), null, xs);flatMap(x => list(x, x + 1), list(2, 3, 4));
[noMarker] Start of evaluation

const flatMap = (f, xs) => accumulate((acc, init) => append(f(acc), init), null, xs);flatMap(x => list(x, x + 1), list(2, 3, 4));
[beforeMarker] Constant flatMap declared and substituted into the rest of block

((f, xs) => accumulate((acc, init) => append(f(acc), init), null, xs))(x => list(x, x + 1), list(2, 3, 4));
[afterMarker] Constant flatMap declared and substituted into the rest of block

((f, xs) => accumulate((acc, init) => append(f(acc), init), null, xs))(x => list(x, x + 1), list(2, 3, 4));
[beforeMarker] list runs

((f, xs) => accumulate((acc, init) => append(f(acc), init), null, xs))(x => list(x, x + 1), [2, [3, [4, null]]]);
[afterMarker] list runs

((f, xs) => accumulate((acc, init) => append(f(acc), init), null, xs))(x => list(x, x + 1), [2, [3, [4, null]]]);
[beforeMarker] x => list(x, x + 1), [2, [3, [4, null]]] substituted into f, xs of (f, xs) => accumulate((acc, init) => append(f(acc), init), null, xs)

accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, [2, [3, [4, null]]]);
[afterMarker] x => list(x, x + 1), [2, [3, [4, null]]] substituted into f, xs of (f, xs) => accumulate((acc, init) => append(f(acc), init), null, xs)

accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, [2, [3, [4, null]]]);
[beforeMarker] accumulate runs

$accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, [2, [3, [4, null]]], x => x);
[afterMarker] accumulate runs

$accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, [2, [3, [4, null]]], x => x);
[beforeMarker] $accumulate runs

((f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x))))((acc, init) => append((x => list(x, x + 1))(acc), init), null, [2, [3, [4, null]]], x => x);
[afterMarker] $accumulate runs

((f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x))))((acc, init) => append((x => list(x, x + 1))(acc), init), null, [2, [3, [4, null]]], x => x);
[beforeMarker] (acc, init) => append((x => list(x, x + 1))(acc), init), null, [2, [3, [4, null]]], x => x substituted into f, initial, xs, cont of (f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x)))

is_null([2, [3, [4, null]]]) ? (x => x)(null) : $accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail([2, [3, [4, null]]]), x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)));
[afterMarker] (acc, init) => append((x => list(x, x + 1))(acc), init), null, [2, [3, [4, null]]], x => x substituted into f, initial, xs, cont of (f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x)))

is_null([2, [3, [4, null]]]) ? (x => x)(null) : $accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail([2, [3, [4, null]]]), x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)));
[beforeMarker] is_null runs

false ? (x => x)(null) : $accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail([2, [3, [4, null]]]), x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)));
[afterMarker] is_null runs

false ? (x => x)(null) : $accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail([2, [3, [4, null]]]), x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

$accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail([2, [3, [4, null]]]), x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

$accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail([2, [3, [4, null]]]), x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)));
[beforeMarker] tail runs

$accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, [3, [4, null]], x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)));
[afterMarker] tail runs

$accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, [3, [4, null]], x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)));
[beforeMarker] $accumulate runs

((f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x))))((acc, init) => append((x => list(x, x + 1))(acc), init), null, [3, [4, null]], x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)));
[afterMarker] $accumulate runs

((f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x))))((acc, init) => append((x => list(x, x + 1))(acc), init), null, [3, [4, null]], x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)));
[beforeMarker] (acc, init) => append((x => list(x, x + 1))(acc), init), null, [3, [4, null]], x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)) substituted into f, initial, xs, cont of (f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x)))

is_null([3, [4, null]]) ? (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(null) : $accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail([3, [4, null]]), x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)));
[afterMarker] (acc, init) => append((x => list(x, x + 1))(acc), init), null, [3, [4, null]], x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)) substituted into f, initial, xs, cont of (f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x)))

is_null([3, [4, null]]) ? (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(null) : $accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail([3, [4, null]]), x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)));
[beforeMarker] is_null runs

false ? (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(null) : $accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail([3, [4, null]]), x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)));
[afterMarker] is_null runs

false ? (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(null) : $accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail([3, [4, null]]), x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

$accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail([3, [4, null]]), x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

$accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail([3, [4, null]]), x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)));
[beforeMarker] tail runs

$accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, [4, null], x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)));
[afterMarker] tail runs

$accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, [4, null], x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)));
[beforeMarker] $accumulate runs

((f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x))))((acc, init) => append((x => list(x, x + 1))(acc), init), null, [4, null], x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)));
[afterMarker] $accumulate runs

((f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x))))((acc, init) => append((x => list(x, x + 1))(acc), init), null, [4, null], x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)));
[beforeMarker] (acc, init) => append((x => list(x, x + 1))(acc), init), null, [4, null], x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)) substituted into f, initial, xs, cont of (f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x)))

is_null([4, null]) ? (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(null) : $accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail([4, null]), x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x)));
[afterMarker] (acc, init) => append((x => list(x, x + 1))(acc), init), null, [4, null], x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)) substituted into f, initial, xs, cont of (f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x)))

is_null([4, null]) ? (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(null) : $accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail([4, null]), x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x)));
[beforeMarker] is_null runs

false ? (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(null) : $accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail([4, null]), x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x)));
[afterMarker] is_null runs

false ? (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(null) : $accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail([4, null]), x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x)));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

$accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail([4, null]), x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x)));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

$accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail([4, null]), x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x)));
[beforeMarker] tail runs

$accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, null, x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x)));
[afterMarker] tail runs

$accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, null, x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x)));
[beforeMarker] $accumulate runs

((f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x))))((acc, init) => append((x => list(x, x + 1))(acc), init), null, null, x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x)));
[afterMarker] $accumulate runs

((f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x))))((acc, init) => append((x => list(x, x + 1))(acc), init), null, null, x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x)));
[beforeMarker] (acc, init) => append((x => list(x, x + 1))(acc), init), null, null, x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x)) substituted into f, initial, xs, cont of (f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x)))

is_null(null) ? (x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x)))(null) : $accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail(null), x => (x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head(null), x)));
[afterMarker] (acc, init) => append((x => list(x, x + 1))(acc), init), null, null, x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x)) substituted into f, initial, xs, cont of (f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x)))

is_null(null) ? (x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x)))(null) : $accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail(null), x => (x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head(null), x)));
[beforeMarker] is_null runs

true ? (x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x)))(null) : $accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail(null), x => (x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head(null), x)));
[afterMarker] is_null runs

true ? (x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x)))(null) : $accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail(null), x => (x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head(null), x)));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

(x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x)))(null);
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

(x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x)))(null);
[beforeMarker] null substituted into x of x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x))

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), null));
[afterMarker] null substituted into x of x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x))

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), null));
[beforeMarker] head runs

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(4, null));
[afterMarker] head runs

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(4, null));
[beforeMarker] 4, null substituted into acc, init of (acc, init) => append((x => list(x, x + 1))(acc), init)

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(append((x => list(x, x + 1))(4), null));
[afterMarker] 4, null substituted into acc, init of (acc, init) => append((x => list(x, x + 1))(acc), init)

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(append((x => list(x, x + 1))(4), null));
[beforeMarker] 4 substituted into x of x => list(x, x + 1)

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(append(list(4, 4 + 1), null));
[afterMarker] 4 substituted into x of x => list(x, x + 1)

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(append(list(4, 4 + 1), null));
[beforeMarker] Binary expression 4 + 1 evaluated

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(append(list(4, 5), null));
[afterMarker] Binary expression 4 + 1 evaluated

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(append(list(4, 5), null));
[beforeMarker] list runs

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(append([4, [5, null]], null));
[afterMarker] list runs

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(append([4, [5, null]], null));
[beforeMarker] append runs

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))($append([4, [5, null]], null, xs => xs));
[afterMarker] append runs

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))($append([4, [5, null]], null, xs => xs));
[beforeMarker] $append runs

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([4, [5, null]], null, xs => xs));
[afterMarker] $append runs

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([4, [5, null]], null, xs => xs));
[beforeMarker] [4, [5, null]], null, xs => xs substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(is_null([4, [5, null]]) ? (xs => xs)(null) : $append(tail([4, [5, null]]), null, zs => (xs => xs)(pair(head([4, [5, null]]), zs))));
[afterMarker] [4, [5, null]], null, xs => xs substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(is_null([4, [5, null]]) ? (xs => xs)(null) : $append(tail([4, [5, null]]), null, zs => (xs => xs)(pair(head([4, [5, null]]), zs))));
[beforeMarker] is_null runs

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(false ? (xs => xs)(null) : $append(tail([4, [5, null]]), null, zs => (xs => xs)(pair(head([4, [5, null]]), zs))));
[afterMarker] is_null runs

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(false ? (xs => xs)(null) : $append(tail([4, [5, null]]), null, zs => (xs => xs)(pair(head([4, [5, null]]), zs))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))($append(tail([4, [5, null]]), null, zs => (xs => xs)(pair(head([4, [5, null]]), zs))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))($append(tail([4, [5, null]]), null, zs => (xs => xs)(pair(head([4, [5, null]]), zs))));
[beforeMarker] tail runs

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))($append([5, null], null, zs => (xs => xs)(pair(head([4, [5, null]]), zs))));
[afterMarker] tail runs

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))($append([5, null], null, zs => (xs => xs)(pair(head([4, [5, null]]), zs))));
[beforeMarker] $append runs

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([5, null], null, zs => (xs => xs)(pair(head([4, [5, null]]), zs))));
[afterMarker] $append runs

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([5, null], null, zs => (xs => xs)(pair(head([4, [5, null]]), zs))));
[beforeMarker] [5, null], null, zs => (xs => xs)(pair(head([4, [5, null]]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(is_null([5, null]) ? (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(null) : $append(tail([5, null]), null, zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs))));
[afterMarker] [5, null], null, zs => (xs => xs)(pair(head([4, [5, null]]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(is_null([5, null]) ? (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(null) : $append(tail([5, null]), null, zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs))));
[beforeMarker] is_null runs

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(false ? (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(null) : $append(tail([5, null]), null, zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs))));
[afterMarker] is_null runs

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(false ? (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(null) : $append(tail([5, null]), null, zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))($append(tail([5, null]), null, zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))($append(tail([5, null]), null, zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs))));
[beforeMarker] tail runs

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))($append(null, null, zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs))));
[afterMarker] tail runs

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))($append(null, null, zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs))));
[beforeMarker] $append runs

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))(null, null, zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs))));
[afterMarker] $append runs

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))(null, null, zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs))));
[beforeMarker] null, null, zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(is_null(null) ? (zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs)))(null) : $append(tail(null), null, zs => (zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs)))(pair(head(null), zs))));
[afterMarker] null, null, zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(is_null(null) ? (zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs)))(null) : $append(tail(null), null, zs => (zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs)))(pair(head(null), zs))));
[beforeMarker] is_null runs

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(true ? (zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs)))(null) : $append(tail(null), null, zs => (zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs)))(pair(head(null), zs))));
[afterMarker] is_null runs

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(true ? (zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs)))(null) : $append(tail(null), null, zs => (zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs)))(pair(head(null), zs))));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))((zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs)))(null));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))((zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs)))(null));
[beforeMarker] null substituted into zs of zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs))

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))((zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), null)));
[afterMarker] null substituted into zs of zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs))

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))((zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), null)));
[beforeMarker] head runs

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))((zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(5, null)));
[afterMarker] head runs

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))((zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(5, null)));
[beforeMarker] pair runs

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))((zs => (xs => xs)(pair(head([4, [5, null]]), zs)))([5, null]));
[afterMarker] pair runs

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))((zs => (xs => xs)(pair(head([4, [5, null]]), zs)))([5, null]));
[beforeMarker] [5, null] substituted into zs of zs => (xs => xs)(pair(head([4, [5, null]]), zs))

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))((xs => xs)(pair(head([4, [5, null]]), [5, null])));
[afterMarker] [5, null] substituted into zs of zs => (xs => xs)(pair(head([4, [5, null]]), zs))

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))((xs => xs)(pair(head([4, [5, null]]), [5, null])));
[beforeMarker] head runs

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))((xs => xs)(pair(4, [5, null])));
[afterMarker] head runs

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))((xs => xs)(pair(4, [5, null])));
[beforeMarker] pair runs

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))((xs => xs)([4, [5, null]]));
[afterMarker] pair runs

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))((xs => xs)([4, [5, null]]));
[beforeMarker] [4, [5, null]] substituted into xs of xs => xs

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))([4, [5, null]]);
[afterMarker] [4, [5, null]] substituted into xs of xs => xs

(x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))([4, [5, null]]);
[beforeMarker] [4, [5, null]] substituted into x of x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x))

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), [4, [5, null]]));
[afterMarker] [4, [5, null]] substituted into x of x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x))

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), [4, [5, null]]));
[beforeMarker] head runs

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(3, [4, [5, null]]));
[afterMarker] head runs

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(3, [4, [5, null]]));
[beforeMarker] 3, [4, [5, null]] substituted into acc, init of (acc, init) => append((x => list(x, x + 1))(acc), init)

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(append((x => list(x, x + 1))(3), [4, [5, null]]));
[afterMarker] 3, [4, [5, null]] substituted into acc, init of (acc, init) => append((x => list(x, x + 1))(acc), init)

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(append((x => list(x, x + 1))(3), [4, [5, null]]));
[beforeMarker] 3 substituted into x of x => list(x, x + 1)

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(append(list(3, 3 + 1), [4, [5, null]]));
[afterMarker] 3 substituted into x of x => list(x, x + 1)

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(append(list(3, 3 + 1), [4, [5, null]]));
[beforeMarker] Binary expression 3 + 1 evaluated

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(append(list(3, 4), [4, [5, null]]));
[afterMarker] Binary expression 3 + 1 evaluated

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(append(list(3, 4), [4, [5, null]]));
[beforeMarker] list runs

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(append([3, [4, null]], [4, [5, null]]));
[afterMarker] list runs

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(append([3, [4, null]], [4, [5, null]]));
[beforeMarker] append runs

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))($append([3, [4, null]], [4, [5, null]], xs => xs));
[afterMarker] append runs

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))($append([3, [4, null]], [4, [5, null]], xs => xs));
[beforeMarker] $append runs

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([3, [4, null]], [4, [5, null]], xs => xs));
[afterMarker] $append runs

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([3, [4, null]], [4, [5, null]], xs => xs));
[beforeMarker] [3, [4, null]], [4, [5, null]], xs => xs substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(is_null([3, [4, null]]) ? (xs => xs)([4, [5, null]]) : $append(tail([3, [4, null]]), [4, [5, null]], zs => (xs => xs)(pair(head([3, [4, null]]), zs))));
[afterMarker] [3, [4, null]], [4, [5, null]], xs => xs substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(is_null([3, [4, null]]) ? (xs => xs)([4, [5, null]]) : $append(tail([3, [4, null]]), [4, [5, null]], zs => (xs => xs)(pair(head([3, [4, null]]), zs))));
[beforeMarker] is_null runs

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(false ? (xs => xs)([4, [5, null]]) : $append(tail([3, [4, null]]), [4, [5, null]], zs => (xs => xs)(pair(head([3, [4, null]]), zs))));
[afterMarker] is_null runs

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(false ? (xs => xs)([4, [5, null]]) : $append(tail([3, [4, null]]), [4, [5, null]], zs => (xs => xs)(pair(head([3, [4, null]]), zs))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))($append(tail([3, [4, null]]), [4, [5, null]], zs => (xs => xs)(pair(head([3, [4, null]]), zs))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))($append(tail([3, [4, null]]), [4, [5, null]], zs => (xs => xs)(pair(head([3, [4, null]]), zs))));
[beforeMarker] tail runs

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))($append([4, null], [4, [5, null]], zs => (xs => xs)(pair(head([3, [4, null]]), zs))));
[afterMarker] tail runs

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))($append([4, null], [4, [5, null]], zs => (xs => xs)(pair(head([3, [4, null]]), zs))));
[beforeMarker] $append runs

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([4, null], [4, [5, null]], zs => (xs => xs)(pair(head([3, [4, null]]), zs))));
[afterMarker] $append runs

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([4, null], [4, [5, null]], zs => (xs => xs)(pair(head([3, [4, null]]), zs))));
[beforeMarker] [4, null], [4, [5, null]], zs => (xs => xs)(pair(head([3, [4, null]]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(is_null([4, null]) ? (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))([4, [5, null]]) : $append(tail([4, null]), [4, [5, null]], zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs))));
[afterMarker] [4, null], [4, [5, null]], zs => (xs => xs)(pair(head([3, [4, null]]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(is_null([4, null]) ? (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))([4, [5, null]]) : $append(tail([4, null]), [4, [5, null]], zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs))));
[beforeMarker] is_null runs

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(false ? (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))([4, [5, null]]) : $append(tail([4, null]), [4, [5, null]], zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs))));
[afterMarker] is_null runs

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(false ? (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))([4, [5, null]]) : $append(tail([4, null]), [4, [5, null]], zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))($append(tail([4, null]), [4, [5, null]], zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))($append(tail([4, null]), [4, [5, null]], zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs))));
[beforeMarker] tail runs

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))($append(null, [4, [5, null]], zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs))));
[afterMarker] tail runs

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))($append(null, [4, [5, null]], zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs))));
[beforeMarker] $append runs

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))(null, [4, [5, null]], zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs))));
[afterMarker] $append runs

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))(null, [4, [5, null]], zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs))));
[beforeMarker] null, [4, [5, null]], zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(is_null(null) ? (zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs)))([4, [5, null]]) : $append(tail(null), [4, [5, null]], zs => (zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs)))(pair(head(null), zs))));
[afterMarker] null, [4, [5, null]], zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(is_null(null) ? (zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs)))([4, [5, null]]) : $append(tail(null), [4, [5, null]], zs => (zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs)))(pair(head(null), zs))));
[beforeMarker] is_null runs

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(true ? (zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs)))([4, [5, null]]) : $append(tail(null), [4, [5, null]], zs => (zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs)))(pair(head(null), zs))));
[afterMarker] is_null runs

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(true ? (zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs)))([4, [5, null]]) : $append(tail(null), [4, [5, null]], zs => (zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs)))(pair(head(null), zs))));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))((zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs)))([4, [5, null]]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))((zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs)))([4, [5, null]]));
[beforeMarker] [4, [5, null]] substituted into zs of zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs))

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))((zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), [4, [5, null]])));
[afterMarker] [4, [5, null]] substituted into zs of zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs))

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))((zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), [4, [5, null]])));
[beforeMarker] head runs

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))((zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(4, [4, [5, null]])));
[afterMarker] head runs

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))((zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(4, [4, [5, null]])));
[beforeMarker] pair runs

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))((zs => (xs => xs)(pair(head([3, [4, null]]), zs)))([4, [4, [5, null]]]));
[afterMarker] pair runs

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))((zs => (xs => xs)(pair(head([3, [4, null]]), zs)))([4, [4, [5, null]]]));
[beforeMarker] [4, [4, [5, null]]] substituted into zs of zs => (xs => xs)(pair(head([3, [4, null]]), zs))

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))((xs => xs)(pair(head([3, [4, null]]), [4, [4, [5, null]]])));
[afterMarker] [4, [4, [5, null]]] substituted into zs of zs => (xs => xs)(pair(head([3, [4, null]]), zs))

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))((xs => xs)(pair(head([3, [4, null]]), [4, [4, [5, null]]])));
[beforeMarker] head runs

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))((xs => xs)(pair(3, [4, [4, [5, null]]])));
[afterMarker] head runs

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))((xs => xs)(pair(3, [4, [4, [5, null]]])));
[beforeMarker] pair runs

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))((xs => xs)([3, [4, [4, [5, null]]]]));
[afterMarker] pair runs

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))((xs => xs)([3, [4, [4, [5, null]]]]));
[beforeMarker] [3, [4, [4, [5, null]]]] substituted into xs of xs => xs

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))([3, [4, [4, [5, null]]]]);
[afterMarker] [3, [4, [4, [5, null]]]] substituted into xs of xs => xs

(x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))([3, [4, [4, [5, null]]]]);
[beforeMarker] [3, [4, [4, [5, null]]]] substituted into x of x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x))

(x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), [3, [4, [4, [5, null]]]]));
[afterMarker] [3, [4, [4, [5, null]]]] substituted into x of x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x))

(x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), [3, [4, [4, [5, null]]]]));
[beforeMarker] head runs

(x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(2, [3, [4, [4, [5, null]]]]));
[afterMarker] head runs

(x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(2, [3, [4, [4, [5, null]]]]));
[beforeMarker] 2, [3, [4, [4, [5, null]]]] substituted into acc, init of (acc, init) => append((x => list(x, x + 1))(acc), init)

(x => x)(append((x => list(x, x + 1))(2), [3, [4, [4, [5, null]]]]));
[afterMarker] 2, [3, [4, [4, [5, null]]]] substituted into acc, init of (acc, init) => append((x => list(x, x + 1))(acc), init)

(x => x)(append((x => list(x, x + 1))(2), [3, [4, [4, [5, null]]]]));
[beforeMarker] 2 substituted into x of x => list(x, x + 1)

(x => x)(append(list(2, 2 + 1), [3, [4, [4, [5, null]]]]));
[afterMarker] 2 substituted into x of x => list(x, x + 1)

(x => x)(append(list(2, 2 + 1), [3, [4, [4, [5, null]]]]));
[beforeMarker] Binary expression 2 + 1 evaluated

(x => x)(append(list(2, 3), [3, [4, [4, [5, null]]]]));
[afterMarker] Binary expression 2 + 1 evaluated

(x => x)(append(list(2, 3), [3, [4, [4, [5, null]]]]));
[beforeMarker] list runs

(x => x)(append([2, [3, null]], [3, [4, [4, [5, null]]]]));
[afterMarker] list runs

(x => x)(append([2, [3, null]], [3, [4, [4, [5, null]]]]));
[beforeMarker] append runs

(x => x)($append([2, [3, null]], [3, [4, [4, [5, null]]]], xs => xs));
[afterMarker] append runs

(x => x)($append([2, [3, null]], [3, [4, [4, [5, null]]]], xs => xs));
[beforeMarker] $append runs

(x => x)(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([2, [3, null]], [3, [4, [4, [5, null]]]], xs => xs));
[afterMarker] $append runs

(x => x)(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([2, [3, null]], [3, [4, [4, [5, null]]]], xs => xs));
[beforeMarker] [2, [3, null]], [3, [4, [4, [5, null]]]], xs => xs substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

(x => x)(is_null([2, [3, null]]) ? (xs => xs)([3, [4, [4, [5, null]]]]) : $append(tail([2, [3, null]]), [3, [4, [4, [5, null]]]], zs => (xs => xs)(pair(head([2, [3, null]]), zs))));
[afterMarker] [2, [3, null]], [3, [4, [4, [5, null]]]], xs => xs substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

(x => x)(is_null([2, [3, null]]) ? (xs => xs)([3, [4, [4, [5, null]]]]) : $append(tail([2, [3, null]]), [3, [4, [4, [5, null]]]], zs => (xs => xs)(pair(head([2, [3, null]]), zs))));
[beforeMarker] is_null runs

(x => x)(false ? (xs => xs)([3, [4, [4, [5, null]]]]) : $append(tail([2, [3, null]]), [3, [4, [4, [5, null]]]], zs => (xs => xs)(pair(head([2, [3, null]]), zs))));
[afterMarker] is_null runs

(x => x)(false ? (xs => xs)([3, [4, [4, [5, null]]]]) : $append(tail([2, [3, null]]), [3, [4, [4, [5, null]]]], zs => (xs => xs)(pair(head([2, [3, null]]), zs))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(x => x)($append(tail([2, [3, null]]), [3, [4, [4, [5, null]]]], zs => (xs => xs)(pair(head([2, [3, null]]), zs))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(x => x)($append(tail([2, [3, null]]), [3, [4, [4, [5, null]]]], zs => (xs => xs)(pair(head([2, [3, null]]), zs))));
[beforeMarker] tail runs

(x => x)($append([3, null], [3, [4, [4, [5, null]]]], zs => (xs => xs)(pair(head([2, [3, null]]), zs))));
[afterMarker] tail runs

(x => x)($append([3, null], [3, [4, [4, [5, null]]]], zs => (xs => xs)(pair(head([2, [3, null]]), zs))));
[beforeMarker] $append runs

(x => x)(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([3, null], [3, [4, [4, [5, null]]]], zs => (xs => xs)(pair(head([2, [3, null]]), zs))));
[afterMarker] $append runs

(x => x)(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([3, null], [3, [4, [4, [5, null]]]], zs => (xs => xs)(pair(head([2, [3, null]]), zs))));
[beforeMarker] [3, null], [3, [4, [4, [5, null]]]], zs => (xs => xs)(pair(head([2, [3, null]]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

(x => x)(is_null([3, null]) ? (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))([3, [4, [4, [5, null]]]]) : $append(tail([3, null]), [3, [4, [4, [5, null]]]], zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs))));
[afterMarker] [3, null], [3, [4, [4, [5, null]]]], zs => (xs => xs)(pair(head([2, [3, null]]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

(x => x)(is_null([3, null]) ? (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))([3, [4, [4, [5, null]]]]) : $append(tail([3, null]), [3, [4, [4, [5, null]]]], zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs))));
[beforeMarker] is_null runs

(x => x)(false ? (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))([3, [4, [4, [5, null]]]]) : $append(tail([3, null]), [3, [4, [4, [5, null]]]], zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs))));
[afterMarker] is_null runs

(x => x)(false ? (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))([3, [4, [4, [5, null]]]]) : $append(tail([3, null]), [3, [4, [4, [5, null]]]], zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(x => x)($append(tail([3, null]), [3, [4, [4, [5, null]]]], zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(x => x)($append(tail([3, null]), [3, [4, [4, [5, null]]]], zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs))));
[beforeMarker] tail runs

(x => x)($append(null, [3, [4, [4, [5, null]]]], zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs))));
[afterMarker] tail runs

(x => x)($append(null, [3, [4, [4, [5, null]]]], zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs))));
[beforeMarker] $append runs

(x => x)(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))(null, [3, [4, [4, [5, null]]]], zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs))));
[afterMarker] $append runs

(x => x)(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))(null, [3, [4, [4, [5, null]]]], zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs))));
[beforeMarker] null, [3, [4, [4, [5, null]]]], zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

(x => x)(is_null(null) ? (zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs)))([3, [4, [4, [5, null]]]]) : $append(tail(null), [3, [4, [4, [5, null]]]], zs => (zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs)))(pair(head(null), zs))));
[afterMarker] null, [3, [4, [4, [5, null]]]], zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

(x => x)(is_null(null) ? (zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs)))([3, [4, [4, [5, null]]]]) : $append(tail(null), [3, [4, [4, [5, null]]]], zs => (zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs)))(pair(head(null), zs))));
[beforeMarker] is_null runs

(x => x)(true ? (zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs)))([3, [4, [4, [5, null]]]]) : $append(tail(null), [3, [4, [4, [5, null]]]], zs => (zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs)))(pair(head(null), zs))));
[afterMarker] is_null runs

(x => x)(true ? (zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs)))([3, [4, [4, [5, null]]]]) : $append(tail(null), [3, [4, [4, [5, null]]]], zs => (zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs)))(pair(head(null), zs))));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

(x => x)((zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs)))([3, [4, [4, [5, null]]]]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

(x => x)((zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs)))([3, [4, [4, [5, null]]]]));
[beforeMarker] [3, [4, [4, [5, null]]]] substituted into zs of zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs))

(x => x)((zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), [3, [4, [4, [5, null]]]])));
[afterMarker] [3, [4, [4, [5, null]]]] substituted into zs of zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs))

(x => x)((zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), [3, [4, [4, [5, null]]]])));
[beforeMarker] head runs

(x => x)((zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(3, [3, [4, [4, [5, null]]]])));
[afterMarker] head runs

(x => x)((zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(3, [3, [4, [4, [5, null]]]])));
[beforeMarker] pair runs

(x => x)((zs => (xs => xs)(pair(head([2, [3, null]]), zs)))([3, [3, [4, [4, [5, null]]]]]));
[afterMarker] pair runs

(x => x)((zs => (xs => xs)(pair(head([2, [3, null]]), zs)))([3, [3, [4, [4, [5, null]]]]]));
[beforeMarker] [3, [3, [4, [4, [5, null]]]]] substituted into zs of zs => (xs => xs)(pair(head([2, [3, null]]), zs))

(x => x)((xs => xs)(pair(head([2, [3, null]]), [3, [3, [4, [4, [5, null]]]]])));
[afterMarker] [3, [3, [4, [4, [5, null]]]]] substituted into zs of zs => (xs => xs)(pair(head([2, [3, null]]), zs))

(x => x)((xs => xs)(pair(head([2, [3, null]]), [3, [3, [4, [4, [5, null]]]]])));
[beforeMarker] head runs

(x => x)((xs => xs)(pair(2, [3, [3, [4, [4, [5, null]]]]])));
[afterMarker] head runs

(x => x)((xs => xs)(pair(2, [3, [3, [4, [4, [5, null]]]]])));
[beforeMarker] pair runs

(x => x)((xs => xs)([2, [3, [3, [4, [4, [5, null]]]]]]));
[afterMarker] pair runs

(x => x)((xs => xs)([2, [3, [3, [4, [4, [5, null]]]]]]));
[beforeMarker] [2, [3, [3, [4, [4, [5, null]]]]]] substituted into xs of xs => xs

(x => x)([2, [3, [3, [4, [4, [5, null]]]]]]);
[afterMarker] [2, [3, [3, [4, [4, [5, null]]]]]] substituted into xs of xs => xs

(x => x)([2, [3, [3, [4, [4, [5, null]]]]]]);
[beforeMarker] [2, [3, [3, [4, [4, [5, null]]]]]] substituted into x of x => x

[2, [3, [3, [4, [4, [5, null]]]]]];
[afterMarker] [2, [3, [3, [4, [4, [5, null]]]]]] substituted into x of x => x

[2, [3, [3, [4, [4, [5, null]]]]]];
[noMarker] Evaluation complete
"
`;

exports[`List operations is_null 1`] = `
"is_null(tail(list(1)));
[noMarker] Start of evaluation

is_null(tail(list(1)));
[beforeMarker] list runs

is_null(tail([1, null]));
[afterMarker] list runs

is_null(tail([1, null]));
[beforeMarker] tail runs

is_null(null);
[afterMarker] tail runs

is_null(null);
[beforeMarker] is_null runs

true;
[afterMarker] is_null runs

true;
[noMarker] Evaluation complete
"
`;

exports[`List operations map on list 1`] = `
"map(x => list(x, 1), list(1, 2, 3));
[noMarker] Start of evaluation

map(x => list(x, 1), list(1, 2, 3));
[beforeMarker] list runs

map(x => list(x, 1), [1, [2, [3, null]]]);
[afterMarker] list runs

map(x => list(x, 1), [1, [2, [3, null]]]);
[beforeMarker] map runs

$map(x => list(x, 1), [1, [2, [3, null]]], null);
[afterMarker] map runs

$map(x => list(x, 1), [1, [2, [3, null]]], null);
[beforeMarker] $map runs

((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => list(x, 1), [1, [2, [3, null]]], null);
[afterMarker] $map runs

((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => list(x, 1), [1, [2, [3, null]]], null);
[beforeMarker] x => list(x, 1), [1, [2, [3, null]]], null substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

is_null([1, [2, [3, null]]]) ? reverse(null) : $map(x => list(x, 1), tail([1, [2, [3, null]]]), pair((x => list(x, 1))(head([1, [2, [3, null]]])), null));
[afterMarker] x => list(x, 1), [1, [2, [3, null]]], null substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

is_null([1, [2, [3, null]]]) ? reverse(null) : $map(x => list(x, 1), tail([1, [2, [3, null]]]), pair((x => list(x, 1))(head([1, [2, [3, null]]])), null));
[beforeMarker] is_null runs

false ? reverse(null) : $map(x => list(x, 1), tail([1, [2, [3, null]]]), pair((x => list(x, 1))(head([1, [2, [3, null]]])), null));
[afterMarker] is_null runs

false ? reverse(null) : $map(x => list(x, 1), tail([1, [2, [3, null]]]), pair((x => list(x, 1))(head([1, [2, [3, null]]])), null));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

$map(x => list(x, 1), tail([1, [2, [3, null]]]), pair((x => list(x, 1))(head([1, [2, [3, null]]])), null));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

$map(x => list(x, 1), tail([1, [2, [3, null]]]), pair((x => list(x, 1))(head([1, [2, [3, null]]])), null));
[beforeMarker] tail runs

$map(x => list(x, 1), [2, [3, null]], pair((x => list(x, 1))(head([1, [2, [3, null]]])), null));
[afterMarker] tail runs

$map(x => list(x, 1), [2, [3, null]], pair((x => list(x, 1))(head([1, [2, [3, null]]])), null));
[beforeMarker] head runs

$map(x => list(x, 1), [2, [3, null]], pair((x => list(x, 1))(1), null));
[afterMarker] head runs

$map(x => list(x, 1), [2, [3, null]], pair((x => list(x, 1))(1), null));
[beforeMarker] 1 substituted into x of x => list(x, 1)

$map(x => list(x, 1), [2, [3, null]], pair(list(1, 1), null));
[afterMarker] 1 substituted into x of x => list(x, 1)

$map(x => list(x, 1), [2, [3, null]], pair(list(1, 1), null));
[beforeMarker] list runs

$map(x => list(x, 1), [2, [3, null]], pair([1, [1, null]], null));
[afterMarker] list runs

$map(x => list(x, 1), [2, [3, null]], pair([1, [1, null]], null));
[beforeMarker] pair runs

$map(x => list(x, 1), [2, [3, null]], [[1, [1, null]], null]);
[afterMarker] pair runs

$map(x => list(x, 1), [2, [3, null]], [[1, [1, null]], null]);
[beforeMarker] $map runs

((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => list(x, 1), [2, [3, null]], [[1, [1, null]], null]);
[afterMarker] $map runs

((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => list(x, 1), [2, [3, null]], [[1, [1, null]], null]);
[beforeMarker] x => list(x, 1), [2, [3, null]], [[1, [1, null]], null] substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

is_null([2, [3, null]]) ? reverse([[1, [1, null]], null]) : $map(x => list(x, 1), tail([2, [3, null]]), pair((x => list(x, 1))(head([2, [3, null]])), [[1, [1, null]], null]));
[afterMarker] x => list(x, 1), [2, [3, null]], [[1, [1, null]], null] substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

is_null([2, [3, null]]) ? reverse([[1, [1, null]], null]) : $map(x => list(x, 1), tail([2, [3, null]]), pair((x => list(x, 1))(head([2, [3, null]])), [[1, [1, null]], null]));
[beforeMarker] is_null runs

false ? reverse([[1, [1, null]], null]) : $map(x => list(x, 1), tail([2, [3, null]]), pair((x => list(x, 1))(head([2, [3, null]])), [[1, [1, null]], null]));
[afterMarker] is_null runs

false ? reverse([[1, [1, null]], null]) : $map(x => list(x, 1), tail([2, [3, null]]), pair((x => list(x, 1))(head([2, [3, null]])), [[1, [1, null]], null]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

$map(x => list(x, 1), tail([2, [3, null]]), pair((x => list(x, 1))(head([2, [3, null]])), [[1, [1, null]], null]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

$map(x => list(x, 1), tail([2, [3, null]]), pair((x => list(x, 1))(head([2, [3, null]])), [[1, [1, null]], null]));
[beforeMarker] tail runs

$map(x => list(x, 1), [3, null], pair((x => list(x, 1))(head([2, [3, null]])), [[1, [1, null]], null]));
[afterMarker] tail runs

$map(x => list(x, 1), [3, null], pair((x => list(x, 1))(head([2, [3, null]])), [[1, [1, null]], null]));
[beforeMarker] head runs

$map(x => list(x, 1), [3, null], pair((x => list(x, 1))(2), [[1, [1, null]], null]));
[afterMarker] head runs

$map(x => list(x, 1), [3, null], pair((x => list(x, 1))(2), [[1, [1, null]], null]));
[beforeMarker] 2 substituted into x of x => list(x, 1)

$map(x => list(x, 1), [3, null], pair(list(2, 1), [[1, [1, null]], null]));
[afterMarker] 2 substituted into x of x => list(x, 1)

$map(x => list(x, 1), [3, null], pair(list(2, 1), [[1, [1, null]], null]));
[beforeMarker] list runs

$map(x => list(x, 1), [3, null], pair([2, [1, null]], [[1, [1, null]], null]));
[afterMarker] list runs

$map(x => list(x, 1), [3, null], pair([2, [1, null]], [[1, [1, null]], null]));
[beforeMarker] pair runs

$map(x => list(x, 1), [3, null], [[2, [1, null]], [[1, [1, null]], null]]);
[afterMarker] pair runs

$map(x => list(x, 1), [3, null], [[2, [1, null]], [[1, [1, null]], null]]);
[beforeMarker] $map runs

((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => list(x, 1), [3, null], [[2, [1, null]], [[1, [1, null]], null]]);
[afterMarker] $map runs

((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => list(x, 1), [3, null], [[2, [1, null]], [[1, [1, null]], null]]);
[beforeMarker] x => list(x, 1), [3, null], [[2, [1, null]], [[1, [1, null]], null]] substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

is_null([3, null]) ? reverse([[2, [1, null]], [[1, [1, null]], null]]) : $map(x => list(x, 1), tail([3, null]), pair((x => list(x, 1))(head([3, null])), [[2, [1, null]], [[1, [1, null]], null]]));
[afterMarker] x => list(x, 1), [3, null], [[2, [1, null]], [[1, [1, null]], null]] substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

is_null([3, null]) ? reverse([[2, [1, null]], [[1, [1, null]], null]]) : $map(x => list(x, 1), tail([3, null]), pair((x => list(x, 1))(head([3, null])), [[2, [1, null]], [[1, [1, null]], null]]));
[beforeMarker] is_null runs

false ? reverse([[2, [1, null]], [[1, [1, null]], null]]) : $map(x => list(x, 1), tail([3, null]), pair((x => list(x, 1))(head([3, null])), [[2, [1, null]], [[1, [1, null]], null]]));
[afterMarker] is_null runs

false ? reverse([[2, [1, null]], [[1, [1, null]], null]]) : $map(x => list(x, 1), tail([3, null]), pair((x => list(x, 1))(head([3, null])), [[2, [1, null]], [[1, [1, null]], null]]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

$map(x => list(x, 1), tail([3, null]), pair((x => list(x, 1))(head([3, null])), [[2, [1, null]], [[1, [1, null]], null]]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

$map(x => list(x, 1), tail([3, null]), pair((x => list(x, 1))(head([3, null])), [[2, [1, null]], [[1, [1, null]], null]]));
[beforeMarker] tail runs

$map(x => list(x, 1), null, pair((x => list(x, 1))(head([3, null])), [[2, [1, null]], [[1, [1, null]], null]]));
[afterMarker] tail runs

$map(x => list(x, 1), null, pair((x => list(x, 1))(head([3, null])), [[2, [1, null]], [[1, [1, null]], null]]));
[beforeMarker] head runs

$map(x => list(x, 1), null, pair((x => list(x, 1))(3), [[2, [1, null]], [[1, [1, null]], null]]));
[afterMarker] head runs

$map(x => list(x, 1), null, pair((x => list(x, 1))(3), [[2, [1, null]], [[1, [1, null]], null]]));
[beforeMarker] 3 substituted into x of x => list(x, 1)

$map(x => list(x, 1), null, pair(list(3, 1), [[2, [1, null]], [[1, [1, null]], null]]));
[afterMarker] 3 substituted into x of x => list(x, 1)

$map(x => list(x, 1), null, pair(list(3, 1), [[2, [1, null]], [[1, [1, null]], null]]));
[beforeMarker] list runs

$map(x => list(x, 1), null, pair([3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]));
[afterMarker] list runs

$map(x => list(x, 1), null, pair([3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]));
[beforeMarker] pair runs

$map(x => list(x, 1), null, [[3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]]);
[afterMarker] pair runs

$map(x => list(x, 1), null, [[3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]]);
[beforeMarker] $map runs

((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => list(x, 1), null, [[3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]]);
[afterMarker] $map runs

((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => list(x, 1), null, [[3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]]);
[beforeMarker] x => list(x, 1), null, [[3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]] substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

is_null(null) ? reverse([[3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]]) : $map(x => list(x, 1), tail(null), pair((x => list(x, 1))(head(null)), [[3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]]));
[afterMarker] x => list(x, 1), null, [[3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]] substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

is_null(null) ? reverse([[3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]]) : $map(x => list(x, 1), tail(null), pair((x => list(x, 1))(head(null)), [[3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]]));
[beforeMarker] is_null runs

true ? reverse([[3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]]) : $map(x => list(x, 1), tail(null), pair((x => list(x, 1))(head(null)), [[3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]]));
[afterMarker] is_null runs

true ? reverse([[3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]]) : $map(x => list(x, 1), tail(null), pair((x => list(x, 1))(head(null)), [[3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]]));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

reverse([[3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]]);
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

reverse([[3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]]);
[beforeMarker] reverse runs

$reverse([[3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]], null);
[afterMarker] reverse runs

$reverse([[3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]], null);
[beforeMarker] $reverse runs

((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([[3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]], null);
[afterMarker] $reverse runs

((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([[3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]], null);
[beforeMarker] [[3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]], null substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

is_null([[3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]]) ? null : $reverse(tail([[3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]]), pair(head([[3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]]), null));
[afterMarker] [[3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]], null substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

is_null([[3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]]) ? null : $reverse(tail([[3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]]), pair(head([[3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]]), null));
[beforeMarker] is_null runs

false ? null : $reverse(tail([[3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]]), pair(head([[3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]]), null));
[afterMarker] is_null runs

false ? null : $reverse(tail([[3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]]), pair(head([[3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]]), null));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

$reverse(tail([[3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]]), pair(head([[3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]]), null));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

$reverse(tail([[3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]]), pair(head([[3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]]), null));
[beforeMarker] tail runs

$reverse([[2, [1, null]], [[1, [1, null]], null]], pair(head([[3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]]), null));
[afterMarker] tail runs

$reverse([[2, [1, null]], [[1, [1, null]], null]], pair(head([[3, [1, null]], [[2, [1, null]], [[1, [1, null]], null]]]), null));
[beforeMarker] head runs

$reverse([[2, [1, null]], [[1, [1, null]], null]], pair([3, [1, null]], null));
[afterMarker] head runs

$reverse([[2, [1, null]], [[1, [1, null]], null]], pair([3, [1, null]], null));
[beforeMarker] pair runs

$reverse([[2, [1, null]], [[1, [1, null]], null]], [[3, [1, null]], null]);
[afterMarker] pair runs

$reverse([[2, [1, null]], [[1, [1, null]], null]], [[3, [1, null]], null]);
[beforeMarker] $reverse runs

((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([[2, [1, null]], [[1, [1, null]], null]], [[3, [1, null]], null]);
[afterMarker] $reverse runs

((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([[2, [1, null]], [[1, [1, null]], null]], [[3, [1, null]], null]);
[beforeMarker] [[2, [1, null]], [[1, [1, null]], null]], [[3, [1, null]], null] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

is_null([[2, [1, null]], [[1, [1, null]], null]]) ? [[3, [1, null]], null] : $reverse(tail([[2, [1, null]], [[1, [1, null]], null]]), pair(head([[2, [1, null]], [[1, [1, null]], null]]), [[3, [1, null]], null]));
[afterMarker] [[2, [1, null]], [[1, [1, null]], null]], [[3, [1, null]], null] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

is_null([[2, [1, null]], [[1, [1, null]], null]]) ? [[3, [1, null]], null] : $reverse(tail([[2, [1, null]], [[1, [1, null]], null]]), pair(head([[2, [1, null]], [[1, [1, null]], null]]), [[3, [1, null]], null]));
[beforeMarker] is_null runs

false ? [[3, [1, null]], null] : $reverse(tail([[2, [1, null]], [[1, [1, null]], null]]), pair(head([[2, [1, null]], [[1, [1, null]], null]]), [[3, [1, null]], null]));
[afterMarker] is_null runs

false ? [[3, [1, null]], null] : $reverse(tail([[2, [1, null]], [[1, [1, null]], null]]), pair(head([[2, [1, null]], [[1, [1, null]], null]]), [[3, [1, null]], null]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

$reverse(tail([[2, [1, null]], [[1, [1, null]], null]]), pair(head([[2, [1, null]], [[1, [1, null]], null]]), [[3, [1, null]], null]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

$reverse(tail([[2, [1, null]], [[1, [1, null]], null]]), pair(head([[2, [1, null]], [[1, [1, null]], null]]), [[3, [1, null]], null]));
[beforeMarker] tail runs

$reverse([[1, [1, null]], null], pair(head([[2, [1, null]], [[1, [1, null]], null]]), [[3, [1, null]], null]));
[afterMarker] tail runs

$reverse([[1, [1, null]], null], pair(head([[2, [1, null]], [[1, [1, null]], null]]), [[3, [1, null]], null]));
[beforeMarker] head runs

$reverse([[1, [1, null]], null], pair([2, [1, null]], [[3, [1, null]], null]));
[afterMarker] head runs

$reverse([[1, [1, null]], null], pair([2, [1, null]], [[3, [1, null]], null]));
[beforeMarker] pair runs

$reverse([[1, [1, null]], null], [[2, [1, null]], [[3, [1, null]], null]]);
[afterMarker] pair runs

$reverse([[1, [1, null]], null], [[2, [1, null]], [[3, [1, null]], null]]);
[beforeMarker] $reverse runs

((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([[1, [1, null]], null], [[2, [1, null]], [[3, [1, null]], null]]);
[afterMarker] $reverse runs

((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([[1, [1, null]], null], [[2, [1, null]], [[3, [1, null]], null]]);
[beforeMarker] [[1, [1, null]], null], [[2, [1, null]], [[3, [1, null]], null]] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

is_null([[1, [1, null]], null]) ? [[2, [1, null]], [[3, [1, null]], null]] : $reverse(tail([[1, [1, null]], null]), pair(head([[1, [1, null]], null]), [[2, [1, null]], [[3, [1, null]], null]]));
[afterMarker] [[1, [1, null]], null], [[2, [1, null]], [[3, [1, null]], null]] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

is_null([[1, [1, null]], null]) ? [[2, [1, null]], [[3, [1, null]], null]] : $reverse(tail([[1, [1, null]], null]), pair(head([[1, [1, null]], null]), [[2, [1, null]], [[3, [1, null]], null]]));
[beforeMarker] is_null runs

false ? [[2, [1, null]], [[3, [1, null]], null]] : $reverse(tail([[1, [1, null]], null]), pair(head([[1, [1, null]], null]), [[2, [1, null]], [[3, [1, null]], null]]));
[afterMarker] is_null runs

false ? [[2, [1, null]], [[3, [1, null]], null]] : $reverse(tail([[1, [1, null]], null]), pair(head([[1, [1, null]], null]), [[2, [1, null]], [[3, [1, null]], null]]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

$reverse(tail([[1, [1, null]], null]), pair(head([[1, [1, null]], null]), [[2, [1, null]], [[3, [1, null]], null]]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

$reverse(tail([[1, [1, null]], null]), pair(head([[1, [1, null]], null]), [[2, [1, null]], [[3, [1, null]], null]]));
[beforeMarker] tail runs

$reverse(null, pair(head([[1, [1, null]], null]), [[2, [1, null]], [[3, [1, null]], null]]));
[afterMarker] tail runs

$reverse(null, pair(head([[1, [1, null]], null]), [[2, [1, null]], [[3, [1, null]], null]]));
[beforeMarker] head runs

$reverse(null, pair([1, [1, null]], [[2, [1, null]], [[3, [1, null]], null]]));
[afterMarker] head runs

$reverse(null, pair([1, [1, null]], [[2, [1, null]], [[3, [1, null]], null]]));
[beforeMarker] pair runs

$reverse(null, [[1, [1, null]], [[2, [1, null]], [[3, [1, null]], null]]]);
[afterMarker] pair runs

$reverse(null, [[1, [1, null]], [[2, [1, null]], [[3, [1, null]], null]]]);
[beforeMarker] $reverse runs

((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))(null, [[1, [1, null]], [[2, [1, null]], [[3, [1, null]], null]]]);
[afterMarker] $reverse runs

((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))(null, [[1, [1, null]], [[2, [1, null]], [[3, [1, null]], null]]]);
[beforeMarker] null, [[1, [1, null]], [[2, [1, null]], [[3, [1, null]], null]]] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

is_null(null) ? [[1, [1, null]], [[2, [1, null]], [[3, [1, null]], null]]] : $reverse(tail(null), pair(head(null), [[1, [1, null]], [[2, [1, null]], [[3, [1, null]], null]]]));
[afterMarker] null, [[1, [1, null]], [[2, [1, null]], [[3, [1, null]], null]]] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

is_null(null) ? [[1, [1, null]], [[2, [1, null]], [[3, [1, null]], null]]] : $reverse(tail(null), pair(head(null), [[1, [1, null]], [[2, [1, null]], [[3, [1, null]], null]]]));
[beforeMarker] is_null runs

true ? [[1, [1, null]], [[2, [1, null]], [[3, [1, null]], null]]] : $reverse(tail(null), pair(head(null), [[1, [1, null]], [[2, [1, null]], [[3, [1, null]], null]]]));
[afterMarker] is_null runs

true ? [[1, [1, null]], [[2, [1, null]], [[3, [1, null]], null]]] : $reverse(tail(null), pair(head(null), [[1, [1, null]], [[2, [1, null]], [[3, [1, null]], null]]]));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

[[1, [1, null]], [[2, [1, null]], [[3, [1, null]], null]]];
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

[[1, [1, null]], [[2, [1, null]], [[3, [1, null]], null]]];
[noMarker] Evaluation complete
"
`;

exports[`List operations subsets 1`] = `
"function subsets(s) { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); }}subsets(list(1, 2, 3));
[noMarker] Start of evaluation

function subsets(s) { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); }}subsets(list(1, 2, 3));
[beforeMarker] Function subsets declared, parameter(s) s required

(s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); }})(list(1, 2, 3));
[afterMarker] Function subsets declared, parameter(s) s required

(s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); }})(list(1, 2, 3));
[beforeMarker] list runs

(s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); }})([1, [2, [3, null]]]);
[afterMarker] list runs

(s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); }})([1, [2, [3, null]]]);
[beforeMarker] Function subsets, defined as s => {...}, takes in s as input [1, [2, [3, null]]]

{ if (is_null([1, [2, [3, null]]])) { return list(null); } else { const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(tail([1, [2, [3, null]]])); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] Function subsets, defined as s => {...}, takes in s as input [1, [2, [3, null]]]

{ if (is_null([1, [2, [3, null]]])) { return list(null); } else { const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(tail([1, [2, [3, null]]])); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] is_null runs

{ if (false) { return list(null); } else { const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(tail([1, [2, [3, null]]])); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] is_null runs

{ if (false) { return list(null); } else { const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(tail([1, [2, [3, null]]])); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] ...

{ { undefined; const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(tail([1, [2, [3, null]]])); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] ...

{ { undefined; const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(tail([1, [2, [3, null]]])); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] tail runs

{ { undefined; const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })([2, [3, null]]); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] tail runs

{ { undefined; const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })([2, [3, null]]); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] Function subsets, defined as s => {...}, takes in s as input [2, [3, null]]

{ { undefined; const rest = { if (is_null([2, [3, null]])) { return list(null); } else { const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(tail([2, [3, null]])); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] Function subsets, defined as s => {...}, takes in s as input [2, [3, null]]

{ { undefined; const rest = { if (is_null([2, [3, null]])) { return list(null); } else { const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(tail([2, [3, null]])); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] is_null runs

{ { undefined; const rest = { if (false) { return list(null); } else { const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(tail([2, [3, null]])); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] is_null runs

{ { undefined; const rest = { if (false) { return list(null); } else { const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(tail([2, [3, null]])); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] ...

{ { undefined; const rest = { { undefined; const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(tail([2, [3, null]])); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] ...

{ { undefined; const rest = { { undefined; const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(tail([2, [3, null]])); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] tail runs

{ { undefined; const rest = { { undefined; const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })([3, null]); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] tail runs

{ { undefined; const rest = { { undefined; const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })([3, null]); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] Function subsets, defined as s => {...}, takes in s as input [3, null]

{ { undefined; const rest = { { undefined; const rest = { if (is_null([3, null])) { return list(null); } else { const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(tail([3, null])); return append(rest, map(x => pair(head([3, null]), x), rest)); } }; return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] Function subsets, defined as s => {...}, takes in s as input [3, null]

{ { undefined; const rest = { { undefined; const rest = { if (is_null([3, null])) { return list(null); } else { const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(tail([3, null])); return append(rest, map(x => pair(head([3, null]), x), rest)); } }; return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] is_null runs

{ { undefined; const rest = { { undefined; const rest = { if (false) { return list(null); } else { const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(tail([3, null])); return append(rest, map(x => pair(head([3, null]), x), rest)); } }; return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] is_null runs

{ { undefined; const rest = { { undefined; const rest = { if (false) { return list(null); } else { const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(tail([3, null])); return append(rest, map(x => pair(head([3, null]), x), rest)); } }; return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] ...

{ { undefined; const rest = { { undefined; const rest = { { undefined; const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(tail([3, null])); return append(rest, map(x => pair(head([3, null]), x), rest)); } }; return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] ...

{ { undefined; const rest = { { undefined; const rest = { { undefined; const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(tail([3, null])); return append(rest, map(x => pair(head([3, null]), x), rest)); } }; return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] tail runs

{ { undefined; const rest = { { undefined; const rest = { { undefined; const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(null); return append(rest, map(x => pair(head([3, null]), x), rest)); } }; return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] tail runs

{ { undefined; const rest = { { undefined; const rest = { { undefined; const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(null); return append(rest, map(x => pair(head([3, null]), x), rest)); } }; return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] Function subsets, defined as s => {...}, takes in s as input null

{ { undefined; const rest = { { undefined; const rest = { { undefined; const rest = { if (is_null(null)) { return list(null); } else { const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(tail(null)); return append(rest, map(x => pair(head(null), x), rest)); } }; return append(rest, map(x => pair(head([3, null]), x), rest)); } }; return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] Function subsets, defined as s => {...}, takes in s as input null

{ { undefined; const rest = { { undefined; const rest = { { undefined; const rest = { if (is_null(null)) { return list(null); } else { const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(tail(null)); return append(rest, map(x => pair(head(null), x), rest)); } }; return append(rest, map(x => pair(head([3, null]), x), rest)); } }; return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] is_null runs

{ { undefined; const rest = { { undefined; const rest = { { undefined; const rest = { if (true) { return list(null); } else { const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(tail(null)); return append(rest, map(x => pair(head(null), x), rest)); } }; return append(rest, map(x => pair(head([3, null]), x), rest)); } }; return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] is_null runs

{ { undefined; const rest = { { undefined; const rest = { { undefined; const rest = { if (true) { return list(null); } else { const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(tail(null)); return append(rest, map(x => pair(head(null), x), rest)); } }; return append(rest, map(x => pair(head([3, null]), x), rest)); } }; return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] ...

{ { undefined; const rest = { { undefined; const rest = { { undefined; const rest = { { undefined; return list(null); } }; return append(rest, map(x => pair(head([3, null]), x), rest)); } }; return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] ...

{ { undefined; const rest = { { undefined; const rest = { { undefined; const rest = { { undefined; return list(null); } }; return append(rest, map(x => pair(head([3, null]), x), rest)); } }; return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] undefined finished evaluating

{ { undefined; const rest = { { undefined; const rest = { { undefined; const rest = { { return list(null); } }; return append(rest, map(x => pair(head([3, null]), x), rest)); } }; return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] undefined finished evaluating

{ { undefined; const rest = { { undefined; const rest = { { undefined; const rest = { { return list(null); } }; return append(rest, map(x => pair(head([3, null]), x), rest)); } }; return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] return list(null); finished evaluating

{ { undefined; const rest = { { undefined; const rest = { { undefined; const rest = { return list(null); }; return append(rest, map(x => pair(head([3, null]), x), rest)); } }; return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] return list(null); finished evaluating

{ { undefined; const rest = { { undefined; const rest = { { undefined; const rest = { return list(null); }; return append(rest, map(x => pair(head([3, null]), x), rest)); } }; return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] list(null) returned

{ { undefined; const rest = { { undefined; const rest = { { undefined; const rest = list(null); return append(rest, map(x => pair(head([3, null]), x), rest)); } }; return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] list(null) returned

{ { undefined; const rest = { { undefined; const rest = { { undefined; const rest = list(null); return append(rest, map(x => pair(head([3, null]), x), rest)); } }; return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] list runs

{ { undefined; const rest = { { undefined; const rest = { { undefined; const rest = [null, null]; return append(rest, map(x => pair(head([3, null]), x), rest)); } }; return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] list runs

{ { undefined; const rest = { { undefined; const rest = { { undefined; const rest = [null, null]; return append(rest, map(x => pair(head([3, null]), x), rest)); } }; return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] Constant rest declared and substituted into the rest of block

{ { undefined; const rest = { { undefined; const rest = { { undefined; return append([null, null], map(x => pair(head([3, null]), x), [null, null])); } }; return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] Constant rest declared and substituted into the rest of block

{ { undefined; const rest = { { undefined; const rest = { { undefined; return append([null, null], map(x => pair(head([3, null]), x), [null, null])); } }; return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] undefined finished evaluating

{ { undefined; const rest = { { undefined; const rest = { { return append([null, null], map(x => pair(head([3, null]), x), [null, null])); } }; return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] undefined finished evaluating

{ { undefined; const rest = { { undefined; const rest = { { return append([null, null], map(x => pair(head([3, null]), x), [null, null])); } }; return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] return append([null, null], map(x => pair(head([3, null]), x), [null, null])); finished evaluating

{ { undefined; const rest = { { undefined; const rest = { return append([null, null], map(x => pair(head([3, null]), x), [null, null])); }; return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] return append([null, null], map(x => pair(head([3, null]), x), [null, null])); finished evaluating

{ { undefined; const rest = { { undefined; const rest = { return append([null, null], map(x => pair(head([3, null]), x), [null, null])); }; return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] append([null, null], map(x => pair(head([3, null]), x), [null, null])) returned

{ { undefined; const rest = { { undefined; const rest = append([null, null], map(x => pair(head([3, null]), x), [null, null])); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] append([null, null], map(x => pair(head([3, null]), x), [null, null])) returned

{ { undefined; const rest = { { undefined; const rest = append([null, null], map(x => pair(head([3, null]), x), [null, null])); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] map runs

{ { undefined; const rest = { { undefined; const rest = append([null, null], $map(x => pair(head([3, null]), x), [null, null], null)); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] map runs

{ { undefined; const rest = { { undefined; const rest = append([null, null], $map(x => pair(head([3, null]), x), [null, null], null)); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] $map runs

{ { undefined; const rest = { { undefined; const rest = append([null, null], ((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => pair(head([3, null]), x), [null, null], null)); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] $map runs

{ { undefined; const rest = { { undefined; const rest = append([null, null], ((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => pair(head([3, null]), x), [null, null], null)); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] x => pair(head([3, null]), x), [null, null], null substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

{ { undefined; const rest = { { undefined; const rest = append([null, null], is_null([null, null]) ? reverse(null) : $map(x => pair(head([3, null]), x), tail([null, null]), pair((x => pair(head([3, null]), x))(head([null, null])), null))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] x => pair(head([3, null]), x), [null, null], null substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

{ { undefined; const rest = { { undefined; const rest = append([null, null], is_null([null, null]) ? reverse(null) : $map(x => pair(head([3, null]), x), tail([null, null]), pair((x => pair(head([3, null]), x))(head([null, null])), null))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] is_null runs

{ { undefined; const rest = { { undefined; const rest = append([null, null], false ? reverse(null) : $map(x => pair(head([3, null]), x), tail([null, null]), pair((x => pair(head([3, null]), x))(head([null, null])), null))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] is_null runs

{ { undefined; const rest = { { undefined; const rest = append([null, null], false ? reverse(null) : $map(x => pair(head([3, null]), x), tail([null, null]), pair((x => pair(head([3, null]), x))(head([null, null])), null))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

{ { undefined; const rest = { { undefined; const rest = append([null, null], $map(x => pair(head([3, null]), x), tail([null, null]), pair((x => pair(head([3, null]), x))(head([null, null])), null))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

{ { undefined; const rest = { { undefined; const rest = append([null, null], $map(x => pair(head([3, null]), x), tail([null, null]), pair((x => pair(head([3, null]), x))(head([null, null])), null))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] tail runs

{ { undefined; const rest = { { undefined; const rest = append([null, null], $map(x => pair(head([3, null]), x), null, pair((x => pair(head([3, null]), x))(head([null, null])), null))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] tail runs

{ { undefined; const rest = { { undefined; const rest = append([null, null], $map(x => pair(head([3, null]), x), null, pair((x => pair(head([3, null]), x))(head([null, null])), null))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] head runs

{ { undefined; const rest = { { undefined; const rest = append([null, null], $map(x => pair(head([3, null]), x), null, pair((x => pair(head([3, null]), x))(null), null))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] head runs

{ { undefined; const rest = { { undefined; const rest = append([null, null], $map(x => pair(head([3, null]), x), null, pair((x => pair(head([3, null]), x))(null), null))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] null substituted into x of x => pair(head([3, null]), x)

{ { undefined; const rest = { { undefined; const rest = append([null, null], $map(x => pair(head([3, null]), x), null, pair(pair(head([3, null]), null), null))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] null substituted into x of x => pair(head([3, null]), x)

{ { undefined; const rest = { { undefined; const rest = append([null, null], $map(x => pair(head([3, null]), x), null, pair(pair(head([3, null]), null), null))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] head runs

{ { undefined; const rest = { { undefined; const rest = append([null, null], $map(x => pair(head([3, null]), x), null, pair(pair(3, null), null))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] head runs

{ { undefined; const rest = { { undefined; const rest = append([null, null], $map(x => pair(head([3, null]), x), null, pair(pair(3, null), null))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] pair runs

{ { undefined; const rest = { { undefined; const rest = append([null, null], $map(x => pair(head([3, null]), x), null, pair([3, null], null))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] pair runs

{ { undefined; const rest = { { undefined; const rest = append([null, null], $map(x => pair(head([3, null]), x), null, pair([3, null], null))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] pair runs

{ { undefined; const rest = { { undefined; const rest = append([null, null], $map(x => pair(head([3, null]), x), null, [[3, null], null])); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] pair runs

{ { undefined; const rest = { { undefined; const rest = append([null, null], $map(x => pair(head([3, null]), x), null, [[3, null], null])); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] $map runs

{ { undefined; const rest = { { undefined; const rest = append([null, null], ((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => pair(head([3, null]), x), null, [[3, null], null])); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] $map runs

{ { undefined; const rest = { { undefined; const rest = append([null, null], ((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => pair(head([3, null]), x), null, [[3, null], null])); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] x => pair(head([3, null]), x), null, [[3, null], null] substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

{ { undefined; const rest = { { undefined; const rest = append([null, null], is_null(null) ? reverse([[3, null], null]) : $map(x => pair(head([3, null]), x), tail(null), pair((x => pair(head([3, null]), x))(head(null)), [[3, null], null]))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] x => pair(head([3, null]), x), null, [[3, null], null] substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

{ { undefined; const rest = { { undefined; const rest = append([null, null], is_null(null) ? reverse([[3, null], null]) : $map(x => pair(head([3, null]), x), tail(null), pair((x => pair(head([3, null]), x))(head(null)), [[3, null], null]))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] is_null runs

{ { undefined; const rest = { { undefined; const rest = append([null, null], true ? reverse([[3, null], null]) : $map(x => pair(head([3, null]), x), tail(null), pair((x => pair(head([3, null]), x))(head(null)), [[3, null], null]))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] is_null runs

{ { undefined; const rest = { { undefined; const rest = append([null, null], true ? reverse([[3, null], null]) : $map(x => pair(head([3, null]), x), tail(null), pair((x => pair(head([3, null]), x))(head(null)), [[3, null], null]))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

{ { undefined; const rest = { { undefined; const rest = append([null, null], reverse([[3, null], null])); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

{ { undefined; const rest = { { undefined; const rest = append([null, null], reverse([[3, null], null])); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] reverse runs

{ { undefined; const rest = { { undefined; const rest = append([null, null], $reverse([[3, null], null], null)); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] reverse runs

{ { undefined; const rest = { { undefined; const rest = append([null, null], $reverse([[3, null], null], null)); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] $reverse runs

{ { undefined; const rest = { { undefined; const rest = append([null, null], ((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([[3, null], null], null)); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] $reverse runs

{ { undefined; const rest = { { undefined; const rest = append([null, null], ((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([[3, null], null], null)); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] [[3, null], null], null substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

{ { undefined; const rest = { { undefined; const rest = append([null, null], is_null([[3, null], null]) ? null : $reverse(tail([[3, null], null]), pair(head([[3, null], null]), null))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] [[3, null], null], null substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

{ { undefined; const rest = { { undefined; const rest = append([null, null], is_null([[3, null], null]) ? null : $reverse(tail([[3, null], null]), pair(head([[3, null], null]), null))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] is_null runs

{ { undefined; const rest = { { undefined; const rest = append([null, null], false ? null : $reverse(tail([[3, null], null]), pair(head([[3, null], null]), null))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] is_null runs

{ { undefined; const rest = { { undefined; const rest = append([null, null], false ? null : $reverse(tail([[3, null], null]), pair(head([[3, null], null]), null))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

{ { undefined; const rest = { { undefined; const rest = append([null, null], $reverse(tail([[3, null], null]), pair(head([[3, null], null]), null))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

{ { undefined; const rest = { { undefined; const rest = append([null, null], $reverse(tail([[3, null], null]), pair(head([[3, null], null]), null))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] tail runs

{ { undefined; const rest = { { undefined; const rest = append([null, null], $reverse(null, pair(head([[3, null], null]), null))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] tail runs

{ { undefined; const rest = { { undefined; const rest = append([null, null], $reverse(null, pair(head([[3, null], null]), null))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] head runs

{ { undefined; const rest = { { undefined; const rest = append([null, null], $reverse(null, pair([3, null], null))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] head runs

{ { undefined; const rest = { { undefined; const rest = append([null, null], $reverse(null, pair([3, null], null))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] pair runs

{ { undefined; const rest = { { undefined; const rest = append([null, null], $reverse(null, [[3, null], null])); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] pair runs

{ { undefined; const rest = { { undefined; const rest = append([null, null], $reverse(null, [[3, null], null])); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] $reverse runs

{ { undefined; const rest = { { undefined; const rest = append([null, null], ((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))(null, [[3, null], null])); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] $reverse runs

{ { undefined; const rest = { { undefined; const rest = append([null, null], ((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))(null, [[3, null], null])); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] null, [[3, null], null] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

{ { undefined; const rest = { { undefined; const rest = append([null, null], is_null(null) ? [[3, null], null] : $reverse(tail(null), pair(head(null), [[3, null], null]))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] null, [[3, null], null] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

{ { undefined; const rest = { { undefined; const rest = append([null, null], is_null(null) ? [[3, null], null] : $reverse(tail(null), pair(head(null), [[3, null], null]))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] is_null runs

{ { undefined; const rest = { { undefined; const rest = append([null, null], true ? [[3, null], null] : $reverse(tail(null), pair(head(null), [[3, null], null]))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] is_null runs

{ { undefined; const rest = { { undefined; const rest = append([null, null], true ? [[3, null], null] : $reverse(tail(null), pair(head(null), [[3, null], null]))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

{ { undefined; const rest = { { undefined; const rest = append([null, null], [[3, null], null]); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

{ { undefined; const rest = { { undefined; const rest = append([null, null], [[3, null], null]); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] append runs

{ { undefined; const rest = { { undefined; const rest = $append([null, null], [[3, null], null], xs => xs); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] append runs

{ { undefined; const rest = { { undefined; const rest = $append([null, null], [[3, null], null], xs => xs); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] $append runs

{ { undefined; const rest = { { undefined; const rest = ((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([null, null], [[3, null], null], xs => xs); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] $append runs

{ { undefined; const rest = { { undefined; const rest = ((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([null, null], [[3, null], null], xs => xs); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] [null, null], [[3, null], null], xs => xs substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

{ { undefined; const rest = { { undefined; const rest = is_null([null, null]) ? (xs => xs)([[3, null], null]) : $append(tail([null, null]), [[3, null], null], zs => (xs => xs)(pair(head([null, null]), zs))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] [null, null], [[3, null], null], xs => xs substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

{ { undefined; const rest = { { undefined; const rest = is_null([null, null]) ? (xs => xs)([[3, null], null]) : $append(tail([null, null]), [[3, null], null], zs => (xs => xs)(pair(head([null, null]), zs))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] is_null runs

{ { undefined; const rest = { { undefined; const rest = false ? (xs => xs)([[3, null], null]) : $append(tail([null, null]), [[3, null], null], zs => (xs => xs)(pair(head([null, null]), zs))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] is_null runs

{ { undefined; const rest = { { undefined; const rest = false ? (xs => xs)([[3, null], null]) : $append(tail([null, null]), [[3, null], null], zs => (xs => xs)(pair(head([null, null]), zs))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

{ { undefined; const rest = { { undefined; const rest = $append(tail([null, null]), [[3, null], null], zs => (xs => xs)(pair(head([null, null]), zs))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

{ { undefined; const rest = { { undefined; const rest = $append(tail([null, null]), [[3, null], null], zs => (xs => xs)(pair(head([null, null]), zs))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] tail runs

{ { undefined; const rest = { { undefined; const rest = $append(null, [[3, null], null], zs => (xs => xs)(pair(head([null, null]), zs))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] tail runs

{ { undefined; const rest = { { undefined; const rest = $append(null, [[3, null], null], zs => (xs => xs)(pair(head([null, null]), zs))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] $append runs

{ { undefined; const rest = { { undefined; const rest = ((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))(null, [[3, null], null], zs => (xs => xs)(pair(head([null, null]), zs))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] $append runs

{ { undefined; const rest = { { undefined; const rest = ((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))(null, [[3, null], null], zs => (xs => xs)(pair(head([null, null]), zs))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] null, [[3, null], null], zs => (xs => xs)(pair(head([null, null]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

{ { undefined; const rest = { { undefined; const rest = is_null(null) ? (zs => (xs => xs)(pair(head([null, null]), zs)))([[3, null], null]) : $append(tail(null), [[3, null], null], zs => (zs => (xs => xs)(pair(head([null, null]), zs)))(pair(head(null), zs))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] null, [[3, null], null], zs => (xs => xs)(pair(head([null, null]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

{ { undefined; const rest = { { undefined; const rest = is_null(null) ? (zs => (xs => xs)(pair(head([null, null]), zs)))([[3, null], null]) : $append(tail(null), [[3, null], null], zs => (zs => (xs => xs)(pair(head([null, null]), zs)))(pair(head(null), zs))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] is_null runs

{ { undefined; const rest = { { undefined; const rest = true ? (zs => (xs => xs)(pair(head([null, null]), zs)))([[3, null], null]) : $append(tail(null), [[3, null], null], zs => (zs => (xs => xs)(pair(head([null, null]), zs)))(pair(head(null), zs))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] is_null runs

{ { undefined; const rest = { { undefined; const rest = true ? (zs => (xs => xs)(pair(head([null, null]), zs)))([[3, null], null]) : $append(tail(null), [[3, null], null], zs => (zs => (xs => xs)(pair(head([null, null]), zs)))(pair(head(null), zs))); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

{ { undefined; const rest = { { undefined; const rest = (zs => (xs => xs)(pair(head([null, null]), zs)))([[3, null], null]); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

{ { undefined; const rest = { { undefined; const rest = (zs => (xs => xs)(pair(head([null, null]), zs)))([[3, null], null]); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] [[3, null], null] substituted into zs of zs => (xs => xs)(pair(head([null, null]), zs))

{ { undefined; const rest = { { undefined; const rest = (xs => xs)(pair(head([null, null]), [[3, null], null])); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] [[3, null], null] substituted into zs of zs => (xs => xs)(pair(head([null, null]), zs))

{ { undefined; const rest = { { undefined; const rest = (xs => xs)(pair(head([null, null]), [[3, null], null])); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] head runs

{ { undefined; const rest = { { undefined; const rest = (xs => xs)(pair(null, [[3, null], null])); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] head runs

{ { undefined; const rest = { { undefined; const rest = (xs => xs)(pair(null, [[3, null], null])); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] pair runs

{ { undefined; const rest = { { undefined; const rest = (xs => xs)([null, [[3, null], null]]); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] pair runs

{ { undefined; const rest = { { undefined; const rest = (xs => xs)([null, [[3, null], null]]); return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] [null, [[3, null], null]] substituted into xs of xs => xs

{ { undefined; const rest = { { undefined; const rest = [null, [[3, null], null]]; return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] [null, [[3, null], null]] substituted into xs of xs => xs

{ { undefined; const rest = { { undefined; const rest = [null, [[3, null], null]]; return append(rest, map(x => pair(head([2, [3, null]]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] Constant rest declared and substituted into the rest of block

{ { undefined; const rest = { { undefined; return append([null, [[3, null], null]], map(x => pair(head([2, [3, null]]), x), [null, [[3, null], null]])); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] Constant rest declared and substituted into the rest of block

{ { undefined; const rest = { { undefined; return append([null, [[3, null], null]], map(x => pair(head([2, [3, null]]), x), [null, [[3, null], null]])); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] undefined finished evaluating

{ { undefined; const rest = { { return append([null, [[3, null], null]], map(x => pair(head([2, [3, null]]), x), [null, [[3, null], null]])); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] undefined finished evaluating

{ { undefined; const rest = { { return append([null, [[3, null], null]], map(x => pair(head([2, [3, null]]), x), [null, [[3, null], null]])); } }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] return append([null, [[3, null], null]], map(x => pair(head([2, [3, null]]), x), [null, [[3, null], null]])); finished evaluating

{ { undefined; const rest = { return append([null, [[3, null], null]], map(x => pair(head([2, [3, null]]), x), [null, [[3, null], null]])); }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] return append([null, [[3, null], null]], map(x => pair(head([2, [3, null]]), x), [null, [[3, null], null]])); finished evaluating

{ { undefined; const rest = { return append([null, [[3, null], null]], map(x => pair(head([2, [3, null]]), x), [null, [[3, null], null]])); }; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] append([null, [[3, null], null]], map(x => pair(head([2, [3, null]]), x), [null, [[3, null], null]])) returned

{ { undefined; const rest = append([null, [[3, null], null]], map(x => pair(head([2, [3, null]]), x), [null, [[3, null], null]])); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] append([null, [[3, null], null]], map(x => pair(head([2, [3, null]]), x), [null, [[3, null], null]])) returned

{ { undefined; const rest = append([null, [[3, null], null]], map(x => pair(head([2, [3, null]]), x), [null, [[3, null], null]])); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] map runs

{ { undefined; const rest = append([null, [[3, null], null]], $map(x => pair(head([2, [3, null]]), x), [null, [[3, null], null]], null)); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] map runs

{ { undefined; const rest = append([null, [[3, null], null]], $map(x => pair(head([2, [3, null]]), x), [null, [[3, null], null]], null)); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] $map runs

{ { undefined; const rest = append([null, [[3, null], null]], ((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => pair(head([2, [3, null]]), x), [null, [[3, null], null]], null)); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] $map runs

{ { undefined; const rest = append([null, [[3, null], null]], ((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => pair(head([2, [3, null]]), x), [null, [[3, null], null]], null)); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] x => pair(head([2, [3, null]]), x), [null, [[3, null], null]], null substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

{ { undefined; const rest = append([null, [[3, null], null]], is_null([null, [[3, null], null]]) ? reverse(null) : $map(x => pair(head([2, [3, null]]), x), tail([null, [[3, null], null]]), pair((x => pair(head([2, [3, null]]), x))(head([null, [[3, null], null]])), null))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] x => pair(head([2, [3, null]]), x), [null, [[3, null], null]], null substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

{ { undefined; const rest = append([null, [[3, null], null]], is_null([null, [[3, null], null]]) ? reverse(null) : $map(x => pair(head([2, [3, null]]), x), tail([null, [[3, null], null]]), pair((x => pair(head([2, [3, null]]), x))(head([null, [[3, null], null]])), null))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] is_null runs

{ { undefined; const rest = append([null, [[3, null], null]], false ? reverse(null) : $map(x => pair(head([2, [3, null]]), x), tail([null, [[3, null], null]]), pair((x => pair(head([2, [3, null]]), x))(head([null, [[3, null], null]])), null))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] is_null runs

{ { undefined; const rest = append([null, [[3, null], null]], false ? reverse(null) : $map(x => pair(head([2, [3, null]]), x), tail([null, [[3, null], null]]), pair((x => pair(head([2, [3, null]]), x))(head([null, [[3, null], null]])), null))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

{ { undefined; const rest = append([null, [[3, null], null]], $map(x => pair(head([2, [3, null]]), x), tail([null, [[3, null], null]]), pair((x => pair(head([2, [3, null]]), x))(head([null, [[3, null], null]])), null))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

{ { undefined; const rest = append([null, [[3, null], null]], $map(x => pair(head([2, [3, null]]), x), tail([null, [[3, null], null]]), pair((x => pair(head([2, [3, null]]), x))(head([null, [[3, null], null]])), null))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] tail runs

{ { undefined; const rest = append([null, [[3, null], null]], $map(x => pair(head([2, [3, null]]), x), [[3, null], null], pair((x => pair(head([2, [3, null]]), x))(head([null, [[3, null], null]])), null))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] tail runs

{ { undefined; const rest = append([null, [[3, null], null]], $map(x => pair(head([2, [3, null]]), x), [[3, null], null], pair((x => pair(head([2, [3, null]]), x))(head([null, [[3, null], null]])), null))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] head runs

{ { undefined; const rest = append([null, [[3, null], null]], $map(x => pair(head([2, [3, null]]), x), [[3, null], null], pair((x => pair(head([2, [3, null]]), x))(null), null))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] head runs

{ { undefined; const rest = append([null, [[3, null], null]], $map(x => pair(head([2, [3, null]]), x), [[3, null], null], pair((x => pair(head([2, [3, null]]), x))(null), null))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] null substituted into x of x => pair(head([2, [3, null]]), x)

{ { undefined; const rest = append([null, [[3, null], null]], $map(x => pair(head([2, [3, null]]), x), [[3, null], null], pair(pair(head([2, [3, null]]), null), null))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] null substituted into x of x => pair(head([2, [3, null]]), x)

{ { undefined; const rest = append([null, [[3, null], null]], $map(x => pair(head([2, [3, null]]), x), [[3, null], null], pair(pair(head([2, [3, null]]), null), null))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] head runs

{ { undefined; const rest = append([null, [[3, null], null]], $map(x => pair(head([2, [3, null]]), x), [[3, null], null], pair(pair(2, null), null))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] head runs

{ { undefined; const rest = append([null, [[3, null], null]], $map(x => pair(head([2, [3, null]]), x), [[3, null], null], pair(pair(2, null), null))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] pair runs

{ { undefined; const rest = append([null, [[3, null], null]], $map(x => pair(head([2, [3, null]]), x), [[3, null], null], pair([2, null], null))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] pair runs

{ { undefined; const rest = append([null, [[3, null], null]], $map(x => pair(head([2, [3, null]]), x), [[3, null], null], pair([2, null], null))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] pair runs

{ { undefined; const rest = append([null, [[3, null], null]], $map(x => pair(head([2, [3, null]]), x), [[3, null], null], [[2, null], null])); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] pair runs

{ { undefined; const rest = append([null, [[3, null], null]], $map(x => pair(head([2, [3, null]]), x), [[3, null], null], [[2, null], null])); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] $map runs

{ { undefined; const rest = append([null, [[3, null], null]], ((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => pair(head([2, [3, null]]), x), [[3, null], null], [[2, null], null])); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] $map runs

{ { undefined; const rest = append([null, [[3, null], null]], ((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => pair(head([2, [3, null]]), x), [[3, null], null], [[2, null], null])); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] x => pair(head([2, [3, null]]), x), [[3, null], null], [[2, null], null] substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

{ { undefined; const rest = append([null, [[3, null], null]], is_null([[3, null], null]) ? reverse([[2, null], null]) : $map(x => pair(head([2, [3, null]]), x), tail([[3, null], null]), pair((x => pair(head([2, [3, null]]), x))(head([[3, null], null])), [[2, null], null]))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] x => pair(head([2, [3, null]]), x), [[3, null], null], [[2, null], null] substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

{ { undefined; const rest = append([null, [[3, null], null]], is_null([[3, null], null]) ? reverse([[2, null], null]) : $map(x => pair(head([2, [3, null]]), x), tail([[3, null], null]), pair((x => pair(head([2, [3, null]]), x))(head([[3, null], null])), [[2, null], null]))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] is_null runs

{ { undefined; const rest = append([null, [[3, null], null]], false ? reverse([[2, null], null]) : $map(x => pair(head([2, [3, null]]), x), tail([[3, null], null]), pair((x => pair(head([2, [3, null]]), x))(head([[3, null], null])), [[2, null], null]))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] is_null runs

{ { undefined; const rest = append([null, [[3, null], null]], false ? reverse([[2, null], null]) : $map(x => pair(head([2, [3, null]]), x), tail([[3, null], null]), pair((x => pair(head([2, [3, null]]), x))(head([[3, null], null])), [[2, null], null]))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

{ { undefined; const rest = append([null, [[3, null], null]], $map(x => pair(head([2, [3, null]]), x), tail([[3, null], null]), pair((x => pair(head([2, [3, null]]), x))(head([[3, null], null])), [[2, null], null]))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

{ { undefined; const rest = append([null, [[3, null], null]], $map(x => pair(head([2, [3, null]]), x), tail([[3, null], null]), pair((x => pair(head([2, [3, null]]), x))(head([[3, null], null])), [[2, null], null]))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] tail runs

{ { undefined; const rest = append([null, [[3, null], null]], $map(x => pair(head([2, [3, null]]), x), null, pair((x => pair(head([2, [3, null]]), x))(head([[3, null], null])), [[2, null], null]))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] tail runs

{ { undefined; const rest = append([null, [[3, null], null]], $map(x => pair(head([2, [3, null]]), x), null, pair((x => pair(head([2, [3, null]]), x))(head([[3, null], null])), [[2, null], null]))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] head runs

{ { undefined; const rest = append([null, [[3, null], null]], $map(x => pair(head([2, [3, null]]), x), null, pair((x => pair(head([2, [3, null]]), x))([3, null]), [[2, null], null]))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] head runs

{ { undefined; const rest = append([null, [[3, null], null]], $map(x => pair(head([2, [3, null]]), x), null, pair((x => pair(head([2, [3, null]]), x))([3, null]), [[2, null], null]))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] [3, null] substituted into x of x => pair(head([2, [3, null]]), x)

{ { undefined; const rest = append([null, [[3, null], null]], $map(x => pair(head([2, [3, null]]), x), null, pair(pair(head([2, [3, null]]), [3, null]), [[2, null], null]))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] [3, null] substituted into x of x => pair(head([2, [3, null]]), x)

{ { undefined; const rest = append([null, [[3, null], null]], $map(x => pair(head([2, [3, null]]), x), null, pair(pair(head([2, [3, null]]), [3, null]), [[2, null], null]))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] head runs

{ { undefined; const rest = append([null, [[3, null], null]], $map(x => pair(head([2, [3, null]]), x), null, pair(pair(2, [3, null]), [[2, null], null]))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] head runs

{ { undefined; const rest = append([null, [[3, null], null]], $map(x => pair(head([2, [3, null]]), x), null, pair(pair(2, [3, null]), [[2, null], null]))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] pair runs

{ { undefined; const rest = append([null, [[3, null], null]], $map(x => pair(head([2, [3, null]]), x), null, pair([2, [3, null]], [[2, null], null]))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] pair runs

{ { undefined; const rest = append([null, [[3, null], null]], $map(x => pair(head([2, [3, null]]), x), null, pair([2, [3, null]], [[2, null], null]))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] pair runs

{ { undefined; const rest = append([null, [[3, null], null]], $map(x => pair(head([2, [3, null]]), x), null, [[2, [3, null]], [[2, null], null]])); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] pair runs

{ { undefined; const rest = append([null, [[3, null], null]], $map(x => pair(head([2, [3, null]]), x), null, [[2, [3, null]], [[2, null], null]])); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] $map runs

{ { undefined; const rest = append([null, [[3, null], null]], ((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => pair(head([2, [3, null]]), x), null, [[2, [3, null]], [[2, null], null]])); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] $map runs

{ { undefined; const rest = append([null, [[3, null], null]], ((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => pair(head([2, [3, null]]), x), null, [[2, [3, null]], [[2, null], null]])); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] x => pair(head([2, [3, null]]), x), null, [[2, [3, null]], [[2, null], null]] substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

{ { undefined; const rest = append([null, [[3, null], null]], is_null(null) ? reverse([[2, [3, null]], [[2, null], null]]) : $map(x => pair(head([2, [3, null]]), x), tail(null), pair((x => pair(head([2, [3, null]]), x))(head(null)), [[2, [3, null]], [[2, null], null]]))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] x => pair(head([2, [3, null]]), x), null, [[2, [3, null]], [[2, null], null]] substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

{ { undefined; const rest = append([null, [[3, null], null]], is_null(null) ? reverse([[2, [3, null]], [[2, null], null]]) : $map(x => pair(head([2, [3, null]]), x), tail(null), pair((x => pair(head([2, [3, null]]), x))(head(null)), [[2, [3, null]], [[2, null], null]]))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] is_null runs

{ { undefined; const rest = append([null, [[3, null], null]], true ? reverse([[2, [3, null]], [[2, null], null]]) : $map(x => pair(head([2, [3, null]]), x), tail(null), pair((x => pair(head([2, [3, null]]), x))(head(null)), [[2, [3, null]], [[2, null], null]]))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] is_null runs

{ { undefined; const rest = append([null, [[3, null], null]], true ? reverse([[2, [3, null]], [[2, null], null]]) : $map(x => pair(head([2, [3, null]]), x), tail(null), pair((x => pair(head([2, [3, null]]), x))(head(null)), [[2, [3, null]], [[2, null], null]]))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

{ { undefined; const rest = append([null, [[3, null], null]], reverse([[2, [3, null]], [[2, null], null]])); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

{ { undefined; const rest = append([null, [[3, null], null]], reverse([[2, [3, null]], [[2, null], null]])); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] reverse runs

{ { undefined; const rest = append([null, [[3, null], null]], $reverse([[2, [3, null]], [[2, null], null]], null)); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] reverse runs

{ { undefined; const rest = append([null, [[3, null], null]], $reverse([[2, [3, null]], [[2, null], null]], null)); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] $reverse runs

{ { undefined; const rest = append([null, [[3, null], null]], ((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([[2, [3, null]], [[2, null], null]], null)); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] $reverse runs

{ { undefined; const rest = append([null, [[3, null], null]], ((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([[2, [3, null]], [[2, null], null]], null)); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] [[2, [3, null]], [[2, null], null]], null substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

{ { undefined; const rest = append([null, [[3, null], null]], is_null([[2, [3, null]], [[2, null], null]]) ? null : $reverse(tail([[2, [3, null]], [[2, null], null]]), pair(head([[2, [3, null]], [[2, null], null]]), null))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] [[2, [3, null]], [[2, null], null]], null substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

{ { undefined; const rest = append([null, [[3, null], null]], is_null([[2, [3, null]], [[2, null], null]]) ? null : $reverse(tail([[2, [3, null]], [[2, null], null]]), pair(head([[2, [3, null]], [[2, null], null]]), null))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] is_null runs

{ { undefined; const rest = append([null, [[3, null], null]], false ? null : $reverse(tail([[2, [3, null]], [[2, null], null]]), pair(head([[2, [3, null]], [[2, null], null]]), null))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] is_null runs

{ { undefined; const rest = append([null, [[3, null], null]], false ? null : $reverse(tail([[2, [3, null]], [[2, null], null]]), pair(head([[2, [3, null]], [[2, null], null]]), null))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

{ { undefined; const rest = append([null, [[3, null], null]], $reverse(tail([[2, [3, null]], [[2, null], null]]), pair(head([[2, [3, null]], [[2, null], null]]), null))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

{ { undefined; const rest = append([null, [[3, null], null]], $reverse(tail([[2, [3, null]], [[2, null], null]]), pair(head([[2, [3, null]], [[2, null], null]]), null))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] tail runs

{ { undefined; const rest = append([null, [[3, null], null]], $reverse([[2, null], null], pair(head([[2, [3, null]], [[2, null], null]]), null))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] tail runs

{ { undefined; const rest = append([null, [[3, null], null]], $reverse([[2, null], null], pair(head([[2, [3, null]], [[2, null], null]]), null))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] head runs

{ { undefined; const rest = append([null, [[3, null], null]], $reverse([[2, null], null], pair([2, [3, null]], null))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] head runs

{ { undefined; const rest = append([null, [[3, null], null]], $reverse([[2, null], null], pair([2, [3, null]], null))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] pair runs

{ { undefined; const rest = append([null, [[3, null], null]], $reverse([[2, null], null], [[2, [3, null]], null])); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] pair runs

{ { undefined; const rest = append([null, [[3, null], null]], $reverse([[2, null], null], [[2, [3, null]], null])); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] $reverse runs

{ { undefined; const rest = append([null, [[3, null], null]], ((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([[2, null], null], [[2, [3, null]], null])); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] $reverse runs

{ { undefined; const rest = append([null, [[3, null], null]], ((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([[2, null], null], [[2, [3, null]], null])); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] [[2, null], null], [[2, [3, null]], null] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

{ { undefined; const rest = append([null, [[3, null], null]], is_null([[2, null], null]) ? [[2, [3, null]], null] : $reverse(tail([[2, null], null]), pair(head([[2, null], null]), [[2, [3, null]], null]))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] [[2, null], null], [[2, [3, null]], null] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

{ { undefined; const rest = append([null, [[3, null], null]], is_null([[2, null], null]) ? [[2, [3, null]], null] : $reverse(tail([[2, null], null]), pair(head([[2, null], null]), [[2, [3, null]], null]))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] is_null runs

{ { undefined; const rest = append([null, [[3, null], null]], false ? [[2, [3, null]], null] : $reverse(tail([[2, null], null]), pair(head([[2, null], null]), [[2, [3, null]], null]))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] is_null runs

{ { undefined; const rest = append([null, [[3, null], null]], false ? [[2, [3, null]], null] : $reverse(tail([[2, null], null]), pair(head([[2, null], null]), [[2, [3, null]], null]))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

{ { undefined; const rest = append([null, [[3, null], null]], $reverse(tail([[2, null], null]), pair(head([[2, null], null]), [[2, [3, null]], null]))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

{ { undefined; const rest = append([null, [[3, null], null]], $reverse(tail([[2, null], null]), pair(head([[2, null], null]), [[2, [3, null]], null]))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] tail runs

{ { undefined; const rest = append([null, [[3, null], null]], $reverse(null, pair(head([[2, null], null]), [[2, [3, null]], null]))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] tail runs

{ { undefined; const rest = append([null, [[3, null], null]], $reverse(null, pair(head([[2, null], null]), [[2, [3, null]], null]))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] head runs

{ { undefined; const rest = append([null, [[3, null], null]], $reverse(null, pair([2, null], [[2, [3, null]], null]))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] head runs

{ { undefined; const rest = append([null, [[3, null], null]], $reverse(null, pair([2, null], [[2, [3, null]], null]))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] pair runs

{ { undefined; const rest = append([null, [[3, null], null]], $reverse(null, [[2, null], [[2, [3, null]], null]])); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] pair runs

{ { undefined; const rest = append([null, [[3, null], null]], $reverse(null, [[2, null], [[2, [3, null]], null]])); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] $reverse runs

{ { undefined; const rest = append([null, [[3, null], null]], ((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))(null, [[2, null], [[2, [3, null]], null]])); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] $reverse runs

{ { undefined; const rest = append([null, [[3, null], null]], ((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))(null, [[2, null], [[2, [3, null]], null]])); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] null, [[2, null], [[2, [3, null]], null]] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

{ { undefined; const rest = append([null, [[3, null], null]], is_null(null) ? [[2, null], [[2, [3, null]], null]] : $reverse(tail(null), pair(head(null), [[2, null], [[2, [3, null]], null]]))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] null, [[2, null], [[2, [3, null]], null]] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

{ { undefined; const rest = append([null, [[3, null], null]], is_null(null) ? [[2, null], [[2, [3, null]], null]] : $reverse(tail(null), pair(head(null), [[2, null], [[2, [3, null]], null]]))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] is_null runs

{ { undefined; const rest = append([null, [[3, null], null]], true ? [[2, null], [[2, [3, null]], null]] : $reverse(tail(null), pair(head(null), [[2, null], [[2, [3, null]], null]]))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] is_null runs

{ { undefined; const rest = append([null, [[3, null], null]], true ? [[2, null], [[2, [3, null]], null]] : $reverse(tail(null), pair(head(null), [[2, null], [[2, [3, null]], null]]))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

{ { undefined; const rest = append([null, [[3, null], null]], [[2, null], [[2, [3, null]], null]]); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

{ { undefined; const rest = append([null, [[3, null], null]], [[2, null], [[2, [3, null]], null]]); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] append runs

{ { undefined; const rest = $append([null, [[3, null], null]], [[2, null], [[2, [3, null]], null]], xs => xs); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] append runs

{ { undefined; const rest = $append([null, [[3, null], null]], [[2, null], [[2, [3, null]], null]], xs => xs); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] $append runs

{ { undefined; const rest = ((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([null, [[3, null], null]], [[2, null], [[2, [3, null]], null]], xs => xs); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] $append runs

{ { undefined; const rest = ((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([null, [[3, null], null]], [[2, null], [[2, [3, null]], null]], xs => xs); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] [null, [[3, null], null]], [[2, null], [[2, [3, null]], null]], xs => xs substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

{ { undefined; const rest = is_null([null, [[3, null], null]]) ? (xs => xs)([[2, null], [[2, [3, null]], null]]) : $append(tail([null, [[3, null], null]]), [[2, null], [[2, [3, null]], null]], zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] [null, [[3, null], null]], [[2, null], [[2, [3, null]], null]], xs => xs substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

{ { undefined; const rest = is_null([null, [[3, null], null]]) ? (xs => xs)([[2, null], [[2, [3, null]], null]]) : $append(tail([null, [[3, null], null]]), [[2, null], [[2, [3, null]], null]], zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] is_null runs

{ { undefined; const rest = false ? (xs => xs)([[2, null], [[2, [3, null]], null]]) : $append(tail([null, [[3, null], null]]), [[2, null], [[2, [3, null]], null]], zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] is_null runs

{ { undefined; const rest = false ? (xs => xs)([[2, null], [[2, [3, null]], null]]) : $append(tail([null, [[3, null], null]]), [[2, null], [[2, [3, null]], null]], zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

{ { undefined; const rest = $append(tail([null, [[3, null], null]]), [[2, null], [[2, [3, null]], null]], zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

{ { undefined; const rest = $append(tail([null, [[3, null], null]]), [[2, null], [[2, [3, null]], null]], zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] tail runs

{ { undefined; const rest = $append([[3, null], null], [[2, null], [[2, [3, null]], null]], zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] tail runs

{ { undefined; const rest = $append([[3, null], null], [[2, null], [[2, [3, null]], null]], zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] $append runs

{ { undefined; const rest = ((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([[3, null], null], [[2, null], [[2, [3, null]], null]], zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] $append runs

{ { undefined; const rest = ((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([[3, null], null], [[2, null], [[2, [3, null]], null]], zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] [[3, null], null], [[2, null], [[2, [3, null]], null]], zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

{ { undefined; const rest = is_null([[3, null], null]) ? (zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs)))([[2, null], [[2, [3, null]], null]]) : $append(tail([[3, null], null]), [[2, null], [[2, [3, null]], null]], zs => (zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs)))(pair(head([[3, null], null]), zs))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] [[3, null], null], [[2, null], [[2, [3, null]], null]], zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

{ { undefined; const rest = is_null([[3, null], null]) ? (zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs)))([[2, null], [[2, [3, null]], null]]) : $append(tail([[3, null], null]), [[2, null], [[2, [3, null]], null]], zs => (zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs)))(pair(head([[3, null], null]), zs))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] is_null runs

{ { undefined; const rest = false ? (zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs)))([[2, null], [[2, [3, null]], null]]) : $append(tail([[3, null], null]), [[2, null], [[2, [3, null]], null]], zs => (zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs)))(pair(head([[3, null], null]), zs))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] is_null runs

{ { undefined; const rest = false ? (zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs)))([[2, null], [[2, [3, null]], null]]) : $append(tail([[3, null], null]), [[2, null], [[2, [3, null]], null]], zs => (zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs)))(pair(head([[3, null], null]), zs))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

{ { undefined; const rest = $append(tail([[3, null], null]), [[2, null], [[2, [3, null]], null]], zs => (zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs)))(pair(head([[3, null], null]), zs))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

{ { undefined; const rest = $append(tail([[3, null], null]), [[2, null], [[2, [3, null]], null]], zs => (zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs)))(pair(head([[3, null], null]), zs))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] tail runs

{ { undefined; const rest = $append(null, [[2, null], [[2, [3, null]], null]], zs => (zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs)))(pair(head([[3, null], null]), zs))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] tail runs

{ { undefined; const rest = $append(null, [[2, null], [[2, [3, null]], null]], zs => (zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs)))(pair(head([[3, null], null]), zs))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] $append runs

{ { undefined; const rest = ((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))(null, [[2, null], [[2, [3, null]], null]], zs => (zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs)))(pair(head([[3, null], null]), zs))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] $append runs

{ { undefined; const rest = ((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))(null, [[2, null], [[2, [3, null]], null]], zs => (zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs)))(pair(head([[3, null], null]), zs))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] null, [[2, null], [[2, [3, null]], null]], zs => (zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs)))(pair(head([[3, null], null]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

{ { undefined; const rest = is_null(null) ? (zs => (zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs)))(pair(head([[3, null], null]), zs)))([[2, null], [[2, [3, null]], null]]) : $append(tail(null), [[2, null], [[2, [3, null]], null]], zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs)))(pair(head([[3, null], null]), zs)))(pair(head(null), zs))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] null, [[2, null], [[2, [3, null]], null]], zs => (zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs)))(pair(head([[3, null], null]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

{ { undefined; const rest = is_null(null) ? (zs => (zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs)))(pair(head([[3, null], null]), zs)))([[2, null], [[2, [3, null]], null]]) : $append(tail(null), [[2, null], [[2, [3, null]], null]], zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs)))(pair(head([[3, null], null]), zs)))(pair(head(null), zs))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] is_null runs

{ { undefined; const rest = true ? (zs => (zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs)))(pair(head([[3, null], null]), zs)))([[2, null], [[2, [3, null]], null]]) : $append(tail(null), [[2, null], [[2, [3, null]], null]], zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs)))(pair(head([[3, null], null]), zs)))(pair(head(null), zs))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] is_null runs

{ { undefined; const rest = true ? (zs => (zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs)))(pair(head([[3, null], null]), zs)))([[2, null], [[2, [3, null]], null]]) : $append(tail(null), [[2, null], [[2, [3, null]], null]], zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs)))(pair(head([[3, null], null]), zs)))(pair(head(null), zs))); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

{ { undefined; const rest = (zs => (zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs)))(pair(head([[3, null], null]), zs)))([[2, null], [[2, [3, null]], null]]); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

{ { undefined; const rest = (zs => (zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs)))(pair(head([[3, null], null]), zs)))([[2, null], [[2, [3, null]], null]]); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] [[2, null], [[2, [3, null]], null]] substituted into zs of zs => (zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs)))(pair(head([[3, null], null]), zs))

{ { undefined; const rest = (zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs)))(pair(head([[3, null], null]), [[2, null], [[2, [3, null]], null]])); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] [[2, null], [[2, [3, null]], null]] substituted into zs of zs => (zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs)))(pair(head([[3, null], null]), zs))

{ { undefined; const rest = (zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs)))(pair(head([[3, null], null]), [[2, null], [[2, [3, null]], null]])); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] head runs

{ { undefined; const rest = (zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs)))(pair([3, null], [[2, null], [[2, [3, null]], null]])); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] head runs

{ { undefined; const rest = (zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs)))(pair([3, null], [[2, null], [[2, [3, null]], null]])); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] pair runs

{ { undefined; const rest = (zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs)))([[3, null], [[2, null], [[2, [3, null]], null]]]); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] pair runs

{ { undefined; const rest = (zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs)))([[3, null], [[2, null], [[2, [3, null]], null]]]); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] [[3, null], [[2, null], [[2, [3, null]], null]]] substituted into zs of zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs))

{ { undefined; const rest = (xs => xs)(pair(head([null, [[3, null], null]]), [[3, null], [[2, null], [[2, [3, null]], null]]])); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] [[3, null], [[2, null], [[2, [3, null]], null]]] substituted into zs of zs => (xs => xs)(pair(head([null, [[3, null], null]]), zs))

{ { undefined; const rest = (xs => xs)(pair(head([null, [[3, null], null]]), [[3, null], [[2, null], [[2, [3, null]], null]]])); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] head runs

{ { undefined; const rest = (xs => xs)(pair(null, [[3, null], [[2, null], [[2, [3, null]], null]]])); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] head runs

{ { undefined; const rest = (xs => xs)(pair(null, [[3, null], [[2, null], [[2, [3, null]], null]]])); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] pair runs

{ { undefined; const rest = (xs => xs)([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] pair runs

{ { undefined; const rest = (xs => xs)([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]); return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] [null, [[3, null], [[2, null], [[2, [3, null]], null]]]] substituted into xs of xs => xs

{ { undefined; const rest = [null, [[3, null], [[2, null], [[2, [3, null]], null]]]]; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[afterMarker] [null, [[3, null], [[2, null], [[2, [3, null]], null]]]] substituted into xs of xs => xs

{ { undefined; const rest = [null, [[3, null], [[2, null], [[2, [3, null]], null]]]]; return append(rest, map(x => pair(head([1, [2, [3, null]]]), x), rest)); }};
[beforeMarker] Constant rest declared and substituted into the rest of block

{ { undefined; return append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], map(x => pair(head([1, [2, [3, null]]]), x), [null, [[3, null], [[2, null], [[2, [3, null]], null]]]])); }};
[afterMarker] Constant rest declared and substituted into the rest of block

{ { undefined; return append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], map(x => pair(head([1, [2, [3, null]]]), x), [null, [[3, null], [[2, null], [[2, [3, null]], null]]]])); }};
[beforeMarker] undefined finished evaluating

{ { return append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], map(x => pair(head([1, [2, [3, null]]]), x), [null, [[3, null], [[2, null], [[2, [3, null]], null]]]])); }};
[afterMarker] undefined finished evaluating

{ { return append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], map(x => pair(head([1, [2, [3, null]]]), x), [null, [[3, null], [[2, null], [[2, [3, null]], null]]]])); }};
[beforeMarker] return append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], map(x => pair(head([1, [2, [3, null]]]), x), [null, [[3, null], [[2, null], [[2, [3, null]], null]]]])); finished evaluating

{ return append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], map(x => pair(head([1, [2, [3, null]]]), x), [null, [[3, null], [[2, null], [[2, [3, null]], null]]]]));};
[afterMarker] return append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], map(x => pair(head([1, [2, [3, null]]]), x), [null, [[3, null], [[2, null], [[2, [3, null]], null]]]])); finished evaluating

{ return append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], map(x => pair(head([1, [2, [3, null]]]), x), [null, [[3, null], [[2, null], [[2, [3, null]], null]]]]));};
[beforeMarker] append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], map(x => pair(head([1, [2, [3, null]]]), x), [null, [[3, null], [[2, null], [[2, [3, null]], null]]]])) returned

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], map(x => pair(head([1, [2, [3, null]]]), x), [null, [[3, null], [[2, null], [[2, [3, null]], null]]]]));
[afterMarker] append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], map(x => pair(head([1, [2, [3, null]]]), x), [null, [[3, null], [[2, null], [[2, [3, null]], null]]]])) returned

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], map(x => pair(head([1, [2, [3, null]]]), x), [null, [[3, null], [[2, null], [[2, [3, null]], null]]]]));
[beforeMarker] map runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), [null, [[3, null], [[2, null], [[2, [3, null]], null]]]], null));
[afterMarker] map runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), [null, [[3, null], [[2, null], [[2, [3, null]], null]]]], null));
[beforeMarker] $map runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], ((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => pair(head([1, [2, [3, null]]]), x), [null, [[3, null], [[2, null], [[2, [3, null]], null]]]], null));
[afterMarker] $map runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], ((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => pair(head([1, [2, [3, null]]]), x), [null, [[3, null], [[2, null], [[2, [3, null]], null]]]], null));
[beforeMarker] x => pair(head([1, [2, [3, null]]]), x), [null, [[3, null], [[2, null], [[2, [3, null]], null]]]], null substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], is_null([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]) ? reverse(null) : $map(x => pair(head([1, [2, [3, null]]]), x), tail([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), pair((x => pair(head([1, [2, [3, null]]]), x))(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]])), null)));
[afterMarker] x => pair(head([1, [2, [3, null]]]), x), [null, [[3, null], [[2, null], [[2, [3, null]], null]]]], null substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], is_null([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]) ? reverse(null) : $map(x => pair(head([1, [2, [3, null]]]), x), tail([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), pair((x => pair(head([1, [2, [3, null]]]), x))(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]])), null)));
[beforeMarker] is_null runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], false ? reverse(null) : $map(x => pair(head([1, [2, [3, null]]]), x), tail([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), pair((x => pair(head([1, [2, [3, null]]]), x))(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]])), null)));
[afterMarker] is_null runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], false ? reverse(null) : $map(x => pair(head([1, [2, [3, null]]]), x), tail([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), pair((x => pair(head([1, [2, [3, null]]]), x))(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]])), null)));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), tail([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), pair((x => pair(head([1, [2, [3, null]]]), x))(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]])), null)));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), tail([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), pair((x => pair(head([1, [2, [3, null]]]), x))(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]])), null)));
[beforeMarker] tail runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), [[3, null], [[2, null], [[2, [3, null]], null]]], pair((x => pair(head([1, [2, [3, null]]]), x))(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]])), null)));
[afterMarker] tail runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), [[3, null], [[2, null], [[2, [3, null]], null]]], pair((x => pair(head([1, [2, [3, null]]]), x))(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]])), null)));
[beforeMarker] head runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), [[3, null], [[2, null], [[2, [3, null]], null]]], pair((x => pair(head([1, [2, [3, null]]]), x))(null), null)));
[afterMarker] head runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), [[3, null], [[2, null], [[2, [3, null]], null]]], pair((x => pair(head([1, [2, [3, null]]]), x))(null), null)));
[beforeMarker] null substituted into x of x => pair(head([1, [2, [3, null]]]), x)

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), [[3, null], [[2, null], [[2, [3, null]], null]]], pair(pair(head([1, [2, [3, null]]]), null), null)));
[afterMarker] null substituted into x of x => pair(head([1, [2, [3, null]]]), x)

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), [[3, null], [[2, null], [[2, [3, null]], null]]], pair(pair(head([1, [2, [3, null]]]), null), null)));
[beforeMarker] head runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), [[3, null], [[2, null], [[2, [3, null]], null]]], pair(pair(1, null), null)));
[afterMarker] head runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), [[3, null], [[2, null], [[2, [3, null]], null]]], pair(pair(1, null), null)));
[beforeMarker] pair runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), [[3, null], [[2, null], [[2, [3, null]], null]]], pair([1, null], null)));
[afterMarker] pair runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), [[3, null], [[2, null], [[2, [3, null]], null]]], pair([1, null], null)));
[beforeMarker] pair runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), [[3, null], [[2, null], [[2, [3, null]], null]]], [[1, null], null]));
[afterMarker] pair runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), [[3, null], [[2, null], [[2, [3, null]], null]]], [[1, null], null]));
[beforeMarker] $map runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], ((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => pair(head([1, [2, [3, null]]]), x), [[3, null], [[2, null], [[2, [3, null]], null]]], [[1, null], null]));
[afterMarker] $map runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], ((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => pair(head([1, [2, [3, null]]]), x), [[3, null], [[2, null], [[2, [3, null]], null]]], [[1, null], null]));
[beforeMarker] x => pair(head([1, [2, [3, null]]]), x), [[3, null], [[2, null], [[2, [3, null]], null]]], [[1, null], null] substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], is_null([[3, null], [[2, null], [[2, [3, null]], null]]]) ? reverse([[1, null], null]) : $map(x => pair(head([1, [2, [3, null]]]), x), tail([[3, null], [[2, null], [[2, [3, null]], null]]]), pair((x => pair(head([1, [2, [3, null]]]), x))(head([[3, null], [[2, null], [[2, [3, null]], null]]])), [[1, null], null])));
[afterMarker] x => pair(head([1, [2, [3, null]]]), x), [[3, null], [[2, null], [[2, [3, null]], null]]], [[1, null], null] substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], is_null([[3, null], [[2, null], [[2, [3, null]], null]]]) ? reverse([[1, null], null]) : $map(x => pair(head([1, [2, [3, null]]]), x), tail([[3, null], [[2, null], [[2, [3, null]], null]]]), pair((x => pair(head([1, [2, [3, null]]]), x))(head([[3, null], [[2, null], [[2, [3, null]], null]]])), [[1, null], null])));
[beforeMarker] is_null runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], false ? reverse([[1, null], null]) : $map(x => pair(head([1, [2, [3, null]]]), x), tail([[3, null], [[2, null], [[2, [3, null]], null]]]), pair((x => pair(head([1, [2, [3, null]]]), x))(head([[3, null], [[2, null], [[2, [3, null]], null]]])), [[1, null], null])));
[afterMarker] is_null runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], false ? reverse([[1, null], null]) : $map(x => pair(head([1, [2, [3, null]]]), x), tail([[3, null], [[2, null], [[2, [3, null]], null]]]), pair((x => pair(head([1, [2, [3, null]]]), x))(head([[3, null], [[2, null], [[2, [3, null]], null]]])), [[1, null], null])));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), tail([[3, null], [[2, null], [[2, [3, null]], null]]]), pair((x => pair(head([1, [2, [3, null]]]), x))(head([[3, null], [[2, null], [[2, [3, null]], null]]])), [[1, null], null])));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), tail([[3, null], [[2, null], [[2, [3, null]], null]]]), pair((x => pair(head([1, [2, [3, null]]]), x))(head([[3, null], [[2, null], [[2, [3, null]], null]]])), [[1, null], null])));
[beforeMarker] tail runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), [[2, null], [[2, [3, null]], null]], pair((x => pair(head([1, [2, [3, null]]]), x))(head([[3, null], [[2, null], [[2, [3, null]], null]]])), [[1, null], null])));
[afterMarker] tail runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), [[2, null], [[2, [3, null]], null]], pair((x => pair(head([1, [2, [3, null]]]), x))(head([[3, null], [[2, null], [[2, [3, null]], null]]])), [[1, null], null])));
[beforeMarker] head runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), [[2, null], [[2, [3, null]], null]], pair((x => pair(head([1, [2, [3, null]]]), x))([3, null]), [[1, null], null])));
[afterMarker] head runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), [[2, null], [[2, [3, null]], null]], pair((x => pair(head([1, [2, [3, null]]]), x))([3, null]), [[1, null], null])));
[beforeMarker] [3, null] substituted into x of x => pair(head([1, [2, [3, null]]]), x)

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), [[2, null], [[2, [3, null]], null]], pair(pair(head([1, [2, [3, null]]]), [3, null]), [[1, null], null])));
[afterMarker] [3, null] substituted into x of x => pair(head([1, [2, [3, null]]]), x)

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), [[2, null], [[2, [3, null]], null]], pair(pair(head([1, [2, [3, null]]]), [3, null]), [[1, null], null])));
[beforeMarker] head runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), [[2, null], [[2, [3, null]], null]], pair(pair(1, [3, null]), [[1, null], null])));
[afterMarker] head runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), [[2, null], [[2, [3, null]], null]], pair(pair(1, [3, null]), [[1, null], null])));
[beforeMarker] pair runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), [[2, null], [[2, [3, null]], null]], pair([1, [3, null]], [[1, null], null])));
[afterMarker] pair runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), [[2, null], [[2, [3, null]], null]], pair([1, [3, null]], [[1, null], null])));
[beforeMarker] pair runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), [[2, null], [[2, [3, null]], null]], [[1, [3, null]], [[1, null], null]]));
[afterMarker] pair runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), [[2, null], [[2, [3, null]], null]], [[1, [3, null]], [[1, null], null]]));
[beforeMarker] $map runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], ((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => pair(head([1, [2, [3, null]]]), x), [[2, null], [[2, [3, null]], null]], [[1, [3, null]], [[1, null], null]]));
[afterMarker] $map runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], ((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => pair(head([1, [2, [3, null]]]), x), [[2, null], [[2, [3, null]], null]], [[1, [3, null]], [[1, null], null]]));
[beforeMarker] x => pair(head([1, [2, [3, null]]]), x), [[2, null], [[2, [3, null]], null]], [[1, [3, null]], [[1, null], null]] substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], is_null([[2, null], [[2, [3, null]], null]]) ? reverse([[1, [3, null]], [[1, null], null]]) : $map(x => pair(head([1, [2, [3, null]]]), x), tail([[2, null], [[2, [3, null]], null]]), pair((x => pair(head([1, [2, [3, null]]]), x))(head([[2, null], [[2, [3, null]], null]])), [[1, [3, null]], [[1, null], null]])));
[afterMarker] x => pair(head([1, [2, [3, null]]]), x), [[2, null], [[2, [3, null]], null]], [[1, [3, null]], [[1, null], null]] substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], is_null([[2, null], [[2, [3, null]], null]]) ? reverse([[1, [3, null]], [[1, null], null]]) : $map(x => pair(head([1, [2, [3, null]]]), x), tail([[2, null], [[2, [3, null]], null]]), pair((x => pair(head([1, [2, [3, null]]]), x))(head([[2, null], [[2, [3, null]], null]])), [[1, [3, null]], [[1, null], null]])));
[beforeMarker] is_null runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], false ? reverse([[1, [3, null]], [[1, null], null]]) : $map(x => pair(head([1, [2, [3, null]]]), x), tail([[2, null], [[2, [3, null]], null]]), pair((x => pair(head([1, [2, [3, null]]]), x))(head([[2, null], [[2, [3, null]], null]])), [[1, [3, null]], [[1, null], null]])));
[afterMarker] is_null runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], false ? reverse([[1, [3, null]], [[1, null], null]]) : $map(x => pair(head([1, [2, [3, null]]]), x), tail([[2, null], [[2, [3, null]], null]]), pair((x => pair(head([1, [2, [3, null]]]), x))(head([[2, null], [[2, [3, null]], null]])), [[1, [3, null]], [[1, null], null]])));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), tail([[2, null], [[2, [3, null]], null]]), pair((x => pair(head([1, [2, [3, null]]]), x))(head([[2, null], [[2, [3, null]], null]])), [[1, [3, null]], [[1, null], null]])));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), tail([[2, null], [[2, [3, null]], null]]), pair((x => pair(head([1, [2, [3, null]]]), x))(head([[2, null], [[2, [3, null]], null]])), [[1, [3, null]], [[1, null], null]])));
[beforeMarker] tail runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), [[2, [3, null]], null], pair((x => pair(head([1, [2, [3, null]]]), x))(head([[2, null], [[2, [3, null]], null]])), [[1, [3, null]], [[1, null], null]])));
[afterMarker] tail runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), [[2, [3, null]], null], pair((x => pair(head([1, [2, [3, null]]]), x))(head([[2, null], [[2, [3, null]], null]])), [[1, [3, null]], [[1, null], null]])));
[beforeMarker] head runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), [[2, [3, null]], null], pair((x => pair(head([1, [2, [3, null]]]), x))([2, null]), [[1, [3, null]], [[1, null], null]])));
[afterMarker] head runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), [[2, [3, null]], null], pair((x => pair(head([1, [2, [3, null]]]), x))([2, null]), [[1, [3, null]], [[1, null], null]])));
[beforeMarker] [2, null] substituted into x of x => pair(head([1, [2, [3, null]]]), x)

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), [[2, [3, null]], null], pair(pair(head([1, [2, [3, null]]]), [2, null]), [[1, [3, null]], [[1, null], null]])));
[afterMarker] [2, null] substituted into x of x => pair(head([1, [2, [3, null]]]), x)

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), [[2, [3, null]], null], pair(pair(head([1, [2, [3, null]]]), [2, null]), [[1, [3, null]], [[1, null], null]])));
[beforeMarker] head runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), [[2, [3, null]], null], pair(pair(1, [2, null]), [[1, [3, null]], [[1, null], null]])));
[afterMarker] head runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), [[2, [3, null]], null], pair(pair(1, [2, null]), [[1, [3, null]], [[1, null], null]])));
[beforeMarker] pair runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), [[2, [3, null]], null], pair([1, [2, null]], [[1, [3, null]], [[1, null], null]])));
[afterMarker] pair runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), [[2, [3, null]], null], pair([1, [2, null]], [[1, [3, null]], [[1, null], null]])));
[beforeMarker] pair runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), [[2, [3, null]], null], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]));
[afterMarker] pair runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), [[2, [3, null]], null], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]));
[beforeMarker] $map runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], ((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => pair(head([1, [2, [3, null]]]), x), [[2, [3, null]], null], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]));
[afterMarker] $map runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], ((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => pair(head([1, [2, [3, null]]]), x), [[2, [3, null]], null], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]));
[beforeMarker] x => pair(head([1, [2, [3, null]]]), x), [[2, [3, null]], null], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]] substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], is_null([[2, [3, null]], null]) ? reverse([[1, [2, null]], [[1, [3, null]], [[1, null], null]]]) : $map(x => pair(head([1, [2, [3, null]]]), x), tail([[2, [3, null]], null]), pair((x => pair(head([1, [2, [3, null]]]), x))(head([[2, [3, null]], null])), [[1, [2, null]], [[1, [3, null]], [[1, null], null]]])));
[afterMarker] x => pair(head([1, [2, [3, null]]]), x), [[2, [3, null]], null], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]] substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], is_null([[2, [3, null]], null]) ? reverse([[1, [2, null]], [[1, [3, null]], [[1, null], null]]]) : $map(x => pair(head([1, [2, [3, null]]]), x), tail([[2, [3, null]], null]), pair((x => pair(head([1, [2, [3, null]]]), x))(head([[2, [3, null]], null])), [[1, [2, null]], [[1, [3, null]], [[1, null], null]]])));
[beforeMarker] is_null runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], false ? reverse([[1, [2, null]], [[1, [3, null]], [[1, null], null]]]) : $map(x => pair(head([1, [2, [3, null]]]), x), tail([[2, [3, null]], null]), pair((x => pair(head([1, [2, [3, null]]]), x))(head([[2, [3, null]], null])), [[1, [2, null]], [[1, [3, null]], [[1, null], null]]])));
[afterMarker] is_null runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], false ? reverse([[1, [2, null]], [[1, [3, null]], [[1, null], null]]]) : $map(x => pair(head([1, [2, [3, null]]]), x), tail([[2, [3, null]], null]), pair((x => pair(head([1, [2, [3, null]]]), x))(head([[2, [3, null]], null])), [[1, [2, null]], [[1, [3, null]], [[1, null], null]]])));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), tail([[2, [3, null]], null]), pair((x => pair(head([1, [2, [3, null]]]), x))(head([[2, [3, null]], null])), [[1, [2, null]], [[1, [3, null]], [[1, null], null]]])));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), tail([[2, [3, null]], null]), pair((x => pair(head([1, [2, [3, null]]]), x))(head([[2, [3, null]], null])), [[1, [2, null]], [[1, [3, null]], [[1, null], null]]])));
[beforeMarker] tail runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), null, pair((x => pair(head([1, [2, [3, null]]]), x))(head([[2, [3, null]], null])), [[1, [2, null]], [[1, [3, null]], [[1, null], null]]])));
[afterMarker] tail runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), null, pair((x => pair(head([1, [2, [3, null]]]), x))(head([[2, [3, null]], null])), [[1, [2, null]], [[1, [3, null]], [[1, null], null]]])));
[beforeMarker] head runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), null, pair((x => pair(head([1, [2, [3, null]]]), x))([2, [3, null]]), [[1, [2, null]], [[1, [3, null]], [[1, null], null]]])));
[afterMarker] head runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), null, pair((x => pair(head([1, [2, [3, null]]]), x))([2, [3, null]]), [[1, [2, null]], [[1, [3, null]], [[1, null], null]]])));
[beforeMarker] [2, [3, null]] substituted into x of x => pair(head([1, [2, [3, null]]]), x)

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), null, pair(pair(head([1, [2, [3, null]]]), [2, [3, null]]), [[1, [2, null]], [[1, [3, null]], [[1, null], null]]])));
[afterMarker] [2, [3, null]] substituted into x of x => pair(head([1, [2, [3, null]]]), x)

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), null, pair(pair(head([1, [2, [3, null]]]), [2, [3, null]]), [[1, [2, null]], [[1, [3, null]], [[1, null], null]]])));
[beforeMarker] head runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), null, pair(pair(1, [2, [3, null]]), [[1, [2, null]], [[1, [3, null]], [[1, null], null]]])));
[afterMarker] head runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), null, pair(pair(1, [2, [3, null]]), [[1, [2, null]], [[1, [3, null]], [[1, null], null]]])));
[beforeMarker] pair runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), null, pair([1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]])));
[afterMarker] pair runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), null, pair([1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]])));
[beforeMarker] pair runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), null, [[1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]]));
[afterMarker] pair runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $map(x => pair(head([1, [2, [3, null]]]), x), null, [[1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]]));
[beforeMarker] $map runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], ((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => pair(head([1, [2, [3, null]]]), x), null, [[1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]]));
[afterMarker] $map runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], ((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => pair(head([1, [2, [3, null]]]), x), null, [[1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]]));
[beforeMarker] x => pair(head([1, [2, [3, null]]]), x), null, [[1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]] substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], is_null(null) ? reverse([[1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]]) : $map(x => pair(head([1, [2, [3, null]]]), x), tail(null), pair((x => pair(head([1, [2, [3, null]]]), x))(head(null)), [[1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]])));
[afterMarker] x => pair(head([1, [2, [3, null]]]), x), null, [[1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]] substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], is_null(null) ? reverse([[1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]]) : $map(x => pair(head([1, [2, [3, null]]]), x), tail(null), pair((x => pair(head([1, [2, [3, null]]]), x))(head(null)), [[1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]])));
[beforeMarker] is_null runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], true ? reverse([[1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]]) : $map(x => pair(head([1, [2, [3, null]]]), x), tail(null), pair((x => pair(head([1, [2, [3, null]]]), x))(head(null)), [[1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]])));
[afterMarker] is_null runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], true ? reverse([[1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]]) : $map(x => pair(head([1, [2, [3, null]]]), x), tail(null), pair((x => pair(head([1, [2, [3, null]]]), x))(head(null)), [[1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]])));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], reverse([[1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], reverse([[1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]]));
[beforeMarker] reverse runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $reverse([[1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]], null));
[afterMarker] reverse runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $reverse([[1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]], null));
[beforeMarker] $reverse runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], ((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([[1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]], null));
[afterMarker] $reverse runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], ((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([[1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]], null));
[beforeMarker] [[1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]], null substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], is_null([[1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]]) ? null : $reverse(tail([[1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]]), pair(head([[1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]]), null)));
[afterMarker] [[1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]], null substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], is_null([[1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]]) ? null : $reverse(tail([[1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]]), pair(head([[1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]]), null)));
[beforeMarker] is_null runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], false ? null : $reverse(tail([[1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]]), pair(head([[1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]]), null)));
[afterMarker] is_null runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], false ? null : $reverse(tail([[1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]]), pair(head([[1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]]), null)));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $reverse(tail([[1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]]), pair(head([[1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]]), null)));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $reverse(tail([[1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]]), pair(head([[1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]]), null)));
[beforeMarker] tail runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $reverse([[1, [2, null]], [[1, [3, null]], [[1, null], null]]], pair(head([[1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]]), null)));
[afterMarker] tail runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $reverse([[1, [2, null]], [[1, [3, null]], [[1, null], null]]], pair(head([[1, [2, [3, null]]], [[1, [2, null]], [[1, [3, null]], [[1, null], null]]]]), null)));
[beforeMarker] head runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $reverse([[1, [2, null]], [[1, [3, null]], [[1, null], null]]], pair([1, [2, [3, null]]], null)));
[afterMarker] head runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $reverse([[1, [2, null]], [[1, [3, null]], [[1, null], null]]], pair([1, [2, [3, null]]], null)));
[beforeMarker] pair runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $reverse([[1, [2, null]], [[1, [3, null]], [[1, null], null]]], [[1, [2, [3, null]]], null]));
[afterMarker] pair runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $reverse([[1, [2, null]], [[1, [3, null]], [[1, null], null]]], [[1, [2, [3, null]]], null]));
[beforeMarker] $reverse runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], ((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([[1, [2, null]], [[1, [3, null]], [[1, null], null]]], [[1, [2, [3, null]]], null]));
[afterMarker] $reverse runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], ((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([[1, [2, null]], [[1, [3, null]], [[1, null], null]]], [[1, [2, [3, null]]], null]));
[beforeMarker] [[1, [2, null]], [[1, [3, null]], [[1, null], null]]], [[1, [2, [3, null]]], null] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], is_null([[1, [2, null]], [[1, [3, null]], [[1, null], null]]]) ? [[1, [2, [3, null]]], null] : $reverse(tail([[1, [2, null]], [[1, [3, null]], [[1, null], null]]]), pair(head([[1, [2, null]], [[1, [3, null]], [[1, null], null]]]), [[1, [2, [3, null]]], null])));
[afterMarker] [[1, [2, null]], [[1, [3, null]], [[1, null], null]]], [[1, [2, [3, null]]], null] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], is_null([[1, [2, null]], [[1, [3, null]], [[1, null], null]]]) ? [[1, [2, [3, null]]], null] : $reverse(tail([[1, [2, null]], [[1, [3, null]], [[1, null], null]]]), pair(head([[1, [2, null]], [[1, [3, null]], [[1, null], null]]]), [[1, [2, [3, null]]], null])));
[beforeMarker] is_null runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], false ? [[1, [2, [3, null]]], null] : $reverse(tail([[1, [2, null]], [[1, [3, null]], [[1, null], null]]]), pair(head([[1, [2, null]], [[1, [3, null]], [[1, null], null]]]), [[1, [2, [3, null]]], null])));
[afterMarker] is_null runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], false ? [[1, [2, [3, null]]], null] : $reverse(tail([[1, [2, null]], [[1, [3, null]], [[1, null], null]]]), pair(head([[1, [2, null]], [[1, [3, null]], [[1, null], null]]]), [[1, [2, [3, null]]], null])));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $reverse(tail([[1, [2, null]], [[1, [3, null]], [[1, null], null]]]), pair(head([[1, [2, null]], [[1, [3, null]], [[1, null], null]]]), [[1, [2, [3, null]]], null])));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $reverse(tail([[1, [2, null]], [[1, [3, null]], [[1, null], null]]]), pair(head([[1, [2, null]], [[1, [3, null]], [[1, null], null]]]), [[1, [2, [3, null]]], null])));
[beforeMarker] tail runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $reverse([[1, [3, null]], [[1, null], null]], pair(head([[1, [2, null]], [[1, [3, null]], [[1, null], null]]]), [[1, [2, [3, null]]], null])));
[afterMarker] tail runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $reverse([[1, [3, null]], [[1, null], null]], pair(head([[1, [2, null]], [[1, [3, null]], [[1, null], null]]]), [[1, [2, [3, null]]], null])));
[beforeMarker] head runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $reverse([[1, [3, null]], [[1, null], null]], pair([1, [2, null]], [[1, [2, [3, null]]], null])));
[afterMarker] head runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $reverse([[1, [3, null]], [[1, null], null]], pair([1, [2, null]], [[1, [2, [3, null]]], null])));
[beforeMarker] pair runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $reverse([[1, [3, null]], [[1, null], null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]));
[afterMarker] pair runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $reverse([[1, [3, null]], [[1, null], null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]));
[beforeMarker] $reverse runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], ((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([[1, [3, null]], [[1, null], null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]));
[afterMarker] $reverse runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], ((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([[1, [3, null]], [[1, null], null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]));
[beforeMarker] [[1, [3, null]], [[1, null], null]], [[1, [2, null]], [[1, [2, [3, null]]], null]] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], is_null([[1, [3, null]], [[1, null], null]]) ? [[1, [2, null]], [[1, [2, [3, null]]], null]] : $reverse(tail([[1, [3, null]], [[1, null], null]]), pair(head([[1, [3, null]], [[1, null], null]]), [[1, [2, null]], [[1, [2, [3, null]]], null]])));
[afterMarker] [[1, [3, null]], [[1, null], null]], [[1, [2, null]], [[1, [2, [3, null]]], null]] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], is_null([[1, [3, null]], [[1, null], null]]) ? [[1, [2, null]], [[1, [2, [3, null]]], null]] : $reverse(tail([[1, [3, null]], [[1, null], null]]), pair(head([[1, [3, null]], [[1, null], null]]), [[1, [2, null]], [[1, [2, [3, null]]], null]])));
[beforeMarker] is_null runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], false ? [[1, [2, null]], [[1, [2, [3, null]]], null]] : $reverse(tail([[1, [3, null]], [[1, null], null]]), pair(head([[1, [3, null]], [[1, null], null]]), [[1, [2, null]], [[1, [2, [3, null]]], null]])));
[afterMarker] is_null runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], false ? [[1, [2, null]], [[1, [2, [3, null]]], null]] : $reverse(tail([[1, [3, null]], [[1, null], null]]), pair(head([[1, [3, null]], [[1, null], null]]), [[1, [2, null]], [[1, [2, [3, null]]], null]])));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $reverse(tail([[1, [3, null]], [[1, null], null]]), pair(head([[1, [3, null]], [[1, null], null]]), [[1, [2, null]], [[1, [2, [3, null]]], null]])));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $reverse(tail([[1, [3, null]], [[1, null], null]]), pair(head([[1, [3, null]], [[1, null], null]]), [[1, [2, null]], [[1, [2, [3, null]]], null]])));
[beforeMarker] tail runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $reverse([[1, null], null], pair(head([[1, [3, null]], [[1, null], null]]), [[1, [2, null]], [[1, [2, [3, null]]], null]])));
[afterMarker] tail runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $reverse([[1, null], null], pair(head([[1, [3, null]], [[1, null], null]]), [[1, [2, null]], [[1, [2, [3, null]]], null]])));
[beforeMarker] head runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $reverse([[1, null], null], pair([1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]])));
[afterMarker] head runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $reverse([[1, null], null], pair([1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]])));
[beforeMarker] pair runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $reverse([[1, null], null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]));
[afterMarker] pair runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $reverse([[1, null], null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]));
[beforeMarker] $reverse runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], ((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([[1, null], null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]));
[afterMarker] $reverse runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], ((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([[1, null], null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]));
[beforeMarker] [[1, null], null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], is_null([[1, null], null]) ? [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]] : $reverse(tail([[1, null], null]), pair(head([[1, null], null]), [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]])));
[afterMarker] [[1, null], null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], is_null([[1, null], null]) ? [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]] : $reverse(tail([[1, null], null]), pair(head([[1, null], null]), [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]])));
[beforeMarker] is_null runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], false ? [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]] : $reverse(tail([[1, null], null]), pair(head([[1, null], null]), [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]])));
[afterMarker] is_null runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], false ? [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]] : $reverse(tail([[1, null], null]), pair(head([[1, null], null]), [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]])));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $reverse(tail([[1, null], null]), pair(head([[1, null], null]), [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]])));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $reverse(tail([[1, null], null]), pair(head([[1, null], null]), [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]])));
[beforeMarker] tail runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $reverse(null, pair(head([[1, null], null]), [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]])));
[afterMarker] tail runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $reverse(null, pair(head([[1, null], null]), [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]])));
[beforeMarker] head runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $reverse(null, pair([1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]])));
[afterMarker] head runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $reverse(null, pair([1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]])));
[beforeMarker] pair runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $reverse(null, [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]));
[afterMarker] pair runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], $reverse(null, [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]));
[beforeMarker] $reverse runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], ((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))(null, [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]));
[afterMarker] $reverse runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], ((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))(null, [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]));
[beforeMarker] null, [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], is_null(null) ? [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]] : $reverse(tail(null), pair(head(null), [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]])));
[afterMarker] null, [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], is_null(null) ? [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]] : $reverse(tail(null), pair(head(null), [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]])));
[beforeMarker] is_null runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], true ? [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]] : $reverse(tail(null), pair(head(null), [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]])));
[afterMarker] is_null runs

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], true ? [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]] : $reverse(tail(null), pair(head(null), [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]])));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]);
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]);
[beforeMarker] append runs

$append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], xs => xs);
[afterMarker] append runs

$append([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], xs => xs);
[beforeMarker] $append runs

((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], xs => xs);
[afterMarker] $append runs

((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([null, [[3, null], [[2, null], [[2, [3, null]], null]]]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], xs => xs);
[beforeMarker] [null, [[3, null], [[2, null], [[2, [3, null]], null]]]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], xs => xs substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

is_null([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]) ? (xs => xs)([[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]) : $append(tail([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)));
[afterMarker] [null, [[3, null], [[2, null], [[2, [3, null]], null]]]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], xs => xs substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

is_null([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]) ? (xs => xs)([[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]) : $append(tail([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)));
[beforeMarker] is_null runs

false ? (xs => xs)([[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]) : $append(tail([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)));
[afterMarker] is_null runs

false ? (xs => xs)([[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]) : $append(tail([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

$append(tail([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

$append(tail([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)));
[beforeMarker] tail runs

$append([[3, null], [[2, null], [[2, [3, null]], null]]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)));
[afterMarker] tail runs

$append([[3, null], [[2, null], [[2, [3, null]], null]]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)));
[beforeMarker] $append runs

((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([[3, null], [[2, null], [[2, [3, null]], null]]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)));
[afterMarker] $append runs

((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([[3, null], [[2, null], [[2, [3, null]], null]]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)));
[beforeMarker] [[3, null], [[2, null], [[2, [3, null]], null]]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

is_null([[3, null], [[2, null], [[2, [3, null]], null]]]) ? (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))([[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]) : $append(tail([[3, null], [[2, null], [[2, [3, null]], null]]]), [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)));
[afterMarker] [[3, null], [[2, null], [[2, [3, null]], null]]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

is_null([[3, null], [[2, null], [[2, [3, null]], null]]]) ? (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))([[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]) : $append(tail([[3, null], [[2, null], [[2, [3, null]], null]]]), [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)));
[beforeMarker] is_null runs

false ? (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))([[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]) : $append(tail([[3, null], [[2, null], [[2, [3, null]], null]]]), [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)));
[afterMarker] is_null runs

false ? (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))([[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]) : $append(tail([[3, null], [[2, null], [[2, [3, null]], null]]]), [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

$append(tail([[3, null], [[2, null], [[2, [3, null]], null]]]), [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

$append(tail([[3, null], [[2, null], [[2, [3, null]], null]]]), [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)));
[beforeMarker] tail runs

$append([[2, null], [[2, [3, null]], null]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)));
[afterMarker] tail runs

$append([[2, null], [[2, [3, null]], null]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)));
[beforeMarker] $append runs

((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([[2, null], [[2, [3, null]], null]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)));
[afterMarker] $append runs

((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([[2, null], [[2, [3, null]], null]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)));
[beforeMarker] [[2, null], [[2, [3, null]], null]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

is_null([[2, null], [[2, [3, null]], null]]) ? (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))([[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]) : $append(tail([[2, null], [[2, [3, null]], null]]), [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)));
[afterMarker] [[2, null], [[2, [3, null]], null]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

is_null([[2, null], [[2, [3, null]], null]]) ? (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))([[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]) : $append(tail([[2, null], [[2, [3, null]], null]]), [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)));
[beforeMarker] is_null runs

false ? (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))([[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]) : $append(tail([[2, null], [[2, [3, null]], null]]), [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)));
[afterMarker] is_null runs

false ? (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))([[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]) : $append(tail([[2, null], [[2, [3, null]], null]]), [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

$append(tail([[2, null], [[2, [3, null]], null]]), [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

$append(tail([[2, null], [[2, [3, null]], null]]), [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)));
[beforeMarker] tail runs

$append([[2, [3, null]], null], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)));
[afterMarker] tail runs

$append([[2, [3, null]], null], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)));
[beforeMarker] $append runs

((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([[2, [3, null]], null], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)));
[afterMarker] $append runs

((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([[2, [3, null]], null], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)));
[beforeMarker] [[2, [3, null]], null], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

is_null([[2, [3, null]], null]) ? (zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)))([[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]) : $append(tail([[2, [3, null]], null]), [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)))(pair(head([[2, [3, null]], null]), zs)));
[afterMarker] [[2, [3, null]], null], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

is_null([[2, [3, null]], null]) ? (zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)))([[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]) : $append(tail([[2, [3, null]], null]), [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)))(pair(head([[2, [3, null]], null]), zs)));
[beforeMarker] is_null runs

false ? (zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)))([[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]) : $append(tail([[2, [3, null]], null]), [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)))(pair(head([[2, [3, null]], null]), zs)));
[afterMarker] is_null runs

false ? (zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)))([[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]) : $append(tail([[2, [3, null]], null]), [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)))(pair(head([[2, [3, null]], null]), zs)));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

$append(tail([[2, [3, null]], null]), [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)))(pair(head([[2, [3, null]], null]), zs)));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

$append(tail([[2, [3, null]], null]), [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)))(pair(head([[2, [3, null]], null]), zs)));
[beforeMarker] tail runs

$append(null, [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)))(pair(head([[2, [3, null]], null]), zs)));
[afterMarker] tail runs

$append(null, [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)))(pair(head([[2, [3, null]], null]), zs)));
[beforeMarker] $append runs

((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))(null, [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)))(pair(head([[2, [3, null]], null]), zs)));
[afterMarker] $append runs

((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))(null, [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)))(pair(head([[2, [3, null]], null]), zs)));
[beforeMarker] null, [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)))(pair(head([[2, [3, null]], null]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

is_null(null) ? (zs => (zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)))(pair(head([[2, [3, null]], null]), zs)))([[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]) : $append(tail(null), [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)))(pair(head([[2, [3, null]], null]), zs)))(pair(head(null), zs)));
[afterMarker] null, [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)))(pair(head([[2, [3, null]], null]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

is_null(null) ? (zs => (zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)))(pair(head([[2, [3, null]], null]), zs)))([[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]) : $append(tail(null), [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)))(pair(head([[2, [3, null]], null]), zs)))(pair(head(null), zs)));
[beforeMarker] is_null runs

true ? (zs => (zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)))(pair(head([[2, [3, null]], null]), zs)))([[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]) : $append(tail(null), [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)))(pair(head([[2, [3, null]], null]), zs)))(pair(head(null), zs)));
[afterMarker] is_null runs

true ? (zs => (zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)))(pair(head([[2, [3, null]], null]), zs)))([[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]) : $append(tail(null), [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]], zs => (zs => (zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)))(pair(head([[2, [3, null]], null]), zs)))(pair(head(null), zs)));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

(zs => (zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)))(pair(head([[2, [3, null]], null]), zs)))([[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]);
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

(zs => (zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)))(pair(head([[2, [3, null]], null]), zs)))([[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]);
[beforeMarker] [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]] substituted into zs of zs => (zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)))(pair(head([[2, [3, null]], null]), zs))

(zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)))(pair(head([[2, [3, null]], null]), [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]));
[afterMarker] [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]] substituted into zs of zs => (zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)))(pair(head([[2, [3, null]], null]), zs))

(zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)))(pair(head([[2, [3, null]], null]), [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]));
[beforeMarker] head runs

(zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)))(pair([2, [3, null]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]));
[afterMarker] head runs

(zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)))(pair([2, [3, null]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]));
[beforeMarker] pair runs

(zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)))([[2, [3, null]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]]);
[afterMarker] pair runs

(zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs)))([[2, [3, null]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]]);
[beforeMarker] [[2, [3, null]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]] substituted into zs of zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs))

(zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), [[2, [3, null]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]]));
[afterMarker] [[2, [3, null]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]] substituted into zs of zs => (zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), zs))

(zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair(head([[2, null], [[2, [3, null]], null]]), [[2, [3, null]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]]));
[beforeMarker] head runs

(zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair([2, null], [[2, [3, null]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]]));
[afterMarker] head runs

(zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))(pair([2, null], [[2, [3, null]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]]));
[beforeMarker] pair runs

(zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))([[2, null], [[2, [3, null]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]]]);
[afterMarker] pair runs

(zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs)))([[2, null], [[2, [3, null]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]]]);
[beforeMarker] [[2, null], [[2, [3, null]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]]] substituted into zs of zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs))

(zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), [[2, null], [[2, [3, null]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]]]));
[afterMarker] [[2, null], [[2, [3, null]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]]] substituted into zs of zs => (zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), zs))

(zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair(head([[3, null], [[2, null], [[2, [3, null]], null]]]), [[2, null], [[2, [3, null]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]]]));
[beforeMarker] head runs

(zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair([3, null], [[2, null], [[2, [3, null]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]]]));
[afterMarker] head runs

(zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))(pair([3, null], [[2, null], [[2, [3, null]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]]]));
[beforeMarker] pair runs

(zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))([[3, null], [[2, null], [[2, [3, null]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]]]]);
[afterMarker] pair runs

(zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs)))([[3, null], [[2, null], [[2, [3, null]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]]]]);
[beforeMarker] [[3, null], [[2, null], [[2, [3, null]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]]]] substituted into zs of zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs))

(xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), [[3, null], [[2, null], [[2, [3, null]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]]]]));
[afterMarker] [[3, null], [[2, null], [[2, [3, null]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]]]] substituted into zs of zs => (xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), zs))

(xs => xs)(pair(head([null, [[3, null], [[2, null], [[2, [3, null]], null]]]]), [[3, null], [[2, null], [[2, [3, null]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]]]]));
[beforeMarker] head runs

(xs => xs)(pair(null, [[3, null], [[2, null], [[2, [3, null]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]]]]));
[afterMarker] head runs

(xs => xs)(pair(null, [[3, null], [[2, null], [[2, [3, null]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]]]]));
[beforeMarker] pair runs

(xs => xs)([null, [[3, null], [[2, null], [[2, [3, null]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]]]]]);
[afterMarker] pair runs

(xs => xs)([null, [[3, null], [[2, null], [[2, [3, null]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]]]]]);
[beforeMarker] [null, [[3, null], [[2, null], [[2, [3, null]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]]]]] substituted into xs of xs => xs

[null, [[3, null], [[2, null], [[2, [3, null]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]]]]];
[afterMarker] [null, [[3, null], [[2, null], [[2, [3, null]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]]]]] substituted into xs of xs => xs

[null, [[3, null], [[2, null], [[2, [3, null]], [[1, null], [[1, [3, null]], [[1, [2, null]], [[1, [2, [3, null]]], null]]]]]]]];
[noMarker] Evaluation complete
"
`;

exports[`Programs Eliminate-constant-declaration test case 1 1`] = `
"const x = 0;
[noMarker] Start of evaluation

const x = 0;
[beforeMarker] Constant x declared and substituted into the rest of block


[afterMarker] Constant x declared and substituted into the rest of block

undefined;
[noMarker] Evaluation complete
"
`;

exports[`Programs Eliminate-constant-declaration test case 2 1`] = `
"1;const x = 0;
[noMarker] Start of evaluation

1;const x = 0;
[beforeMarker] Constant x declared and substituted into the rest of block

1;
[afterMarker] Constant x declared and substituted into the rest of block

1;
[noMarker] Evaluation complete
"
`;

exports[`Programs Eliminate-function-declaration test case 1 1`] = `
"function foo(x) { return 0;}
[noMarker] Start of evaluation

function foo(x) { return 0;}
[beforeMarker] Function foo declared, parameter(s) x required


[afterMarker] Function foo declared, parameter(s) x required

undefined;
[noMarker] Evaluation complete
"
`;

exports[`Programs Eliminate-function-declaration test case 2 1`] = `
"1;function foo(x) { return 0;}
[noMarker] Start of evaluation

1;function foo(x) { return 0;}
[beforeMarker] Function foo declared, parameter(s) x required

1;
[afterMarker] Function foo declared, parameter(s) x required

1;
[noMarker] Evaluation complete
"
`;

exports[`Programs Program-intro test case 1 1`] = `
"1 + 1;
[noMarker] Start of evaluation

1 + 1;
[beforeMarker] Binary expression 1 + 1 evaluated

2;
[afterMarker] Binary expression 1 + 1 evaluated

2;
[noMarker] Evaluation complete
"
`;

exports[`Programs Program-intro test case 2 1`] = `
"1;1 + 1;
[noMarker] Start of evaluation

1;1 + 1;
[beforeMarker] Binary expression 1 + 1 evaluated

1;2;
[afterMarker] Binary expression 1 + 1 evaluated

1;2;
[beforeMarker] 1 finished evaluating

2;
[afterMarker] 1 finished evaluating

2;
[noMarker] Evaluation complete
"
`;

exports[`Programs Program-reduce test case 1`] = `
"1;2;
[noMarker] Start of evaluation

1;2;
[beforeMarker] 1 finished evaluating

2;
[afterMarker] 1 finished evaluating

2;
[noMarker] Evaluation complete
"
`;

exports[`SOURCE 0 (Tests from previous stepper) 1 + math_sin 1`] = `
"1 + math_sin;
[noMarker] Start of evaluation

1 + math_sin;
[noMarker] Evaluation complete
"
`;

exports[`SOURCE 0 (Tests from previous stepper) Even odd mutual 1`] = `
"const odd = n => n === 0 ? false : even(n - 1);const even = n => n === 0 || odd(n - 1);even(1);
[noMarker] Start of evaluation

const odd = n => n === 0 ? false : even(n - 1);const even = n => n === 0 || odd(n - 1);even(1);
[beforeMarker] Constant odd declared and substituted into the rest of block

const even = n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1);even(1);
[afterMarker] Constant odd declared and substituted into the rest of block

const even = n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1);even(1);
[beforeMarker] Constant even declared and substituted into the rest of block

(n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1))(1);
[afterMarker] Constant even declared and substituted into the rest of block

(n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1))(1);
[beforeMarker] 1 substituted into n of n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1)

1 === 0 || (n => n === 0 ? false : (n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1))(n - 1))(1 - 1);
[afterMarker] 1 substituted into n of n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1)

1 === 0 || (n => n === 0 ? false : (n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1))(n - 1))(1 - 1);
[beforeMarker] Binary expression 1 === 0 evaluated

false || (n => n === 0 ? false : (n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1))(n - 1))(1 - 1);
[afterMarker] Binary expression 1 === 0 evaluated

false || (n => n === 0 ? false : (n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1))(n - 1))(1 - 1);
[beforeMarker] OR operation evaluated, left of operator is false, continue evaluating right of operator

(n => n === 0 ? false : (n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1))(n - 1))(1 - 1);
[afterMarker] OR operation evaluated, left of operator is false, continue evaluating right of operator

(n => n === 0 ? false : (n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1))(n - 1))(1 - 1);
[beforeMarker] Binary expression 1 - 1 evaluated

(n => n === 0 ? false : (n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1))(n - 1))(0);
[afterMarker] Binary expression 1 - 1 evaluated

(n => n === 0 ? false : (n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1))(n - 1))(0);
[beforeMarker] 0 substituted into n of n => n === 0 ? false : (n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1))(n - 1)

0 === 0 ? false : (n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1))(0 - 1);
[afterMarker] 0 substituted into n of n => n === 0 ? false : (n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1))(n - 1)

0 === 0 ? false : (n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1))(0 - 1);
[beforeMarker] Binary expression 0 === 0 evaluated

true ? false : (n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1))(0 - 1);
[afterMarker] Binary expression 0 === 0 evaluated

true ? false : (n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1))(0 - 1);
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

false;
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

false;
[noMarker] Evaluation complete
"
`;

exports[`SOURCE 0 (Tests from previous stepper) Infinite recursion 1`] = `
"function f() { return f();}f();
[noMarker] Start of evaluation

function f() { return f();}f();
[beforeMarker] Function f declared, parameter(s)  required

(() => { return f();})();
[afterMarker] Function f declared, parameter(s)  required

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[noMarker] Maximum number of steps exceeded

(() => { return f();})();
[noMarker] Evaluation complete
"
`;

exports[`SOURCE 0 (Tests from previous stepper) expmod 1`] = `
"function is_even(n) { return n % 2 === 0;}function expmod(base, exp, m) { if (exp === 0) { return 1; } else { if (is_even(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } }}expmod(4, 3, 5);
[noMarker] Start of evaluation

function is_even(n) { return n % 2 === 0;}function expmod(base, exp, m) { if (exp === 0) { return 1; } else { if (is_even(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } }}expmod(4, 3, 5);
[beforeMarker] Function is_even declared, parameter(s) n required

function expmod(base, exp, m) { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } }}expmod(4, 3, 5);
[afterMarker] Function is_even declared, parameter(s) n required

function expmod(base, exp, m) { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } }}expmod(4, 3, 5);
[beforeMarker] Function expmod declared, parameter(s) base,exp,m required

((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } }})(4, 3, 5);
[afterMarker] Function expmod declared, parameter(s) base,exp,m required

((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } }})(4, 3, 5);
[beforeMarker] Function expmod, defined as base, exp, m => {...}, takes in base, exp, m as input 4, 3, 5

{ if (3 === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(3)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; } }};
[afterMarker] Function expmod, defined as base, exp, m => {...}, takes in base, exp, m as input 4, 3, 5

{ if (3 === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(3)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; } }};
[beforeMarker] Binary expression 3 === 0 evaluated

{ if (false) { return 1; } else { if ((n => { return n % 2 === 0; })(3)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; } }};
[afterMarker] Binary expression 3 === 0 evaluated

{ if (false) { return 1; } else { if ((n => { return n % 2 === 0; })(3)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; } }};
[beforeMarker] ...

{ { undefined; if ((n => { return n % 2 === 0; })(3)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; } }};
[afterMarker] ...

{ { undefined; if ((n => { return n % 2 === 0; })(3)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; } }};
[beforeMarker] Function is_even, defined as n => {...}, takes in n as input 3

{ { undefined; if (3 % 2 === 0) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; } }};
[afterMarker] Function is_even, defined as n => {...}, takes in n as input 3

{ { undefined; if (3 % 2 === 0) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; } }};
[beforeMarker] Binary expression 3 % 2 evaluated

{ { undefined; if (1 === 0) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; } }};
[afterMarker] Binary expression 3 % 2 evaluated

{ { undefined; if (1 === 0) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; } }};
[beforeMarker] Binary expression 1 === 0 evaluated

{ { undefined; if (false) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; } }};
[afterMarker] Binary expression 1 === 0 evaluated

{ { undefined; if (false) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; } }};
[beforeMarker] ...

{ { undefined; { undefined; return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; } }};
[afterMarker] ...

{ { undefined; { undefined; return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; } }};
[beforeMarker] undefined finished evaluating

{ { undefined; { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; } }};
[afterMarker] undefined finished evaluating

{ { undefined; { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; } }};
[beforeMarker] return 4 * ((base, exp, m) => {
  if (exp === 0) {
    return 1;
  } else {
    if ((n => {
      return n % 2 === 0;
    })(exp)) {
      const to_half = expmod(base, exp / 2, m);
      return to_half * to_half % m;
    } else {
      return base * expmod(base, exp - 1, m) % m;
    }
  }
})(4, 3 - 1, 5) % 5; finished evaluating

{ { undefined; return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; }};
[afterMarker] return 4 * ((base, exp, m) => {
  if (exp === 0) {
    return 1;
  } else {
    if ((n => {
      return n % 2 === 0;
    })(exp)) {
      const to_half = expmod(base, exp / 2, m);
      return to_half * to_half % m;
    } else {
      return base * expmod(base, exp - 1, m) % m;
    }
  }
})(4, 3 - 1, 5) % 5; finished evaluating

{ { undefined; return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; }};
[beforeMarker] undefined finished evaluating

{ { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; }};
[afterMarker] undefined finished evaluating

{ { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; }};
[beforeMarker] return 4 * ((base, exp, m) => {
  if (exp === 0) {
    return 1;
  } else {
    if ((n => {
      return n % 2 === 0;
    })(exp)) {
      const to_half = expmod(base, exp / 2, m);
      return to_half * to_half % m;
    } else {
      return base * expmod(base, exp - 1, m) % m;
    }
  }
})(4, 3 - 1, 5) % 5; finished evaluating

{ return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5;};
[afterMarker] return 4 * ((base, exp, m) => {
  if (exp === 0) {
    return 1;
  } else {
    if ((n => {
      return n % 2 === 0;
    })(exp)) {
      const to_half = expmod(base, exp / 2, m);
      return to_half * to_half % m;
    } else {
      return base * expmod(base, exp - 1, m) % m;
    }
  }
})(4, 3 - 1, 5) % 5; finished evaluating

{ return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5;};
[beforeMarker] 4 * ((base, exp, m) => {
  if (exp === 0) {
    return 1;
  } else {
    if ((n => {
      return n % 2 === 0;
    })(exp)) {
      const to_half = expmod(base, exp / 2, m);
      return to_half * to_half % m;
    } else {
      return base * expmod(base, exp - 1, m) % m;
    }
  }
})(4, 3 - 1, 5) % 5 returned

4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } }})(4, 3 - 1, 5) % 5;
[afterMarker] 4 * ((base, exp, m) => {
  if (exp === 0) {
    return 1;
  } else {
    if ((n => {
      return n % 2 === 0;
    })(exp)) {
      const to_half = expmod(base, exp / 2, m);
      return to_half * to_half % m;
    } else {
      return base * expmod(base, exp - 1, m) % m;
    }
  }
})(4, 3 - 1, 5) % 5 returned

4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } }})(4, 3 - 1, 5) % 5;
[beforeMarker] Binary expression 3 - 1 evaluated

4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } }})(4, 2, 5) % 5;
[afterMarker] Binary expression 3 - 1 evaluated

4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } }})(4, 2, 5) % 5;
[beforeMarker] Function expmod, defined as base, exp, m => {...}, takes in base, exp, m as input 4, 2, 5

4 * { if (2 === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(2)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 - 1, 5) % 5; } }} % 5;
[afterMarker] Function expmod, defined as base, exp, m => {...}, takes in base, exp, m as input 4, 2, 5

4 * { if (2 === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(2)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 - 1, 5) % 5; } }} % 5;
[beforeMarker] Binary expression 2 === 0 evaluated

4 * { if (false) { return 1; } else { if ((n => { return n % 2 === 0; })(2)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 - 1, 5) % 5; } }} % 5;
[afterMarker] Binary expression 2 === 0 evaluated

4 * { if (false) { return 1; } else { if ((n => { return n % 2 === 0; })(2)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 - 1, 5) % 5; } }} % 5;
[beforeMarker] ...

4 * { { undefined; if ((n => { return n % 2 === 0; })(2)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 - 1, 5) % 5; } }} % 5;
[afterMarker] ...

4 * { { undefined; if ((n => { return n % 2 === 0; })(2)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 - 1, 5) % 5; } }} % 5;
[beforeMarker] Function is_even, defined as n => {...}, takes in n as input 2

4 * { { undefined; if (2 % 2 === 0) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 - 1, 5) % 5; } }} % 5;
[afterMarker] Function is_even, defined as n => {...}, takes in n as input 2

4 * { { undefined; if (2 % 2 === 0) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 - 1, 5) % 5; } }} % 5;
[beforeMarker] Binary expression 2 % 2 evaluated

4 * { { undefined; if (0 === 0) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 - 1, 5) % 5; } }} % 5;
[afterMarker] Binary expression 2 % 2 evaluated

4 * { { undefined; if (0 === 0) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 - 1, 5) % 5; } }} % 5;
[beforeMarker] Binary expression 0 === 0 evaluated

4 * { { undefined; if (true) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 - 1, 5) % 5; } }} % 5;
[afterMarker] Binary expression 0 === 0 evaluated

4 * { { undefined; if (true) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 - 1, 5) % 5; } }} % 5;
[beforeMarker] ...

4 * { { undefined; { undefined; const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 / 2, 5); return to_half * to_half % 5; } }} % 5;
[afterMarker] ...

4 * { { undefined; { undefined; const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 / 2, 5); return to_half * to_half % 5; } }} % 5;
[beforeMarker] Binary expression 2 / 2 evaluated

4 * { { undefined; { undefined; const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1, 5); return to_half * to_half % 5; } }} % 5;
[afterMarker] Binary expression 2 / 2 evaluated

4 * { { undefined; { undefined; const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1, 5); return to_half * to_half % 5; } }} % 5;
[beforeMarker] Function expmod, defined as base, exp, m => {...}, takes in base, exp, m as input 4, 1, 5

4 * { { undefined; { undefined; const to_half = { if (1 === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(1)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } } }; return to_half * to_half % 5; } }} % 5;
[afterMarker] Function expmod, defined as base, exp, m => {...}, takes in base, exp, m as input 4, 1, 5

4 * { { undefined; { undefined; const to_half = { if (1 === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(1)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } } }; return to_half * to_half % 5; } }} % 5;
[beforeMarker] Binary expression 1 === 0 evaluated

4 * { { undefined; { undefined; const to_half = { if (false) { return 1; } else { if ((n => { return n % 2 === 0; })(1)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } } }; return to_half * to_half % 5; } }} % 5;
[afterMarker] Binary expression 1 === 0 evaluated

4 * { { undefined; { undefined; const to_half = { if (false) { return 1; } else { if ((n => { return n % 2 === 0; })(1)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } } }; return to_half * to_half % 5; } }} % 5;
[beforeMarker] ...

4 * { { undefined; { undefined; const to_half = { { undefined; if ((n => { return n % 2 === 0; })(1)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } } }; return to_half * to_half % 5; } }} % 5;
[afterMarker] ...

4 * { { undefined; { undefined; const to_half = { { undefined; if ((n => { return n % 2 === 0; })(1)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } } }; return to_half * to_half % 5; } }} % 5;
[beforeMarker] Function is_even, defined as n => {...}, takes in n as input 1

4 * { { undefined; { undefined; const to_half = { { undefined; if (1 % 2 === 0) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } } }; return to_half * to_half % 5; } }} % 5;
[afterMarker] Function is_even, defined as n => {...}, takes in n as input 1

4 * { { undefined; { undefined; const to_half = { { undefined; if (1 % 2 === 0) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } } }; return to_half * to_half % 5; } }} % 5;
[beforeMarker] Binary expression 1 % 2 evaluated

4 * { { undefined; { undefined; const to_half = { { undefined; if (1 === 0) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } } }; return to_half * to_half % 5; } }} % 5;
[afterMarker] Binary expression 1 % 2 evaluated

4 * { { undefined; { undefined; const to_half = { { undefined; if (1 === 0) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } } }; return to_half * to_half % 5; } }} % 5;
[beforeMarker] Binary expression 1 === 0 evaluated

4 * { { undefined; { undefined; const to_half = { { undefined; if (false) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } } }; return to_half * to_half % 5; } }} % 5;
[afterMarker] Binary expression 1 === 0 evaluated

4 * { { undefined; { undefined; const to_half = { { undefined; if (false) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } } }; return to_half * to_half % 5; } }} % 5;
[beforeMarker] ...

4 * { { undefined; { undefined; const to_half = { { undefined; { undefined; return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } } }; return to_half * to_half % 5; } }} % 5;
[afterMarker] ...

4 * { { undefined; { undefined; const to_half = { { undefined; { undefined; return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } } }; return to_half * to_half % 5; } }} % 5;
[beforeMarker] undefined finished evaluating

4 * { { undefined; { undefined; const to_half = { { undefined; { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } } }; return to_half * to_half % 5; } }} % 5;
[afterMarker] undefined finished evaluating

4 * { { undefined; { undefined; const to_half = { { undefined; { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } } }; return to_half * to_half % 5; } }} % 5;
[beforeMarker] return 4 * ((base, exp, m) => {
  if (exp === 0) {
    return 1;
  } else {
    if ((n => {
      return n % 2 === 0;
    })(exp)) {
      const to_half = expmod(base, exp / 2, m);
      return to_half * to_half % m;
    } else {
      return base * expmod(base, exp - 1, m) % m;
    }
  }
})(4, 1 - 1, 5) % 5; finished evaluating

4 * { { undefined; { undefined; const to_half = { { undefined; return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } }; return to_half * to_half % 5; } }} % 5;
[afterMarker] return 4 * ((base, exp, m) => {
  if (exp === 0) {
    return 1;
  } else {
    if ((n => {
      return n % 2 === 0;
    })(exp)) {
      const to_half = expmod(base, exp / 2, m);
      return to_half * to_half % m;
    } else {
      return base * expmod(base, exp - 1, m) % m;
    }
  }
})(4, 1 - 1, 5) % 5; finished evaluating

4 * { { undefined; { undefined; const to_half = { { undefined; return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } }; return to_half * to_half % 5; } }} % 5;
[beforeMarker] undefined finished evaluating

4 * { { undefined; { undefined; const to_half = { { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } }; return to_half * to_half % 5; } }} % 5;
[afterMarker] undefined finished evaluating

4 * { { undefined; { undefined; const to_half = { { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } }; return to_half * to_half % 5; } }} % 5;
[beforeMarker] return 4 * ((base, exp, m) => {
  if (exp === 0) {
    return 1;
  } else {
    if ((n => {
      return n % 2 === 0;
    })(exp)) {
      const to_half = expmod(base, exp / 2, m);
      return to_half * to_half % m;
    } else {
      return base * expmod(base, exp - 1, m) % m;
    }
  }
})(4, 1 - 1, 5) % 5; finished evaluating

4 * { { undefined; { undefined; const to_half = { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; }; return to_half * to_half % 5; } }} % 5;
[afterMarker] return 4 * ((base, exp, m) => {
  if (exp === 0) {
    return 1;
  } else {
    if ((n => {
      return n % 2 === 0;
    })(exp)) {
      const to_half = expmod(base, exp / 2, m);
      return to_half * to_half % m;
    } else {
      return base * expmod(base, exp - 1, m) % m;
    }
  }
})(4, 1 - 1, 5) % 5; finished evaluating

4 * { { undefined; { undefined; const to_half = { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; }; return to_half * to_half % 5; } }} % 5;
[beforeMarker] 4 * ((base, exp, m) => {
  if (exp === 0) {
    return 1;
  } else {
    if ((n => {
      return n % 2 === 0;
    })(exp)) {
      const to_half = expmod(base, exp / 2, m);
      return to_half * to_half % m;
    } else {
      return base * expmod(base, exp - 1, m) % m;
    }
  }
})(4, 1 - 1, 5) % 5 returned

4 * { { undefined; { undefined; const to_half = 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; return to_half * to_half % 5; } }} % 5;
[afterMarker] 4 * ((base, exp, m) => {
  if (exp === 0) {
    return 1;
  } else {
    if ((n => {
      return n % 2 === 0;
    })(exp)) {
      const to_half = expmod(base, exp / 2, m);
      return to_half * to_half % m;
    } else {
      return base * expmod(base, exp - 1, m) % m;
    }
  }
})(4, 1 - 1, 5) % 5 returned

4 * { { undefined; { undefined; const to_half = 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; return to_half * to_half % 5; } }} % 5;
[beforeMarker] Binary expression 1 - 1 evaluated

4 * { { undefined; { undefined; const to_half = 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 0, 5) % 5; return to_half * to_half % 5; } }} % 5;
[afterMarker] Binary expression 1 - 1 evaluated

4 * { { undefined; { undefined; const to_half = 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 0, 5) % 5; return to_half * to_half % 5; } }} % 5;
[beforeMarker] Function expmod, defined as base, exp, m => {...}, takes in base, exp, m as input 4, 0, 5

4 * { { undefined; { undefined; const to_half = 4 * { if (0 === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(0)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 0 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 0 - 1, 5) % 5; } } } % 5; return to_half * to_half % 5; } }} % 5;
[afterMarker] Function expmod, defined as base, exp, m => {...}, takes in base, exp, m as input 4, 0, 5

4 * { { undefined; { undefined; const to_half = 4 * { if (0 === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(0)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 0 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 0 - 1, 5) % 5; } } } % 5; return to_half * to_half % 5; } }} % 5;
[beforeMarker] Binary expression 0 === 0 evaluated

4 * { { undefined; { undefined; const to_half = 4 * { if (true) { return 1; } else { if ((n => { return n % 2 === 0; })(0)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 0 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 0 - 1, 5) % 5; } } } % 5; return to_half * to_half % 5; } }} % 5;
[afterMarker] Binary expression 0 === 0 evaluated

4 * { { undefined; { undefined; const to_half = 4 * { if (true) { return 1; } else { if ((n => { return n % 2 === 0; })(0)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 0 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 0 - 1, 5) % 5; } } } % 5; return to_half * to_half % 5; } }} % 5;
[beforeMarker] ...

4 * { { undefined; { undefined; const to_half = 4 * { { undefined; return 1; } } % 5; return to_half * to_half % 5; } }} % 5;
[afterMarker] ...

4 * { { undefined; { undefined; const to_half = 4 * { { undefined; return 1; } } % 5; return to_half * to_half % 5; } }} % 5;
[beforeMarker] undefined finished evaluating

4 * { { undefined; { undefined; const to_half = 4 * { { return 1; } } % 5; return to_half * to_half % 5; } }} % 5;
[afterMarker] undefined finished evaluating

4 * { { undefined; { undefined; const to_half = 4 * { { return 1; } } % 5; return to_half * to_half % 5; } }} % 5;
[beforeMarker] return 1; finished evaluating

4 * { { undefined; { undefined; const to_half = 4 * { return 1; } % 5; return to_half * to_half % 5; } }} % 5;
[afterMarker] return 1; finished evaluating

4 * { { undefined; { undefined; const to_half = 4 * { return 1; } % 5; return to_half * to_half % 5; } }} % 5;
[beforeMarker] 1 returned

4 * { { undefined; { undefined; const to_half = 4 * 1 % 5; return to_half * to_half % 5; } }} % 5;
[afterMarker] 1 returned

4 * { { undefined; { undefined; const to_half = 4 * 1 % 5; return to_half * to_half % 5; } }} % 5;
[beforeMarker] Binary expression 4 * 1 evaluated

4 * { { undefined; { undefined; const to_half = 4 % 5; return to_half * to_half % 5; } }} % 5;
[afterMarker] Binary expression 4 * 1 evaluated

4 * { { undefined; { undefined; const to_half = 4 % 5; return to_half * to_half % 5; } }} % 5;
[beforeMarker] Binary expression 4 % 5 evaluated

4 * { { undefined; { undefined; const to_half = 4; return to_half * to_half % 5; } }} % 5;
[afterMarker] Binary expression 4 % 5 evaluated

4 * { { undefined; { undefined; const to_half = 4; return to_half * to_half % 5; } }} % 5;
[beforeMarker] Constant to_half declared and substituted into the rest of block

4 * { { undefined; { undefined; return 4 * 4 % 5; } }} % 5;
[afterMarker] Constant to_half declared and substituted into the rest of block

4 * { { undefined; { undefined; return 4 * 4 % 5; } }} % 5;
[beforeMarker] undefined finished evaluating

4 * { { undefined; { return 4 * 4 % 5; } }} % 5;
[afterMarker] undefined finished evaluating

4 * { { undefined; { return 4 * 4 % 5; } }} % 5;
[beforeMarker] return 4 * 4 % 5; finished evaluating

4 * { { undefined; return 4 * 4 % 5; }} % 5;
[afterMarker] return 4 * 4 % 5; finished evaluating

4 * { { undefined; return 4 * 4 % 5; }} % 5;
[beforeMarker] undefined finished evaluating

4 * { { return 4 * 4 % 5; }} % 5;
[afterMarker] undefined finished evaluating

4 * { { return 4 * 4 % 5; }} % 5;
[beforeMarker] return 4 * 4 % 5; finished evaluating

4 * { return 4 * 4 % 5;} % 5;
[afterMarker] return 4 * 4 % 5; finished evaluating

4 * { return 4 * 4 % 5;} % 5;
[beforeMarker] 4 * 4 % 5 returned

4 * (4 * 4 % 5) % 5;
[afterMarker] 4 * 4 % 5 returned

4 * (4 * 4 % 5) % 5;
[beforeMarker] Binary expression 4 * 4 evaluated

4 * (16 % 5) % 5;
[afterMarker] Binary expression 4 * 4 evaluated

4 * (16 % 5) % 5;
[beforeMarker] Binary expression 16 % 5 evaluated

4 * 1 % 5;
[afterMarker] Binary expression 16 % 5 evaluated

4 * 1 % 5;
[beforeMarker] Binary expression 4 * 1 evaluated

4 % 5;
[afterMarker] Binary expression 4 * 1 evaluated

4 % 5;
[beforeMarker] Binary expression 4 % 5 evaluated

4;
[afterMarker] Binary expression 4 % 5 evaluated

4;
[noMarker] Evaluation complete
"
`;

exports[`SOURCE 0 (Tests from previous stepper) math_pow 1`] = `
"math_pow(2, 20) || NaN;
[noMarker] Start of evaluation

math_pow(2, 20) || NaN;
[beforeMarker] math_pow runs

1048576 || NaN;
[afterMarker] math_pow runs

1048576 || NaN;
[beforeMarker] OR operation evaluated, left of operator is false, continue evaluating right of operator

true;
[afterMarker] OR operation evaluated, left of operator is false, continue evaluating right of operator

true;
[noMarker] Evaluation complete
"
`;

exports[`SOURCE 0 (Tests from previous stepper) plus undefined 1`] = `
"math_sin(1) + undefined;
[noMarker] Start of evaluation

math_sin(1) + undefined;
[beforeMarker] math_sin runs

0.8414709848078965 + undefined;
[afterMarker] math_sin runs

0.8414709848078965 + undefined;
[noMarker] Evaluation complete
"
`;

exports[`SOURCE 0 (Tests from previous stepper) undefined || 1 1`] = `
"undefined || 1;
[noMarker] Start of evaluation

undefined || 1;
[noMarker] Evaluation complete
"
`;

exports[`Statements: Blocks Block-statement-empty-reduce test case 1 1`] = `
"{}
[noMarker] Start of evaluation

{}
[beforeMarker] Empty block expression evaluated


[afterMarker] Empty block expression evaluated

undefined;
[noMarker] Evaluation complete
"
`;

exports[`Statements: Blocks Block-statement-empty-reduce test case 2 1`] = `
"{ { {} {} } { {} {} }}
[noMarker] Start of evaluation

{ { {} {} } { {} {} }}
[beforeMarker] Empty block expression evaluated

{ { {} } { {} {} }}
[afterMarker] Empty block expression evaluated

{ { {} } { {} {} }}
[beforeMarker] Empty block expression evaluated

{ {} { {} {} }}
[afterMarker] Empty block expression evaluated

{ {} { {} {} }}
[beforeMarker] Empty block expression evaluated

{ { {} {} }}
[afterMarker] Empty block expression evaluated

{ { {} {} }}
[beforeMarker] {
  {}
  {}
} finished evaluating

{ {} {}}
[afterMarker] {
  {}
  {}
} finished evaluating

{ {} {}}
[beforeMarker] Empty block expression evaluated

{ {}}
[afterMarker] Empty block expression evaluated

{ {}}
[beforeMarker] Empty block expression evaluated

{}
[afterMarker] Empty block expression evaluated

{}
[beforeMarker] Empty block expression evaluated


[afterMarker] Empty block expression evaluated

undefined;
[noMarker] Evaluation complete
"
`;

exports[`Statements: Blocks Block-statement-intro test case 1`] = `
"{ 1 + 1;}
[noMarker] Start of evaluation

{ 1 + 1;}
[beforeMarker] Binary expression 1 + 1 evaluated

{ 2;}
[afterMarker] Binary expression 1 + 1 evaluated

{ 2;}
[beforeMarker] 2; finished evaluating

2;
[afterMarker] 2; finished evaluating

2;
[noMarker] Evaluation complete
"
`;

exports[`Statements: Blocks Block-statement-single-reduce test case 1`] = `
"{ 1;}
[noMarker] Start of evaluation

{ 1;}
[beforeMarker] 1; finished evaluating

1;
[afterMarker] 1; finished evaluating

1;
[noMarker] Evaluation complete
"
`;

exports[`Statements: Conditionals Conditional-statement-alternative test case 1`] = `
"if (false) { 1;} else { 2;}
[noMarker] Start of evaluation

if (false) { 1;} else { 2;}
[beforeMarker] ...

{ undefined; 2;}
[afterMarker] ...

{ undefined; 2;}
[beforeMarker] undefined finished evaluating

{ 2;}
[afterMarker] undefined finished evaluating

{ 2;}
[beforeMarker] 2; finished evaluating

2;
[afterMarker] 2; finished evaluating

2;
[noMarker] Evaluation complete
"
`;

exports[`Statements: Conditionals Conditional-statement-blockexpr-alternative test case 1 1`] = `
"function foo(x) { if (false) { 1; } else { 2; }}foo(0);
[noMarker] Start of evaluation

function foo(x) { if (false) { 1; } else { 2; }}foo(0);
[beforeMarker] Function foo declared, parameter(s) x required

(x => { if (false) { 1; } else { 2; }})(0);
[afterMarker] Function foo declared, parameter(s) x required

(x => { if (false) { 1; } else { 2; }})(0);
[beforeMarker] Function foo, defined as x => {...}, takes in x as input 0

{ if (false) { 1; } else { 2; }};
[afterMarker] Function foo, defined as x => {...}, takes in x as input 0

{ if (false) { 1; } else { 2; }};
[beforeMarker] ...

{ { undefined; 2; }};
[afterMarker] ...

{ { undefined; 2; }};
[beforeMarker] undefined finished evaluating

{ { 2; }};
[afterMarker] undefined finished evaluating

{ { 2; }};
[beforeMarker] 2; finished evaluating

{ 2;};
[afterMarker] 2; finished evaluating

{ 2;};
[beforeMarker] 2; finished evaluating

undefined;
[afterMarker] 2; finished evaluating

undefined;
[noMarker] Evaluation complete
"
`;

exports[`Statements: Conditionals Conditional-statement-blockexpr-alternative test case 2 1`] = `
"function foo(x) { 3; if (false) { 1; } else { 2; }}foo(0);
[noMarker] Start of evaluation

function foo(x) { 3; if (false) { 1; } else { 2; }}foo(0);
[beforeMarker] Function foo declared, parameter(s) x required

(x => { 3; if (false) { 1; } else { 2; }})(0);
[afterMarker] Function foo declared, parameter(s) x required

(x => { 3; if (false) { 1; } else { 2; }})(0);
[beforeMarker] Function foo, defined as x => {...}, takes in x as input 0

{ 3; if (false) { 1; } else { 2; }};
[afterMarker] Function foo, defined as x => {...}, takes in x as input 0

{ 3; if (false) { 1; } else { 2; }};
[beforeMarker] ...

{ 3; { undefined; 2; }};
[afterMarker] ...

{ 3; { undefined; 2; }};
[beforeMarker] undefined finished evaluating

{ 3; { 2; }};
[afterMarker] undefined finished evaluating

{ 3; { 2; }};
[beforeMarker] 2; finished evaluating

{ 3; 2;};
[afterMarker] 2; finished evaluating

{ 3; 2;};
[beforeMarker] 3 finished evaluating

{ 2;};
[afterMarker] 3 finished evaluating

{ 2;};
[beforeMarker] 2; finished evaluating

undefined;
[afterMarker] 2; finished evaluating

undefined;
[noMarker] Evaluation complete
"
`;

exports[`Statements: Conditionals Conditional-statement-blockexpr-consequent test case 1 1`] = `
"function foo(x) { if (true) { 1; } else { 2; }}foo(0);
[noMarker] Start of evaluation

function foo(x) { if (true) { 1; } else { 2; }}foo(0);
[beforeMarker] Function foo declared, parameter(s) x required

(x => { if (true) { 1; } else { 2; }})(0);
[afterMarker] Function foo declared, parameter(s) x required

(x => { if (true) { 1; } else { 2; }})(0);
[beforeMarker] Function foo, defined as x => {...}, takes in x as input 0

{ if (true) { 1; } else { 2; }};
[afterMarker] Function foo, defined as x => {...}, takes in x as input 0

{ if (true) { 1; } else { 2; }};
[beforeMarker] ...

{ { undefined; 1; }};
[afterMarker] ...

{ { undefined; 1; }};
[beforeMarker] undefined finished evaluating

{ { 1; }};
[afterMarker] undefined finished evaluating

{ { 1; }};
[beforeMarker] 1; finished evaluating

{ 1;};
[afterMarker] 1; finished evaluating

{ 1;};
[beforeMarker] 1; finished evaluating

undefined;
[afterMarker] 1; finished evaluating

undefined;
[noMarker] Evaluation complete
"
`;

exports[`Statements: Conditionals Conditional-statement-blockexpr-consequent test case 2 1`] = `
"function foo(x) { 3; if (true) { 1; } else { 2; }}foo(0);
[noMarker] Start of evaluation

function foo(x) { 3; if (true) { 1; } else { 2; }}foo(0);
[beforeMarker] Function foo declared, parameter(s) x required

(x => { 3; if (true) { 1; } else { 2; }})(0);
[afterMarker] Function foo declared, parameter(s) x required

(x => { 3; if (true) { 1; } else { 2; }})(0);
[beforeMarker] Function foo, defined as x => {...}, takes in x as input 0

{ 3; if (true) { 1; } else { 2; }};
[afterMarker] Function foo, defined as x => {...}, takes in x as input 0

{ 3; if (true) { 1; } else { 2; }};
[beforeMarker] ...

{ 3; { undefined; 1; }};
[afterMarker] ...

{ 3; { undefined; 1; }};
[beforeMarker] undefined finished evaluating

{ 3; { 1; }};
[afterMarker] undefined finished evaluating

{ 3; { 1; }};
[beforeMarker] 1; finished evaluating

{ 3; 1;};
[afterMarker] 1; finished evaluating

{ 3; 1;};
[beforeMarker] 3 finished evaluating

{ 1;};
[afterMarker] 3 finished evaluating

{ 1;};
[beforeMarker] 1; finished evaluating

undefined;
[afterMarker] 1; finished evaluating

undefined;
[noMarker] Evaluation complete
"
`;

exports[`Statements: Conditionals Conditional-statement-consequent test case 1`] = `
"if (true) { 1;} else { 2;}
[noMarker] Start of evaluation

if (true) { 1;} else { 2;}
[beforeMarker] ...

{ undefined; 1;}
[afterMarker] ...

{ undefined; 1;}
[beforeMarker] undefined finished evaluating

{ 1;}
[afterMarker] undefined finished evaluating

{ 1;}
[beforeMarker] 1; finished evaluating

1;
[afterMarker] 1; finished evaluating

1;
[noMarker] Evaluation complete
"
`;

exports[`Statements: Conditionals Conditional-statement-predicate test case 1`] = `
"if (1 + 2 + 3 === 1) {} else {}
[noMarker] Start of evaluation

if (1 + 2 + 3 === 1) {} else {}
[beforeMarker] Binary expression 1 + 2 evaluated

if (3 + 3 === 1) {} else {}
[afterMarker] Binary expression 1 + 2 evaluated

if (3 + 3 === 1) {} else {}
[beforeMarker] Binary expression 3 + 3 evaluated

if (6 === 1) {} else {}
[afterMarker] Binary expression 3 + 3 evaluated

if (6 === 1) {} else {}
[beforeMarker] Binary expression 6 === 1 evaluated

if (false) {} else {}
[afterMarker] Binary expression 6 === 1 evaluated

if (false) {} else {}
[beforeMarker] ...

{ undefined;}
[afterMarker] ...

{ undefined;}
[beforeMarker] undefined; finished evaluating

undefined;
[afterMarker] undefined; finished evaluating

undefined;
[noMarker] Evaluation complete
"
`;

exports[`Statements: Constant declarations Evaluate-constant-declaration test case 1`] = `
"const x = 1 + 2 + 3;
[noMarker] Start of evaluation

const x = 1 + 2 + 3;
[beforeMarker] Binary expression 1 + 2 evaluated

const x = 3 + 3;
[afterMarker] Binary expression 1 + 2 evaluated

const x = 3 + 3;
[beforeMarker] Binary expression 3 + 3 evaluated

const x = 6;
[afterMarker] Binary expression 3 + 3 evaluated

const x = 6;
[beforeMarker] Constant x declared and substituted into the rest of block


[afterMarker] Constant x declared and substituted into the rest of block

undefined;
[noMarker] Evaluation complete
"
`;

exports[`Statements: Expression statements Expression-statement-reduce test case 1`] = `
"1 + 2 + 3;
[noMarker] Start of evaluation

1 + 2 + 3;
[beforeMarker] Binary expression 1 + 2 evaluated

3 + 3;
[afterMarker] Binary expression 1 + 2 evaluated

3 + 3;
[beforeMarker] Binary expression 3 + 3 evaluated

6;
[afterMarker] Binary expression 3 + 3 evaluated

6;
[noMarker] Evaluation complete
"
`;

exports[`Test constant declaration substitution 1`] = `
"const x = -1;x;const y = 2;y;
[noMarker] Start of evaluation

const x = -1;x;const y = 2;y;
[beforeMarker] Constant x declared and substituted into the rest of block

-1;const y = 2;y;
[afterMarker] Constant x declared and substituted into the rest of block

-1;const y = 2;y;
[beforeMarker] Constant y declared and substituted into the rest of block

-1;2;
[afterMarker] Constant y declared and substituted into the rest of block

-1;2;
[beforeMarker] -1 finished evaluating

2;
[afterMarker] -1 finished evaluating

2;
[noMarker] Evaluation complete
"
`;

exports[`Test two statements 1`] = `
"(1 + 2) * (3 + 4);3 * 5;
[noMarker] Start of evaluation

(1 + 2) * (3 + 4);3 * 5;
[beforeMarker] Binary expression 1 + 2 evaluated

3 * (3 + 4);3 * 5;
[afterMarker] Binary expression 1 + 2 evaluated

3 * (3 + 4);3 * 5;
[beforeMarker] Binary expression 3 + 4 evaluated

3 * 7;3 * 5;
[afterMarker] Binary expression 3 + 4 evaluated

3 * 7;3 * 5;
[beforeMarker] Binary expression 3 * 7 evaluated

21;3 * 5;
[afterMarker] Binary expression 3 * 7 evaluated

21;3 * 5;
[beforeMarker] Binary expression 3 * 5 evaluated

21;15;
[afterMarker] Binary expression 3 * 5 evaluated

21;15;
[beforeMarker] 21 finished evaluating

15;
[afterMarker] 21 finished evaluating

15;
[noMarker] Evaluation complete
"
`;

exports[`const declarations in blocks subst into call expressions 1`] = `
"const z = 1;function f(g) { const z = 3; return (y => z + z)(z);}f(undefined);
[noMarker] Start of evaluation

const z = 1;function f(g) { const z = 3; return (y => z + z)(z);}f(undefined);
[beforeMarker] Constant z declared and substituted into the rest of block

function f(g) { const z = 3; return (y => z + z)(z);}f(undefined);
[afterMarker] Constant z declared and substituted into the rest of block

function f(g) { const z = 3; return (y => z + z)(z);}f(undefined);
[beforeMarker] Function f declared, parameter(s) g required

(g => { const z = 3; return (y => z + z)(z);})(undefined);
[afterMarker] Function f declared, parameter(s) g required

(g => { const z = 3; return (y => z + z)(z);})(undefined);
[beforeMarker] Function f, defined as g => {...}, takes in g as input undefined

{ const z = 3; return (y => z + z)(z);};
[afterMarker] Function f, defined as g => {...}, takes in g as input undefined

{ const z = 3; return (y => z + z)(z);};
[beforeMarker] Constant z declared and substituted into the rest of block

{ return (y => 3 + 3)(3);};
[afterMarker] Constant z declared and substituted into the rest of block

{ return (y => 3 + 3)(3);};
[beforeMarker] (y => 3 + 3)(3) returned

(y => 3 + 3)(3);
[afterMarker] (y => 3 + 3)(3) returned

(y => 3 + 3)(3);
[beforeMarker] 3 substituted into y of y => 3 + 3

3 + 3;
[afterMarker] 3 substituted into y of y => 3 + 3

3 + 3;
[beforeMarker] Binary expression 3 + 3 evaluated

6;
[afterMarker] Binary expression 3 + 3 evaluated

6;
[noMarker] Evaluation complete
"
`;

exports[`constant declarations in blocks are protected 1`] = `
"const z = 1;function f(g) { const z = 3; return g(z);}f(y => y + z);
[noMarker] Start of evaluation

const z = 1;function f(g) { const z = 3; return g(z);}f(y => y + z);
[beforeMarker] Constant z declared and substituted into the rest of block

function f(g) { const z = 3; return g(z);}f(y => y + 1);
[afterMarker] Constant z declared and substituted into the rest of block

function f(g) { const z = 3; return g(z);}f(y => y + 1);
[beforeMarker] Function f declared, parameter(s) g required

(g => { const z = 3; return g(z);})(y => y + 1);
[afterMarker] Function f declared, parameter(s) g required

(g => { const z = 3; return g(z);})(y => y + 1);
[beforeMarker] Function f, defined as g => {...}, takes in g as input y => y + 1

{ const z = 3; return (y => y + 1)(z);};
[afterMarker] Function f, defined as g => {...}, takes in g as input y => y + 1

{ const z = 3; return (y => y + 1)(z);};
[beforeMarker] Constant z declared and substituted into the rest of block

{ return (y => y + 1)(3);};
[afterMarker] Constant z declared and substituted into the rest of block

{ return (y => y + 1)(3);};
[beforeMarker] (y => y + 1)(3) returned

(y => y + 1)(3);
[afterMarker] (y => y + 1)(3) returned

(y => y + 1)(3);
[beforeMarker] 3 substituted into y of y => y + 1

3 + 1;
[afterMarker] 3 substituted into y of y => y + 1

3 + 1;
[beforeMarker] Binary expression 3 + 1 evaluated

4;
[afterMarker] Binary expression 3 + 1 evaluated

4;
[noMarker] Evaluation complete
"
`;

exports[`function declarations in blocks are protected 1`] = `
"function repeat_pattern(n, p, r) { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);}function plus_one(x) { return x + 1;}repeat_pattern(5, plus_one, 0);
[noMarker] Start of evaluation

function repeat_pattern(n, p, r) { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);}function plus_one(x) { return x + 1;}repeat_pattern(5, plus_one, 0);
[beforeMarker] Function repeat_pattern declared, parameter(s) n,p,r required

function plus_one(x) { return x + 1;}((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5, plus_one, 0);
[afterMarker] Function repeat_pattern declared, parameter(s) n,p,r required

function plus_one(x) { return x + 1;}((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5, plus_one, 0);
[beforeMarker] Function plus_one declared, parameter(s) x required

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5, x => { return x + 1;}, 0);
[afterMarker] Function plus_one declared, parameter(s) x required

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5, x => { return x + 1;}, 0);
[beforeMarker] Function repeat_pattern, defined as n, p, r => {...}, takes in n, p, r as input 5, x => {
  return x + 1;
}, 0

{ function twice_p(r) { return (x => { return x + 1; })((x => { return x + 1; })(r)); } return 5 === 0 ? 0 : 5 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(5 - 1, x => { return x + 1; }, (x => { return x + 1; })(0)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(5 / 2, twice_p, 0);};
[afterMarker] Function repeat_pattern, defined as n, p, r => {...}, takes in n, p, r as input 5, x => {
  return x + 1;
}, 0

{ function twice_p(r) { return (x => { return x + 1; })((x => { return x + 1; })(r)); } return 5 === 0 ? 0 : 5 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(5 - 1, x => { return x + 1; }, (x => { return x + 1; })(0)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(5 / 2, twice_p, 0);};
[beforeMarker] Function twice_p declared, parameter(s) r required

{ return 5 === 0 ? 0 : 5 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(5 - 1, x => { return x + 1; }, (x => { return x + 1; })(0)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(5 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); }, 0);};
[afterMarker] Function twice_p declared, parameter(s) r required

{ return 5 === 0 ? 0 : 5 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(5 - 1, x => { return x + 1; }, (x => { return x + 1; })(0)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(5 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); }, 0);};
[beforeMarker] 5 === 0 ? 0 : 5 % 2 !== 0 ? ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(5 - 1, x => {
  return x + 1;
}, (x => {
  return x + 1;
})(0)) : ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(5 / 2, r => {
  return (x => {
    return x + 1;
  })((x => {
    return x + 1;
  })(r));
}, 0) returned

5 === 0 ? 0 : 5 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 - 1, x => { return x + 1;}, (x => { return x + 1;})(0)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 0);
[afterMarker] 5 === 0 ? 0 : 5 % 2 !== 0 ? ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(5 - 1, x => {
  return x + 1;
}, (x => {
  return x + 1;
})(0)) : ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(5 / 2, r => {
  return (x => {
    return x + 1;
  })((x => {
    return x + 1;
  })(r));
}, 0) returned

5 === 0 ? 0 : 5 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 - 1, x => { return x + 1;}, (x => { return x + 1;})(0)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 0);
[beforeMarker] Binary expression 5 === 0 evaluated

false ? 0 : 5 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 - 1, x => { return x + 1;}, (x => { return x + 1;})(0)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 0);
[afterMarker] Binary expression 5 === 0 evaluated

false ? 0 : 5 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 - 1, x => { return x + 1;}, (x => { return x + 1;})(0)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 0);
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

5 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 - 1, x => { return x + 1;}, (x => { return x + 1;})(0)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 0);
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

5 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 - 1, x => { return x + 1;}, (x => { return x + 1;})(0)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 0);
[beforeMarker] Binary expression 5 % 2 evaluated

1 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 - 1, x => { return x + 1;}, (x => { return x + 1;})(0)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 0);
[afterMarker] Binary expression 5 % 2 evaluated

1 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 - 1, x => { return x + 1;}, (x => { return x + 1;})(0)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 0);
[beforeMarker] Binary expression 1 !== 0 evaluated

true ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 - 1, x => { return x + 1;}, (x => { return x + 1;})(0)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 0);
[afterMarker] Binary expression 1 !== 0 evaluated

true ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 - 1, x => { return x + 1;}, (x => { return x + 1;})(0)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 0);
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 - 1, x => { return x + 1;}, (x => { return x + 1;})(0));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 - 1, x => { return x + 1;}, (x => { return x + 1;})(0));
[beforeMarker] Binary expression 5 - 1 evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4, x => { return x + 1;}, (x => { return x + 1;})(0));
[afterMarker] Binary expression 5 - 1 evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4, x => { return x + 1;}, (x => { return x + 1;})(0));
[beforeMarker] Function plus_one, defined as x => {...}, takes in x as input 0

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4, x => { return x + 1;}, 0 + 1);
[afterMarker] Function plus_one, defined as x => {...}, takes in x as input 0

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4, x => { return x + 1;}, 0 + 1);
[beforeMarker] Binary expression 0 + 1 evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4, x => { return x + 1;}, 1);
[afterMarker] Binary expression 0 + 1 evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4, x => { return x + 1;}, 1);
[beforeMarker] Function repeat_pattern, defined as n, p, r => {...}, takes in n, p, r as input 4, x => {
  return x + 1;
}, 1

{ function twice_p(r) { return (x => { return x + 1; })((x => { return x + 1; })(r)); } return 4 === 0 ? 1 : 4 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(4 - 1, x => { return x + 1; }, (x => { return x + 1; })(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(4 / 2, twice_p, 1);};
[afterMarker] Function repeat_pattern, defined as n, p, r => {...}, takes in n, p, r as input 4, x => {
  return x + 1;
}, 1

{ function twice_p(r) { return (x => { return x + 1; })((x => { return x + 1; })(r)); } return 4 === 0 ? 1 : 4 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(4 - 1, x => { return x + 1; }, (x => { return x + 1; })(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(4 / 2, twice_p, 1);};
[beforeMarker] Function twice_p declared, parameter(s) r required

{ return 4 === 0 ? 1 : 4 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(4 - 1, x => { return x + 1; }, (x => { return x + 1; })(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(4 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); }, 1);};
[afterMarker] Function twice_p declared, parameter(s) r required

{ return 4 === 0 ? 1 : 4 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(4 - 1, x => { return x + 1; }, (x => { return x + 1; })(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(4 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); }, 1);};
[beforeMarker] 4 === 0 ? 1 : 4 % 2 !== 0 ? ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(4 - 1, x => {
  return x + 1;
}, (x => {
  return x + 1;
})(1)) : ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(4 / 2, r => {
  return (x => {
    return x + 1;
  })((x => {
    return x + 1;
  })(r));
}, 1) returned

4 === 0 ? 1 : 4 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 - 1, x => { return x + 1;}, (x => { return x + 1;})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 1);
[afterMarker] 4 === 0 ? 1 : 4 % 2 !== 0 ? ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(4 - 1, x => {
  return x + 1;
}, (x => {
  return x + 1;
})(1)) : ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(4 / 2, r => {
  return (x => {
    return x + 1;
  })((x => {
    return x + 1;
  })(r));
}, 1) returned

4 === 0 ? 1 : 4 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 - 1, x => { return x + 1;}, (x => { return x + 1;})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 1);
[beforeMarker] Binary expression 4 === 0 evaluated

false ? 1 : 4 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 - 1, x => { return x + 1;}, (x => { return x + 1;})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 1);
[afterMarker] Binary expression 4 === 0 evaluated

false ? 1 : 4 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 - 1, x => { return x + 1;}, (x => { return x + 1;})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 1);
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

4 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 - 1, x => { return x + 1;}, (x => { return x + 1;})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 1);
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

4 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 - 1, x => { return x + 1;}, (x => { return x + 1;})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 1);
[beforeMarker] Binary expression 4 % 2 evaluated

0 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 - 1, x => { return x + 1;}, (x => { return x + 1;})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 1);
[afterMarker] Binary expression 4 % 2 evaluated

0 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 - 1, x => { return x + 1;}, (x => { return x + 1;})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 1);
[beforeMarker] Binary expression 0 !== 0 evaluated

false ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 - 1, x => { return x + 1;}, (x => { return x + 1;})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 1);
[afterMarker] Binary expression 0 !== 0 evaluated

false ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 - 1, x => { return x + 1;}, (x => { return x + 1;})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 1);
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 1);
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 1);
[beforeMarker] Binary expression 4 / 2 evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 1);
[afterMarker] Binary expression 4 / 2 evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 1);
[beforeMarker] Function repeat_pattern, defined as n, p, r => {...}, takes in n, p, r as input 2, r => {
  return (x => {
    return x + 1;
  })((x => {
    return x + 1;
  })(r));
}, 1

{ function twice_p(r) { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); } return 2 === 0 ? 1 : 2 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(2 - 1, r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); }, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(2 / 2, twice_p, 1);};
[afterMarker] Function repeat_pattern, defined as n, p, r => {...}, takes in n, p, r as input 2, r => {
  return (x => {
    return x + 1;
  })((x => {
    return x + 1;
  })(r));
}, 1

{ function twice_p(r) { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); } return 2 === 0 ? 1 : 2 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(2 - 1, r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); }, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(2 / 2, twice_p, 1);};
[beforeMarker] Function twice_p declared, parameter(s) r required

{ return 2 === 0 ? 1 : 2 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(2 - 1, r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); }, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(2 / 2, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); }, 1);};
[afterMarker] Function twice_p declared, parameter(s) r required

{ return 2 === 0 ? 1 : 2 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(2 - 1, r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); }, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(2 / 2, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); }, 1);};
[beforeMarker] 2 === 0 ? 1 : 2 % 2 !== 0 ? ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(2 - 1, r => {
  return (x => {
    return x + 1;
  })((x => {
    return x + 1;
  })(r));
}, (r => {
  return (x => {
    return x + 1;
  })((x => {
    return x + 1;
  })(r));
})(1)) : ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(2 / 2, r => {
  return (r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })((r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })(r));
}, 1) returned

2 === 0 ? 1 : 2 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 - 1, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 / 2, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, 1);
[afterMarker] 2 === 0 ? 1 : 2 % 2 !== 0 ? ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(2 - 1, r => {
  return (x => {
    return x + 1;
  })((x => {
    return x + 1;
  })(r));
}, (r => {
  return (x => {
    return x + 1;
  })((x => {
    return x + 1;
  })(r));
})(1)) : ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(2 / 2, r => {
  return (r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })((r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })(r));
}, 1) returned

2 === 0 ? 1 : 2 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 - 1, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 / 2, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, 1);
[beforeMarker] Binary expression 2 === 0 evaluated

false ? 1 : 2 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 - 1, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 / 2, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, 1);
[afterMarker] Binary expression 2 === 0 evaluated

false ? 1 : 2 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 - 1, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 / 2, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, 1);
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

2 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 - 1, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 / 2, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, 1);
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

2 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 - 1, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 / 2, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, 1);
[beforeMarker] Binary expression 2 % 2 evaluated

0 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 - 1, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 / 2, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, 1);
[afterMarker] Binary expression 2 % 2 evaluated

0 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 - 1, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 / 2, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, 1);
[beforeMarker] Binary expression 0 !== 0 evaluated

false ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 - 1, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 / 2, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, 1);
[afterMarker] Binary expression 0 !== 0 evaluated

false ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 - 1, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 / 2, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, 1);
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 / 2, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, 1);
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 / 2, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, 1);
[beforeMarker] Binary expression 2 / 2 evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, 1);
[afterMarker] Binary expression 2 / 2 evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, 1);
[beforeMarker] Function repeat_pattern, defined as n, p, r => {...}, takes in n, p, r as input 1, r => {
  return (r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })((r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })(r));
}, 1

{ function twice_p(r) { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r)); } return 1 === 0 ? 1 : 1 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(1 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); }, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(1 / 2, twice_p, 1);};
[afterMarker] Function repeat_pattern, defined as n, p, r => {...}, takes in n, p, r as input 1, r => {
  return (r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })((r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })(r));
}, 1

{ function twice_p(r) { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r)); } return 1 === 0 ? 1 : 1 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(1 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); }, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(1 / 2, twice_p, 1);};
[beforeMarker] Function twice_p declared, parameter(s) r required

{ return 1 === 0 ? 1 : 1 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(1 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); }, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(1 / 2, r => { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r)); }, 1);};
[afterMarker] Function twice_p declared, parameter(s) r required

{ return 1 === 0 ? 1 : 1 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(1 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); }, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(1 / 2, r => { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r)); }, 1);};
[beforeMarker] 1 === 0 ? 1 : 1 % 2 !== 0 ? ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(1 - 1, r => {
  return (r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })((r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })(r));
}, (r => {
  return (r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })((r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })(r));
})(1)) : ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(1 / 2, r => {
  return (r => {
    return (r => {
      return (x => {
        return x + 1;
      })((x => {
        return x + 1;
      })(r));
    })((r => {
      return (x => {
        return x + 1;
      })((x => {
        return x + 1;
      })(r));
    })(r));
  })((r => {
    return (r => {
      return (x => {
        return x + 1;
      })((x => {
        return x + 1;
      })(r));
    })((r => {
      return (x => {
        return x + 1;
      })((x => {
        return x + 1;
      })(r));
    })(r));
  })(r));
}, 1) returned

1 === 0 ? 1 : 1 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 / 2, r => { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r));}, 1);
[afterMarker] 1 === 0 ? 1 : 1 % 2 !== 0 ? ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(1 - 1, r => {
  return (r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })((r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })(r));
}, (r => {
  return (r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })((r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })(r));
})(1)) : ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(1 / 2, r => {
  return (r => {
    return (r => {
      return (x => {
        return x + 1;
      })((x => {
        return x + 1;
      })(r));
    })((r => {
      return (x => {
        return x + 1;
      })((x => {
        return x + 1;
      })(r));
    })(r));
  })((r => {
    return (r => {
      return (x => {
        return x + 1;
      })((x => {
        return x + 1;
      })(r));
    })((r => {
      return (x => {
        return x + 1;
      })((x => {
        return x + 1;
      })(r));
    })(r));
  })(r));
}, 1) returned

1 === 0 ? 1 : 1 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 / 2, r => { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r));}, 1);
[beforeMarker] Binary expression 1 === 0 evaluated

false ? 1 : 1 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 / 2, r => { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r));}, 1);
[afterMarker] Binary expression 1 === 0 evaluated

false ? 1 : 1 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 / 2, r => { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r));}, 1);
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

1 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 / 2, r => { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r));}, 1);
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

1 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 / 2, r => { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r));}, 1);
[beforeMarker] Binary expression 1 % 2 evaluated

1 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 / 2, r => { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r));}, 1);
[afterMarker] Binary expression 1 % 2 evaluated

1 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 / 2, r => { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r));}, 1);
[beforeMarker] Binary expression 1 !== 0 evaluated

true ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 / 2, r => { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r));}, 1);
[afterMarker] Binary expression 1 !== 0 evaluated

true ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 / 2, r => { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r));}, 1);
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));})(1));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));})(1));
[beforeMarker] Binary expression 1 - 1 evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));})(1));
[afterMarker] Binary expression 1 - 1 evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));})(1));
[beforeMarker] Function twice_p, defined as r => {...}, takes in r as input 1

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})((r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})(1)));
[afterMarker] Function twice_p, defined as r => {...}, takes in r as input 1

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})((r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})(1)));
[beforeMarker] Function twice_p, defined as r => {...}, takes in r as input 1

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})((x => { return x + 1;})((x => { return x + 1;})(1))));
[afterMarker] Function twice_p, defined as r => {...}, takes in r as input 1

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})((x => { return x + 1;})((x => { return x + 1;})(1))));
[beforeMarker] Function plus_one, defined as x => {...}, takes in x as input 1

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})((x => { return x + 1;})(1 + 1)));
[afterMarker] Function plus_one, defined as x => {...}, takes in x as input 1

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})((x => { return x + 1;})(1 + 1)));
[beforeMarker] Binary expression 1 + 1 evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})((x => { return x + 1;})(2)));
[afterMarker] Binary expression 1 + 1 evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})((x => { return x + 1;})(2)));
[beforeMarker] Function plus_one, defined as x => {...}, takes in x as input 2

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})(2 + 1));
[afterMarker] Function plus_one, defined as x => {...}, takes in x as input 2

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})(2 + 1));
[beforeMarker] Binary expression 2 + 1 evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})(3));
[afterMarker] Binary expression 2 + 1 evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})(3));
[beforeMarker] Function twice_p, defined as r => {...}, takes in r as input 3

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (x => { return x + 1;})((x => { return x + 1;})(3)));
[afterMarker] Function twice_p, defined as r => {...}, takes in r as input 3

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (x => { return x + 1;})((x => { return x + 1;})(3)));
[beforeMarker] Function plus_one, defined as x => {...}, takes in x as input 3

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (x => { return x + 1;})(3 + 1));
[afterMarker] Function plus_one, defined as x => {...}, takes in x as input 3

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (x => { return x + 1;})(3 + 1));
[beforeMarker] Binary expression 3 + 1 evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (x => { return x + 1;})(4));
[afterMarker] Binary expression 3 + 1 evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (x => { return x + 1;})(4));
[beforeMarker] Function plus_one, defined as x => {...}, takes in x as input 4

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, 4 + 1);
[afterMarker] Function plus_one, defined as x => {...}, takes in x as input 4

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, 4 + 1);
[beforeMarker] Binary expression 4 + 1 evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, 5);
[afterMarker] Binary expression 4 + 1 evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, 5);
[beforeMarker] Function repeat_pattern, defined as n, p, r => {...}, takes in n, p, r as input 0, r => {
  return (r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })((r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })(r));
}, 5

{ function twice_p(r) { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r)); } return 0 === 0 ? 5 : 0 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(0 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); }, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(5)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(0 / 2, twice_p, 5);};
[afterMarker] Function repeat_pattern, defined as n, p, r => {...}, takes in n, p, r as input 0, r => {
  return (r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })((r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })(r));
}, 5

{ function twice_p(r) { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r)); } return 0 === 0 ? 5 : 0 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(0 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); }, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(5)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(0 / 2, twice_p, 5);};
[beforeMarker] Function twice_p declared, parameter(s) r required

{ return 0 === 0 ? 5 : 0 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(0 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); }, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(5)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(0 / 2, r => { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r)); }, 5);};
[afterMarker] Function twice_p declared, parameter(s) r required

{ return 0 === 0 ? 5 : 0 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(0 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); }, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(5)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(0 / 2, r => { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r)); }, 5);};
[beforeMarker] 0 === 0 ? 5 : 0 % 2 !== 0 ? ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(0 - 1, r => {
  return (r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })((r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })(r));
}, (r => {
  return (r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })((r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })(r));
})(5)) : ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(0 / 2, r => {
  return (r => {
    return (r => {
      return (x => {
        return x + 1;
      })((x => {
        return x + 1;
      })(r));
    })((r => {
      return (x => {
        return x + 1;
      })((x => {
        return x + 1;
      })(r));
    })(r));
  })((r => {
    return (r => {
      return (x => {
        return x + 1;
      })((x => {
        return x + 1;
      })(r));
    })((r => {
      return (x => {
        return x + 1;
      })((x => {
        return x + 1;
      })(r));
    })(r));
  })(r));
}, 5) returned

0 === 0 ? 5 : 0 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));})(5)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0 / 2, r => { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r));}, 5);
[afterMarker] 0 === 0 ? 5 : 0 % 2 !== 0 ? ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(0 - 1, r => {
  return (r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })((r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })(r));
}, (r => {
  return (r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })((r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })(r));
})(5)) : ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(0 / 2, r => {
  return (r => {
    return (r => {
      return (x => {
        return x + 1;
      })((x => {
        return x + 1;
      })(r));
    })((r => {
      return (x => {
        return x + 1;
      })((x => {
        return x + 1;
      })(r));
    })(r));
  })((r => {
    return (r => {
      return (x => {
        return x + 1;
      })((x => {
        return x + 1;
      })(r));
    })((r => {
      return (x => {
        return x + 1;
      })((x => {
        return x + 1;
      })(r));
    })(r));
  })(r));
}, 5) returned

0 === 0 ? 5 : 0 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));})(5)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0 / 2, r => { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r));}, 5);
[beforeMarker] Binary expression 0 === 0 evaluated

true ? 5 : 0 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));})(5)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0 / 2, r => { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r));}, 5);
[afterMarker] Binary expression 0 === 0 evaluated

true ? 5 : 0 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));})(5)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0 / 2, r => { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r));}, 5);
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

5;
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

5;
[noMarker] Evaluation complete
"
`;

exports[`return in nested blocks 1`] = `
"function f(x) { { return 1; }}f(0);
[noMarker] Start of evaluation

function f(x) { { return 1; }}f(0);
[beforeMarker] Function f declared, parameter(s) x required

(x => { { return 1; }})(0);
[afterMarker] Function f declared, parameter(s) x required

(x => { { return 1; }})(0);
[beforeMarker] Function f, defined as x => {...}, takes in x as input 0

{ { return 1; }};
[afterMarker] Function f, defined as x => {...}, takes in x as input 0

{ { return 1; }};
[beforeMarker] return 1; finished evaluating

{ return 1;};
[afterMarker] return 1; finished evaluating

{ return 1;};
[beforeMarker] 1 returned

1;
[afterMarker] 1 returned

1;
[noMarker] Evaluation complete
"
`;

exports[`scoping test for block expressions 1`] = `
"function f(x) { const y = x; return g();}function g() { return y;}const y = 1;f(0);
[noMarker] Start of evaluation

function f(x) { const y = x; return g();}function g() { return y;}const y = 1;f(0);
[beforeMarker] Function f declared, parameter(s) x required

function g() { return y;}const y = 1;(x => { const y = x; return g();})(0);
[afterMarker] Function f declared, parameter(s) x required

function g() { return y;}const y = 1;(x => { const y = x; return g();})(0);
[beforeMarker] Function g declared, parameter(s)  required

const y = 1;(x => { const y_1 = x; return (() => { return y; })();})(0);
[afterMarker] Function g declared, parameter(s)  required

const y = 1;(x => { const y_1 = x; return (() => { return y; })();})(0);
[beforeMarker] Constant y declared and substituted into the rest of block

(x => { const y_1 = x; return (() => { return 1; })();})(0);
[afterMarker] Constant y declared and substituted into the rest of block

(x => { const y_1 = x; return (() => { return 1; })();})(0);
[beforeMarker] Function f, defined as x => {...}, takes in x as input 0

{ const y_1 = 0; return (() => { return 1; })();};
[afterMarker] Function f, defined as x => {...}, takes in x as input 0

{ const y_1 = 0; return (() => { return 1; })();};
[beforeMarker] Constant y_1 declared and substituted into the rest of block

{ return (() => { return 1; })();};
[afterMarker] Constant y_1 declared and substituted into the rest of block

{ return (() => { return 1; })();};
[beforeMarker] (() => {
  return 1;
})() returned

(() => { return 1;})();
[afterMarker] (() => {
  return 1;
})() returned

(() => { return 1;})();
[beforeMarker] () => {...} runs

1;
[afterMarker] () => {...} runs

1;
[noMarker] Evaluation complete
"
`;

exports[`scoping test for block expressions, no renaming 1`] = `
"function h(w) { function f(w) { return g(); } function g() { return w; } return f(0);}h(1);
[noMarker] Start of evaluation

function h(w) { function f(w) { return g(); } function g() { return w; } return f(0);}h(1);
[beforeMarker] Function h declared, parameter(s) w required

(w => { function f(w) { return g(); } function g() { return w; } return f(0);})(1);
[afterMarker] Function h declared, parameter(s) w required

(w => { function f(w) { return g(); } function g() { return w; } return f(0);})(1);
[beforeMarker] Function h, defined as w => {...}, takes in w as input 1

{ function f(w) { return g(); } function g() { return 1; } return f(0);};
[afterMarker] Function h, defined as w => {...}, takes in w as input 1

{ function f(w) { return g(); } function g() { return 1; } return f(0);};
[beforeMarker] Function f declared, parameter(s) w required

{ function g() { return 1; } return (w => { return g(); })(0);};
[afterMarker] Function f declared, parameter(s) w required

{ function g() { return 1; } return (w => { return g(); })(0);};
[beforeMarker] Function g declared, parameter(s)  required

{ return (w => { return (() => { return 1; })(); })(0);};
[afterMarker] Function g declared, parameter(s)  required

{ return (w => { return (() => { return 1; })(); })(0);};
[beforeMarker] (w => {
  return (() => {
    return 1;
  })();
})(0) returned

(w => { return (() => { return 1; })();})(0);
[afterMarker] (w => {
  return (() => {
    return 1;
  })();
})(0) returned

(w => { return (() => { return 1; })();})(0);
[beforeMarker] Function f, defined as w => {...}, takes in w as input 0

(() => { return 1;})();
[afterMarker] Function f, defined as w => {...}, takes in w as input 0

(() => { return 1;})();
[beforeMarker] () => {...} runs

1;
[afterMarker] () => {...} runs

1;
[noMarker] Evaluation complete
"
`;

exports[`scoping test for blocks nested in lambda expressions 1`] = `
"const f = x => { g();};const g = () => { x;};const x = 1;f(0);
[noMarker] Start of evaluation

const f = x => { g();};const g = () => { x;};const x = 1;f(0);
[beforeMarker] Constant f declared and substituted into the rest of block

const g = () => { x;};const x = 1;(x => { g();})(0);
[afterMarker] Constant f declared and substituted into the rest of block

const g = () => { x;};const x = 1;(x => { g();})(0);
[beforeMarker] Constant g declared and substituted into the rest of block

const x = 1;(x_1 => { (() => { x; })();})(0);
[afterMarker] Constant g declared and substituted into the rest of block

const x = 1;(x_1 => { (() => { x; })();})(0);
[beforeMarker] Constant x declared and substituted into the rest of block

(x_1 => { (() => { 1; })();})(0);
[afterMarker] Constant x declared and substituted into the rest of block

(x_1 => { (() => { 1; })();})(0);
[beforeMarker] Function f, defined as x_1 => {...}, takes in x_1 as input 0

{ (() => { 1; })();};
[afterMarker] Function f, defined as x_1 => {...}, takes in x_1 as input 0

{ (() => { 1; })();};
[beforeMarker] () => {...} runs

{ { 1; };};
[afterMarker] () => {...} runs

{ { 1; };};
[beforeMarker] 1; finished evaluating

{ undefined;};
[afterMarker] 1; finished evaluating

{ undefined;};
[beforeMarker] undefined; finished evaluating

undefined;
[afterMarker] undefined; finished evaluating

undefined;
[noMarker] Evaluation complete
"
`;

exports[`scoping test for function expressions 1`] = `
"function f(x) { return g();}function g() { return x;}const x = 1;f(0);
[noMarker] Start of evaluation

function f(x) { return g();}function g() { return x;}const x = 1;f(0);
[beforeMarker] Function f declared, parameter(s) x required

function g() { return x;}const x = 1;(x => { return g();})(0);
[afterMarker] Function f declared, parameter(s) x required

function g() { return x;}const x = 1;(x => { return g();})(0);
[beforeMarker] Function g declared, parameter(s)  required

const x = 1;(x_1 => { return (() => { return x; })();})(0);
[afterMarker] Function g declared, parameter(s)  required

const x = 1;(x_1 => { return (() => { return x; })();})(0);
[beforeMarker] Constant x declared and substituted into the rest of block

(x_1 => { return (() => { return 1; })();})(0);
[afterMarker] Constant x declared and substituted into the rest of block

(x_1 => { return (() => { return 1; })();})(0);
[beforeMarker] Function f, defined as x_1 => {...}, takes in x_1 as input 0

(() => { return 1;})();
[afterMarker] Function f, defined as x_1 => {...}, takes in x_1 as input 0

(() => { return 1;})();
[beforeMarker] () => {...} runs

1;
[afterMarker] () => {...} runs

1;
[noMarker] Evaluation complete
"
`;

exports[`scoping test for lambda expressions 1`] = `
"const f = x => g();const g = () => x;const x = 1;f(0);
[noMarker] Start of evaluation

const f = x => g();const g = () => x;const x = 1;f(0);
[beforeMarker] Constant f declared and substituted into the rest of block

const g = () => x;const x = 1;(x => g())(0);
[afterMarker] Constant f declared and substituted into the rest of block

const g = () => x;const x = 1;(x => g())(0);
[beforeMarker] Constant g declared and substituted into the rest of block

const x = 1;(x_1 => (() => x)())(0);
[afterMarker] Constant g declared and substituted into the rest of block

const x = 1;(x_1 => (() => x)())(0);
[beforeMarker] Constant x declared and substituted into the rest of block

(x_1 => (() => 1)())(0);
[afterMarker] Constant x declared and substituted into the rest of block

(x_1 => (() => 1)())(0);
[beforeMarker] 0 substituted into x_1 of x_1 => (() => 1)()

(() => 1)();
[afterMarker] 0 substituted into x_1 of x_1 => (() => 1)()

(() => 1)();
[beforeMarker] () => 1 runs

1;
[afterMarker] () => 1 runs

1;
[noMarker] Evaluation complete
"
`;

exports[`scoping test for lambda expressions nested in blocks 1`] = `
"{ const f = x => g(); const g = () => x; const x = 1; f(0);}
[noMarker] Start of evaluation

{ const f = x => g(); const g = () => x; const x = 1; f(0);}
[beforeMarker] Constant f declared and substituted into the rest of block

{ const g = () => x; const x = 1; (x => g())(0);}
[afterMarker] Constant f declared and substituted into the rest of block

{ const g = () => x; const x = 1; (x => g())(0);}
[beforeMarker] Constant g declared and substituted into the rest of block

{ const x = 1; (x_1 => (() => x)())(0);}
[afterMarker] Constant g declared and substituted into the rest of block

{ const x = 1; (x_1 => (() => x)())(0);}
[beforeMarker] Constant x declared and substituted into the rest of block

{ (x_1 => (() => 1)())(0);}
[afterMarker] Constant x declared and substituted into the rest of block

{ (x_1 => (() => 1)())(0);}
[beforeMarker] 0 substituted into x_1 of x_1 => (() => 1)()

{ (() => 1)();}
[afterMarker] 0 substituted into x_1 of x_1 => (() => 1)()

{ (() => 1)();}
[beforeMarker] () => 1 runs

{ 1;}
[afterMarker] () => 1 runs

{ 1;}
[beforeMarker] 1; finished evaluating

1;
[afterMarker] 1; finished evaluating

1;
[noMarker] Evaluation complete
"
`;

exports[`steps appear as if capturing happens #1714 1`] = `
"function h(f, x) { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1);}h(h, 5);
[noMarker] Start of evaluation

function h(f, x) { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1);}h(h, 5);
[beforeMarker] Function h declared, parameter(s) f,x required

((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1);})((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1);}, 5);
[afterMarker] Function h declared, parameter(s) f,x required

((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1);})((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1);}, 5);
[beforeMarker] Function h, defined as f, x => {...}, takes in f, x as input (f, x) => {
  function h_1(g, x) {
    return x <= 1 ? 1 : 3 * g(f, x - 1);
  }
  return x <= 1 ? 1 : 2 * f(h_1, x - 1);
}, 5

{ function h_1(g, x) { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); } return 5 <= 1 ? 1 : 2 * ((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); })(h_1, 5 - 1);};
[afterMarker] Function h, defined as f, x => {...}, takes in f, x as input (f, x) => {
  function h_1(g, x) {
    return x <= 1 ? 1 : 3 * g(f, x - 1);
  }
  return x <= 1 ? 1 : 2 * f(h_1, x - 1);
}, 5

{ function h_1(g, x) { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); } return 5 <= 1 ? 1 : 2 * ((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); })(h_1, 5 - 1);};
[beforeMarker] Function h_1 declared, parameter(s) g,x required

{ return 5 <= 1 ? 1 : 2 * ((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); })((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); }, 5 - 1);};
[afterMarker] Function h_1 declared, parameter(s) g,x required

{ return 5 <= 1 ? 1 : 2 * ((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); })((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); }, 5 - 1);};
[beforeMarker] 5 <= 1 ? 1 : 2 * ((f, x) => {
  function h_1(g, x) {
    return x <= 1 ? 1 : 3 * g(f, x - 1);
  }
  return x <= 1 ? 1 : 2 * f(h_1, x - 1);
})((g, x) => {
  return x <= 1 ? 1 : 3 * g((f, x) => {
    function h_1(g, x) {
      return x <= 1 ? 1 : 3 * g(f, x - 1);
    }
    return x <= 1 ? 1 : 2 * f(h_1, x - 1);
  }, x - 1);
}, 5 - 1) returned

5 <= 1 ? 1 : 2 * ((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1);}, 5 - 1);
[afterMarker] 5 <= 1 ? 1 : 2 * ((f, x) => {
  function h_1(g, x) {
    return x <= 1 ? 1 : 3 * g(f, x - 1);
  }
  return x <= 1 ? 1 : 2 * f(h_1, x - 1);
})((g, x) => {
  return x <= 1 ? 1 : 3 * g((f, x) => {
    function h_1(g, x) {
      return x <= 1 ? 1 : 3 * g(f, x - 1);
    }
    return x <= 1 ? 1 : 2 * f(h_1, x - 1);
  }, x - 1);
}, 5 - 1) returned

5 <= 1 ? 1 : 2 * ((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1);}, 5 - 1);
[beforeMarker] Binary expression 5 <= 1 evaluated

false ? 1 : 2 * ((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1);}, 5 - 1);
[afterMarker] Binary expression 5 <= 1 evaluated

false ? 1 : 2 * ((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1);}, 5 - 1);
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

2 * ((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1);}, 5 - 1);
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

2 * ((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1);}, 5 - 1);
[beforeMarker] Binary expression 5 - 1 evaluated

2 * ((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1);}, 4);
[afterMarker] Binary expression 5 - 1 evaluated

2 * ((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1);}, 4);
[beforeMarker] Function h, defined as f, x => {...}, takes in f, x as input (g, x) => {
  return x <= 1 ? 1 : 3 * g((f, x) => {
    function h_1(g, x) {
      return x <= 1 ? 1 : 3 * g(f, x - 1);
    }
    return x <= 1 ? 1 : 2 * f(h_1, x - 1);
  }, x - 1);
}, 4

2 * { function h_1(g, x) { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); }, x - 1); } return 4 <= 1 ? 1 : 2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); })(h_1, 4 - 1);};
[afterMarker] Function h, defined as f, x => {...}, takes in f, x as input (g, x) => {
  return x <= 1 ? 1 : 3 * g((f, x) => {
    function h_1(g, x) {
      return x <= 1 ? 1 : 3 * g(f, x - 1);
    }
    return x <= 1 ? 1 : 2 * f(h_1, x - 1);
  }, x - 1);
}, 4

2 * { function h_1(g, x) { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); }, x - 1); } return 4 <= 1 ? 1 : 2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); })(h_1, 4 - 1);};
[beforeMarker] Function h_1 declared, parameter(s) g,x required

2 * { return 4 <= 1 ? 1 : 2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); })((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); }, x - 1); }, 4 - 1);};
[afterMarker] Function h_1 declared, parameter(s) g,x required

2 * { return 4 <= 1 ? 1 : 2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); })((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); }, x - 1); }, 4 - 1);};
[beforeMarker] 4 <= 1 ? 1 : 2 * ((g, x) => {
  return x <= 1 ? 1 : 3 * g((f, x) => {
    function h_1(g, x) {
      return x <= 1 ? 1 : 3 * g(f, x - 1);
    }
    return x <= 1 ? 1 : 2 * f(h_1, x - 1);
  }, x - 1);
})((g, x) => {
  return x <= 1 ? 1 : 3 * g((g, x) => {
    return x <= 1 ? 1 : 3 * g((f, x) => {
      function h_1(g, x) {
        return x <= 1 ? 1 : 3 * g(f, x - 1);
      }
      return x <= 1 ? 1 : 2 * f(h_1, x - 1);
    }, x - 1);
  }, x - 1);
}, 4 - 1) returned

2 * (4 <= 1 ? 1 : 2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); }, x - 1);}, 4 - 1));
[afterMarker] 4 <= 1 ? 1 : 2 * ((g, x) => {
  return x <= 1 ? 1 : 3 * g((f, x) => {
    function h_1(g, x) {
      return x <= 1 ? 1 : 3 * g(f, x - 1);
    }
    return x <= 1 ? 1 : 2 * f(h_1, x - 1);
  }, x - 1);
})((g, x) => {
  return x <= 1 ? 1 : 3 * g((g, x) => {
    return x <= 1 ? 1 : 3 * g((f, x) => {
      function h_1(g, x) {
        return x <= 1 ? 1 : 3 * g(f, x - 1);
      }
      return x <= 1 ? 1 : 2 * f(h_1, x - 1);
    }, x - 1);
  }, x - 1);
}, 4 - 1) returned

2 * (4 <= 1 ? 1 : 2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); }, x - 1);}, 4 - 1));
[beforeMarker] Binary expression 4 <= 1 evaluated

2 * (false ? 1 : 2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); }, x - 1);}, 4 - 1));
[afterMarker] Binary expression 4 <= 1 evaluated

2 * (false ? 1 : 2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); }, x - 1);}, 4 - 1));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

2 * (2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); }, x - 1);}, 4 - 1));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

2 * (2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); }, x - 1);}, 4 - 1));
[beforeMarker] Binary expression 4 - 1 evaluated

2 * (2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); }, x - 1);}, 3));
[afterMarker] Binary expression 4 - 1 evaluated

2 * (2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); }, x - 1);}, 3));
[beforeMarker] Function h_1, defined as g, x => {...}, takes in g, x as input (g, x) => {
  return x <= 1 ? 1 : 3 * g((g, x) => {
    return x <= 1 ? 1 : 3 * g((f, x) => {
      function h_1(g, x) {
        return x <= 1 ? 1 : 3 * g(f, x - 1);
      }
      return x <= 1 ? 1 : 2 * f(h_1, x - 1);
    }, x - 1);
  }, x - 1);
}, 3

2 * (2 * (3 <= 1 ? 1 : 3 * ((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); }, x - 1);})((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1);}, 3 - 1)));
[afterMarker] Function h_1, defined as g, x => {...}, takes in g, x as input (g, x) => {
  return x <= 1 ? 1 : 3 * g((g, x) => {
    return x <= 1 ? 1 : 3 * g((f, x) => {
      function h_1(g, x) {
        return x <= 1 ? 1 : 3 * g(f, x - 1);
      }
      return x <= 1 ? 1 : 2 * f(h_1, x - 1);
    }, x - 1);
  }, x - 1);
}, 3

2 * (2 * (3 <= 1 ? 1 : 3 * ((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); }, x - 1);})((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1);}, 3 - 1)));
[beforeMarker] Binary expression 3 <= 1 evaluated

2 * (2 * (false ? 1 : 3 * ((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); }, x - 1);})((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1);}, 3 - 1)));
[afterMarker] Binary expression 3 <= 1 evaluated

2 * (2 * (false ? 1 : 3 * ((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); }, x - 1);})((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1);}, 3 - 1)));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

2 * (2 * (3 * ((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); }, x - 1);})((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1);}, 3 - 1)));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

2 * (2 * (3 * ((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); }, x - 1);})((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1);}, 3 - 1)));
[beforeMarker] Binary expression 3 - 1 evaluated

2 * (2 * (3 * ((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); }, x - 1);})((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1);}, 2)));
[afterMarker] Binary expression 3 - 1 evaluated

2 * (2 * (3 * ((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); }, x - 1);})((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1);}, 2)));
[beforeMarker] Function h_1, defined as g, x => {...}, takes in g, x as input (f, x) => {
  function h_1(g, x) {
    return x <= 1 ? 1 : 3 * g(f, x - 1);
  }
  return x <= 1 ? 1 : 2 * f(h_1, x - 1);
}, 2

2 * (2 * (3 * (2 <= 1 ? 1 : 3 * ((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1);}, 2 - 1))));
[afterMarker] Function h_1, defined as g, x => {...}, takes in g, x as input (f, x) => {
  function h_1(g, x) {
    return x <= 1 ? 1 : 3 * g(f, x - 1);
  }
  return x <= 1 ? 1 : 2 * f(h_1, x - 1);
}, 2

2 * (2 * (3 * (2 <= 1 ? 1 : 3 * ((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1);}, 2 - 1))));
[beforeMarker] Binary expression 2 <= 1 evaluated

2 * (2 * (3 * (false ? 1 : 3 * ((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1);}, 2 - 1))));
[afterMarker] Binary expression 2 <= 1 evaluated

2 * (2 * (3 * (false ? 1 : 3 * ((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1);}, 2 - 1))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

2 * (2 * (3 * (3 * ((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1);}, 2 - 1))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

2 * (2 * (3 * (3 * ((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1);}, 2 - 1))));
[beforeMarker] Binary expression 2 - 1 evaluated

2 * (2 * (3 * (3 * ((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1);}, 1))));
[afterMarker] Binary expression 2 - 1 evaluated

2 * (2 * (3 * (3 * ((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1);}, 1))));
[beforeMarker] Function h, defined as f, x => {...}, takes in f, x as input (g, x) => {
  return x <= 1 ? 1 : 3 * g((f, x) => {
    function h_1(g, x) {
      return x <= 1 ? 1 : 3 * g(f, x - 1);
    }
    return x <= 1 ? 1 : 2 * f(h_1, x - 1);
  }, x - 1);
}, 1

2 * (2 * (3 * (3 * { function h_1(g, x) { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); }, x - 1); } return 1 <= 1 ? 1 : 2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); })(h_1, 1 - 1);})));
[afterMarker] Function h, defined as f, x => {...}, takes in f, x as input (g, x) => {
  return x <= 1 ? 1 : 3 * g((f, x) => {
    function h_1(g, x) {
      return x <= 1 ? 1 : 3 * g(f, x - 1);
    }
    return x <= 1 ? 1 : 2 * f(h_1, x - 1);
  }, x - 1);
}, 1

2 * (2 * (3 * (3 * { function h_1(g, x) { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); }, x - 1); } return 1 <= 1 ? 1 : 2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); })(h_1, 1 - 1);})));
[beforeMarker] Function h_1 declared, parameter(s) g,x required

2 * (2 * (3 * (3 * { return 1 <= 1 ? 1 : 2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); })((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); }, x - 1); }, 1 - 1);})));
[afterMarker] Function h_1 declared, parameter(s) g,x required

2 * (2 * (3 * (3 * { return 1 <= 1 ? 1 : 2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); })((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); }, x - 1); }, 1 - 1);})));
[beforeMarker] 1 <= 1 ? 1 : 2 * ((g, x) => {
  return x <= 1 ? 1 : 3 * g((f, x) => {
    function h_1(g, x) {
      return x <= 1 ? 1 : 3 * g(f, x - 1);
    }
    return x <= 1 ? 1 : 2 * f(h_1, x - 1);
  }, x - 1);
})((g, x) => {
  return x <= 1 ? 1 : 3 * g((g, x) => {
    return x <= 1 ? 1 : 3 * g((f, x) => {
      function h_1(g, x) {
        return x <= 1 ? 1 : 3 * g(f, x - 1);
      }
      return x <= 1 ? 1 : 2 * f(h_1, x - 1);
    }, x - 1);
  }, x - 1);
}, 1 - 1) returned

2 * (2 * (3 * (3 * (1 <= 1 ? 1 : 2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); }, x - 1);}, 1 - 1)))));
[afterMarker] 1 <= 1 ? 1 : 2 * ((g, x) => {
  return x <= 1 ? 1 : 3 * g((f, x) => {
    function h_1(g, x) {
      return x <= 1 ? 1 : 3 * g(f, x - 1);
    }
    return x <= 1 ? 1 : 2 * f(h_1, x - 1);
  }, x - 1);
})((g, x) => {
  return x <= 1 ? 1 : 3 * g((g, x) => {
    return x <= 1 ? 1 : 3 * g((f, x) => {
      function h_1(g, x) {
        return x <= 1 ? 1 : 3 * g(f, x - 1);
      }
      return x <= 1 ? 1 : 2 * f(h_1, x - 1);
    }, x - 1);
  }, x - 1);
}, 1 - 1) returned

2 * (2 * (3 * (3 * (1 <= 1 ? 1 : 2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); }, x - 1);}, 1 - 1)))));
[beforeMarker] Binary expression 1 <= 1 evaluated

2 * (2 * (3 * (3 * (true ? 1 : 2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); }, x - 1);}, 1 - 1)))));
[afterMarker] Binary expression 1 <= 1 evaluated

2 * (2 * (3 * (3 * (true ? 1 : 2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h_1(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h_1, x - 1); }, x - 1); }, x - 1);}, 1 - 1)))));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

2 * (2 * (3 * (3 * 1)));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

2 * (2 * (3 * (3 * 1)));
[beforeMarker] Binary expression 3 * 1 evaluated

2 * (2 * (3 * 3));
[afterMarker] Binary expression 3 * 1 evaluated

2 * (2 * (3 * 3));
[beforeMarker] Binary expression 3 * 3 evaluated

2 * (2 * 9);
[afterMarker] Binary expression 3 * 3 evaluated

2 * (2 * 9);
[beforeMarker] Binary expression 2 * 9 evaluated

2 * 18;
[afterMarker] Binary expression 2 * 9 evaluated

2 * 18;
[beforeMarker] Binary expression 2 * 18 evaluated

36;
[afterMarker] Binary expression 2 * 18 evaluated

36;
[noMarker] Evaluation complete
"
`;

exports[`triple equals work on function 1`] = `
"function f() { return g();}function g() { return f();}f === f;g === g;f === g;
[noMarker] Start of evaluation

function f() { return g();}function g() { return f();}f === f;g === g;f === g;
[beforeMarker] Function f declared, parameter(s)  required

function g() { return (() => { return g(); })();}(() => { return g();}) === (() => { return g();});g === g;(() => { return g();}) === g;
[afterMarker] Function f declared, parameter(s)  required

function g() { return (() => { return g(); })();}(() => { return g();}) === (() => { return g();});g === g;(() => { return g();}) === g;
[beforeMarker] Function g declared, parameter(s)  required

(() => { return (() => { return (() => { return g(); })(); })();}) === (() => { return (() => { return (() => { return g(); })(); })();});(() => { return (() => { return g(); })();}) === (() => { return (() => { return g(); })();});(() => { return (() => { return (() => { return g(); })(); })();}) === (() => { return (() => { return g(); })();});
[afterMarker] Function g declared, parameter(s)  required

(() => { return (() => { return (() => { return g(); })(); })();}) === (() => { return (() => { return (() => { return g(); })(); })();});(() => { return (() => { return g(); })();}) === (() => { return (() => { return g(); })();});(() => { return (() => { return (() => { return g(); })(); })();}) === (() => { return (() => { return g(); })();});
[beforeMarker] (() => {
  return (() => {
    return (() => {
      return g();
    })();
  })();
}) === (() => {
  return (() => {
    return (() => {
      return g();
    })();
  })();
}) finished evaluating

(() => { return (() => { return g(); })();}) === (() => { return (() => { return g(); })();});(() => { return (() => { return (() => { return g(); })(); })();}) === (() => { return (() => { return g(); })();});
[afterMarker] (() => {
  return (() => {
    return (() => {
      return g();
    })();
  })();
}) === (() => {
  return (() => {
    return (() => {
      return g();
    })();
  })();
}) finished evaluating

(() => { return (() => { return g(); })();}) === (() => { return (() => { return g(); })();});(() => { return (() => { return (() => { return g(); })(); })();}) === (() => { return (() => { return g(); })();});
[beforeMarker] (() => {
  return (() => {
    return g();
  })();
}) === (() => {
  return (() => {
    return g();
  })();
}) finished evaluating

(() => { return (() => { return (() => { return g(); })(); })();}) === (() => { return (() => { return g(); })();});
[afterMarker] (() => {
  return (() => {
    return g();
  })();
}) === (() => {
  return (() => {
    return g();
  })();
}) finished evaluating

(() => { return (() => { return (() => { return g(); })(); })();}) === (() => { return (() => { return g(); })();});
[noMarker] Evaluation complete
"
`;

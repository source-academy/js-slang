// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`#1109: Empty function bodies don't break execution Constant declaration of lambda 1`] = `
"const a = () => {};\\"other statement\\";a();\\"Gets returned by normal run\\";
[noMarker] Start of evaluation

const a = () => {};\\"other statement\\";a();\\"Gets returned by normal run\\";
[beforeMarker] Constant a declared and substituted into the rest of block

\\"other statement\\";(() => {})();\\"Gets returned by normal run\\";
[afterMarker] Constant a declared and substituted into the rest of block

\\"other statement\\";(() => {})();\\"Gets returned by normal run\\";
[beforeMarker] () => {...} runs

\\"other statement\\";{};\\"Gets returned by normal run\\";
[afterMarker] () => {...} runs

\\"other statement\\";{};\\"Gets returned by normal run\\";
[beforeMarker] Empty block expression evaluated

\\"other statement\\";undefined;\\"Gets returned by normal run\\";
[afterMarker] Empty block expression evaluated

\\"other statement\\";undefined;\\"Gets returned by normal run\\";
[beforeMarker] \\"other statement\\" finished evaluating

undefined;\\"Gets returned by normal run\\";
[afterMarker] \\"other statement\\" finished evaluating

undefined;\\"Gets returned by normal run\\";
[beforeMarker] undefined finished evaluating

\\"Gets returned by normal run\\";
[afterMarker] undefined finished evaluating

\\"Gets returned by normal run\\";
[noMarker] Evaluation complete
"
`;

exports[`#1109: Empty function bodies don't break execution Function declaration 1`] = `
"function a() {}\\"other statement\\";a();\\"Gets returned by normal run\\";
[noMarker] Start of evaluation

function a() {}\\"other statement\\";a();\\"Gets returned by normal run\\";
[beforeMarker] Function a declared, parameter(s)  required

\\"other statement\\";(() => {})();\\"Gets returned by normal run\\";
[afterMarker] Function a declared, parameter(s)  required

\\"other statement\\";(() => {})();\\"Gets returned by normal run\\";
[beforeMarker] () => {...} runs

\\"other statement\\";{};\\"Gets returned by normal run\\";
[afterMarker] () => {...} runs

\\"other statement\\";{};\\"Gets returned by normal run\\";
[beforeMarker] Empty block expression evaluated

\\"other statement\\";undefined;\\"Gets returned by normal run\\";
[afterMarker] Empty block expression evaluated

\\"other statement\\";undefined;\\"Gets returned by normal run\\";
[beforeMarker] \\"other statement\\" finished evaluating

undefined;\\"Gets returned by normal run\\";
[afterMarker] \\"other statement\\" finished evaluating

undefined;\\"Gets returned by normal run\\";
[beforeMarker] undefined finished evaluating

\\"Gets returned by normal run\\";
[afterMarker] undefined finished evaluating

\\"Gets returned by normal run\\";
[noMarker] Evaluation complete
"
`;

exports[`#1342: Test the fix of #1341: Stepper limit off by one Program steps equal to Stepper limit 1`] = `
"function factorial(n) { return n === 1 ? 1 : n * factorial(n - 1);}factorial(100);
[noMarker] Start of evaluation

function factorial(n) { return n === 1 ? 1 : n * factorial(n - 1);}factorial(100);
[beforeMarker] Function factorial declared, parameter(s) n required

(n => { return n === 1 ? 1 : n * factorial(n - 1);})(100);
[afterMarker] Function factorial declared, parameter(s) n required

(n => { return n === 1 ? 1 : n * factorial(n - 1);})(100);
[beforeMarker] Function factorial takes in 100 as input n

100 === 1 ? 1 : 100 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(100 - 1);
[afterMarker] Function factorial takes in 100 as input n

100 === 1 ? 1 : 100 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(100 - 1);
[beforeMarker] Binary expression 100 === 1 evaluated

false ? 1 : 100 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(100 - 1);
[afterMarker] Binary expression 100 === 1 evaluated

false ? 1 : 100 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(100 - 1);
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(100 - 1);
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(100 - 1);
[beforeMarker] Binary expression 100 - 1 evaluated

100 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(99);
[afterMarker] Binary expression 100 - 1 evaluated

100 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(99);
[beforeMarker] Function factorial takes in 99 as input n

100 * (99 === 1 ? 1 : 99 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(99 - 1));
[afterMarker] Function factorial takes in 99 as input n

100 * (99 === 1 ? 1 : 99 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(99 - 1));
[beforeMarker] Binary expression 99 === 1 evaluated

100 * (false ? 1 : 99 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(99 - 1));
[afterMarker] Binary expression 99 === 1 evaluated

100 * (false ? 1 : 99 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(99 - 1));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(99 - 1));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(99 - 1));
[beforeMarker] Binary expression 99 - 1 evaluated

100 * (99 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(98));
[afterMarker] Binary expression 99 - 1 evaluated

100 * (99 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(98));
[beforeMarker] Function factorial takes in 98 as input n

100 * (99 * (98 === 1 ? 1 : 98 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(98 - 1)));
[afterMarker] Function factorial takes in 98 as input n

100 * (99 * (98 === 1 ? 1 : 98 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(98 - 1)));
[beforeMarker] Binary expression 98 === 1 evaluated

100 * (99 * (false ? 1 : 98 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(98 - 1)));
[afterMarker] Binary expression 98 === 1 evaluated

100 * (99 * (false ? 1 : 98 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(98 - 1)));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(98 - 1)));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(98 - 1)));
[beforeMarker] Binary expression 98 - 1 evaluated

100 * (99 * (98 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(97)));
[afterMarker] Binary expression 98 - 1 evaluated

100 * (99 * (98 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(97)));
[beforeMarker] Function factorial takes in 97 as input n

100 * (99 * (98 * (97 === 1 ? 1 : 97 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(97 - 1))));
[afterMarker] Function factorial takes in 97 as input n

100 * (99 * (98 * (97 === 1 ? 1 : 97 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(97 - 1))));
[beforeMarker] Binary expression 97 === 1 evaluated

100 * (99 * (98 * (false ? 1 : 97 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(97 - 1))));
[afterMarker] Binary expression 97 === 1 evaluated

100 * (99 * (98 * (false ? 1 : 97 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(97 - 1))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(97 - 1))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(97 - 1))));
[beforeMarker] Binary expression 97 - 1 evaluated

100 * (99 * (98 * (97 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(96))));
[afterMarker] Binary expression 97 - 1 evaluated

100 * (99 * (98 * (97 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(96))));
[beforeMarker] Function factorial takes in 96 as input n

100 * (99 * (98 * (97 * (96 === 1 ? 1 : 96 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(96 - 1)))));
[afterMarker] Function factorial takes in 96 as input n

100 * (99 * (98 * (97 * (96 === 1 ? 1 : 96 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(96 - 1)))));
[beforeMarker] Binary expression 96 === 1 evaluated

100 * (99 * (98 * (97 * (false ? 1 : 96 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(96 - 1)))));
[afterMarker] Binary expression 96 === 1 evaluated

100 * (99 * (98 * (97 * (false ? 1 : 96 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(96 - 1)))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(96 - 1)))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(96 - 1)))));
[beforeMarker] Binary expression 96 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(95)))));
[afterMarker] Binary expression 96 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(95)))));
[beforeMarker] Function factorial takes in 95 as input n

100 * (99 * (98 * (97 * (96 * (95 === 1 ? 1 : 95 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(95 - 1))))));
[afterMarker] Function factorial takes in 95 as input n

100 * (99 * (98 * (97 * (96 * (95 === 1 ? 1 : 95 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(95 - 1))))));
[beforeMarker] Binary expression 95 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (false ? 1 : 95 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(95 - 1))))));
[afterMarker] Binary expression 95 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (false ? 1 : 95 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(95 - 1))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(95 - 1))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(95 - 1))))));
[beforeMarker] Binary expression 95 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(94))))));
[afterMarker] Binary expression 95 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(94))))));
[beforeMarker] Function factorial takes in 94 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 === 1 ? 1 : 94 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(94 - 1)))))));
[afterMarker] Function factorial takes in 94 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 === 1 ? 1 : 94 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(94 - 1)))))));
[beforeMarker] Binary expression 94 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (false ? 1 : 94 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(94 - 1)))))));
[afterMarker] Binary expression 94 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (false ? 1 : 94 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(94 - 1)))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(94 - 1)))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(94 - 1)))))));
[beforeMarker] Binary expression 94 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(93)))))));
[afterMarker] Binary expression 94 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(93)))))));
[beforeMarker] Function factorial takes in 93 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 === 1 ? 1 : 93 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(93 - 1))))))));
[afterMarker] Function factorial takes in 93 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 === 1 ? 1 : 93 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(93 - 1))))))));
[beforeMarker] Binary expression 93 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (false ? 1 : 93 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(93 - 1))))))));
[afterMarker] Binary expression 93 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (false ? 1 : 93 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(93 - 1))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(93 - 1))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(93 - 1))))))));
[beforeMarker] Binary expression 93 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(92))))))));
[afterMarker] Binary expression 93 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(92))))))));
[beforeMarker] Function factorial takes in 92 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 === 1 ? 1 : 92 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(92 - 1)))))))));
[afterMarker] Function factorial takes in 92 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 === 1 ? 1 : 92 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(92 - 1)))))))));
[beforeMarker] Binary expression 92 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (false ? 1 : 92 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(92 - 1)))))))));
[afterMarker] Binary expression 92 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (false ? 1 : 92 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(92 - 1)))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(92 - 1)))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(92 - 1)))))))));
[beforeMarker] Binary expression 92 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(91)))))))));
[afterMarker] Binary expression 92 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(91)))))))));
[beforeMarker] Function factorial takes in 91 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 === 1 ? 1 : 91 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(91 - 1))))))))));
[afterMarker] Function factorial takes in 91 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 === 1 ? 1 : 91 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(91 - 1))))))))));
[beforeMarker] Binary expression 91 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (false ? 1 : 91 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(91 - 1))))))))));
[afterMarker] Binary expression 91 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (false ? 1 : 91 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(91 - 1))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(91 - 1))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(91 - 1))))))))));
[beforeMarker] Binary expression 91 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(90))))))))));
[afterMarker] Binary expression 91 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(90))))))))));
[beforeMarker] Function factorial takes in 90 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 === 1 ? 1 : 90 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(90 - 1)))))))))));
[afterMarker] Function factorial takes in 90 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 === 1 ? 1 : 90 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(90 - 1)))))))))));
[beforeMarker] Binary expression 90 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (false ? 1 : 90 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(90 - 1)))))))))));
[afterMarker] Binary expression 90 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (false ? 1 : 90 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(90 - 1)))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(90 - 1)))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(90 - 1)))))))))));
[beforeMarker] Binary expression 90 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(89)))))))))));
[afterMarker] Binary expression 90 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(89)))))))))));
[beforeMarker] Function factorial takes in 89 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 === 1 ? 1 : 89 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(89 - 1))))))))))));
[afterMarker] Function factorial takes in 89 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 === 1 ? 1 : 89 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(89 - 1))))))))))));
[beforeMarker] Binary expression 89 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (false ? 1 : 89 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(89 - 1))))))))))));
[afterMarker] Binary expression 89 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (false ? 1 : 89 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(89 - 1))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(89 - 1))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(89 - 1))))))))))));
[beforeMarker] Binary expression 89 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(88))))))))))));
[afterMarker] Binary expression 89 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(88))))))))))));
[beforeMarker] Function factorial takes in 88 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 === 1 ? 1 : 88 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(88 - 1)))))))))))));
[afterMarker] Function factorial takes in 88 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 === 1 ? 1 : 88 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(88 - 1)))))))))))));
[beforeMarker] Binary expression 88 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (false ? 1 : 88 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(88 - 1)))))))))))));
[afterMarker] Binary expression 88 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (false ? 1 : 88 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(88 - 1)))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(88 - 1)))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(88 - 1)))))))))))));
[beforeMarker] Binary expression 88 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(87)))))))))))));
[afterMarker] Binary expression 88 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(87)))))))))))));
[beforeMarker] Function factorial takes in 87 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 === 1 ? 1 : 87 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(87 - 1))))))))))))));
[afterMarker] Function factorial takes in 87 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 === 1 ? 1 : 87 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(87 - 1))))))))))))));
[beforeMarker] Binary expression 87 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (false ? 1 : 87 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(87 - 1))))))))))))));
[afterMarker] Binary expression 87 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (false ? 1 : 87 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(87 - 1))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(87 - 1))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(87 - 1))))))))))))));
[beforeMarker] Binary expression 87 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(86))))))))))))));
[afterMarker] Binary expression 87 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(86))))))))))))));
[beforeMarker] Function factorial takes in 86 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 === 1 ? 1 : 86 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(86 - 1)))))))))))))));
[afterMarker] Function factorial takes in 86 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 === 1 ? 1 : 86 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(86 - 1)))))))))))))));
[beforeMarker] Binary expression 86 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (false ? 1 : 86 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(86 - 1)))))))))))))));
[afterMarker] Binary expression 86 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (false ? 1 : 86 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(86 - 1)))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(86 - 1)))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(86 - 1)))))))))))))));
[beforeMarker] Binary expression 86 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(85)))))))))))))));
[afterMarker] Binary expression 86 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(85)))))))))))))));
[beforeMarker] Function factorial takes in 85 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 === 1 ? 1 : 85 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(85 - 1))))))))))))))));
[afterMarker] Function factorial takes in 85 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 === 1 ? 1 : 85 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(85 - 1))))))))))))))));
[beforeMarker] Binary expression 85 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (false ? 1 : 85 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(85 - 1))))))))))))))));
[afterMarker] Binary expression 85 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (false ? 1 : 85 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(85 - 1))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(85 - 1))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(85 - 1))))))))))))))));
[beforeMarker] Binary expression 85 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(84))))))))))))))));
[afterMarker] Binary expression 85 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(84))))))))))))))));
[beforeMarker] Function factorial takes in 84 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 === 1 ? 1 : 84 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(84 - 1)))))))))))))))));
[afterMarker] Function factorial takes in 84 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 === 1 ? 1 : 84 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(84 - 1)))))))))))))))));
[beforeMarker] Binary expression 84 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (false ? 1 : 84 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(84 - 1)))))))))))))))));
[afterMarker] Binary expression 84 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (false ? 1 : 84 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(84 - 1)))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(84 - 1)))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(84 - 1)))))))))))))))));
[beforeMarker] Binary expression 84 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(83)))))))))))))))));
[afterMarker] Binary expression 84 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(83)))))))))))))))));
[beforeMarker] Function factorial takes in 83 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 === 1 ? 1 : 83 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(83 - 1))))))))))))))))));
[afterMarker] Function factorial takes in 83 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 === 1 ? 1 : 83 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(83 - 1))))))))))))))))));
[beforeMarker] Binary expression 83 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (false ? 1 : 83 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(83 - 1))))))))))))))))));
[afterMarker] Binary expression 83 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (false ? 1 : 83 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(83 - 1))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(83 - 1))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(83 - 1))))))))))))))))));
[beforeMarker] Binary expression 83 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(82))))))))))))))))));
[afterMarker] Binary expression 83 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(82))))))))))))))))));
[beforeMarker] Function factorial takes in 82 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 === 1 ? 1 : 82 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(82 - 1)))))))))))))))))));
[afterMarker] Function factorial takes in 82 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 === 1 ? 1 : 82 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(82 - 1)))))))))))))))))));
[beforeMarker] Binary expression 82 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (false ? 1 : 82 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(82 - 1)))))))))))))))))));
[afterMarker] Binary expression 82 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (false ? 1 : 82 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(82 - 1)))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(82 - 1)))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(82 - 1)))))))))))))))))));
[beforeMarker] Binary expression 82 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(81)))))))))))))))))));
[afterMarker] Binary expression 82 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(81)))))))))))))))))));
[beforeMarker] Function factorial takes in 81 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 === 1 ? 1 : 81 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(81 - 1))))))))))))))))))));
[afterMarker] Function factorial takes in 81 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 === 1 ? 1 : 81 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(81 - 1))))))))))))))))))));
[beforeMarker] Binary expression 81 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (false ? 1 : 81 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(81 - 1))))))))))))))))))));
[afterMarker] Binary expression 81 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (false ? 1 : 81 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(81 - 1))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(81 - 1))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(81 - 1))))))))))))))))))));
[beforeMarker] Binary expression 81 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(80))))))))))))))))))));
[afterMarker] Binary expression 81 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(80))))))))))))))))))));
[beforeMarker] Function factorial takes in 80 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 === 1 ? 1 : 80 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(80 - 1)))))))))))))))))))));
[afterMarker] Function factorial takes in 80 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 === 1 ? 1 : 80 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(80 - 1)))))))))))))))))))));
[beforeMarker] Binary expression 80 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (false ? 1 : 80 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(80 - 1)))))))))))))))))))));
[afterMarker] Binary expression 80 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (false ? 1 : 80 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(80 - 1)))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(80 - 1)))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(80 - 1)))))))))))))))))))));
[beforeMarker] Binary expression 80 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(79)))))))))))))))))))));
[afterMarker] Binary expression 80 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(79)))))))))))))))))))));
[beforeMarker] Function factorial takes in 79 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 === 1 ? 1 : 79 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(79 - 1))))))))))))))))))))));
[afterMarker] Function factorial takes in 79 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 === 1 ? 1 : 79 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(79 - 1))))))))))))))))))))));
[beforeMarker] Binary expression 79 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (false ? 1 : 79 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(79 - 1))))))))))))))))))))));
[afterMarker] Binary expression 79 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (false ? 1 : 79 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(79 - 1))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(79 - 1))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(79 - 1))))))))))))))))))))));
[beforeMarker] Binary expression 79 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(78))))))))))))))))))))));
[afterMarker] Binary expression 79 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(78))))))))))))))))))))));
[beforeMarker] Function factorial takes in 78 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 === 1 ? 1 : 78 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(78 - 1)))))))))))))))))))))));
[afterMarker] Function factorial takes in 78 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 === 1 ? 1 : 78 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(78 - 1)))))))))))))))))))))));
[beforeMarker] Binary expression 78 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (false ? 1 : 78 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(78 - 1)))))))))))))))))))))));
[afterMarker] Binary expression 78 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (false ? 1 : 78 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(78 - 1)))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(78 - 1)))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(78 - 1)))))))))))))))))))))));
[beforeMarker] Binary expression 78 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(77)))))))))))))))))))))));
[afterMarker] Binary expression 78 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(77)))))))))))))))))))))));
[beforeMarker] Function factorial takes in 77 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 === 1 ? 1 : 77 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(77 - 1))))))))))))))))))))))));
[afterMarker] Function factorial takes in 77 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 === 1 ? 1 : 77 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(77 - 1))))))))))))))))))))))));
[beforeMarker] Binary expression 77 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (false ? 1 : 77 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(77 - 1))))))))))))))))))))))));
[afterMarker] Binary expression 77 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (false ? 1 : 77 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(77 - 1))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(77 - 1))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(77 - 1))))))))))))))))))))))));
[beforeMarker] Binary expression 77 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(76))))))))))))))))))))))));
[afterMarker] Binary expression 77 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(76))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 76 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 === 1 ? 1 : 76 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(76 - 1)))))))))))))))))))))))));
[afterMarker] Function factorial takes in 76 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 === 1 ? 1 : 76 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(76 - 1)))))))))))))))))))))))));
[beforeMarker] Binary expression 76 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (false ? 1 : 76 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(76 - 1)))))))))))))))))))))))));
[afterMarker] Binary expression 76 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (false ? 1 : 76 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(76 - 1)))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(76 - 1)))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(76 - 1)))))))))))))))))))))))));
[beforeMarker] Binary expression 76 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(75)))))))))))))))))))))))));
[afterMarker] Binary expression 76 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(75)))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 75 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 === 1 ? 1 : 75 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(75 - 1))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 75 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 === 1 ? 1 : 75 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(75 - 1))))))))))))))))))))))))));
[beforeMarker] Binary expression 75 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (false ? 1 : 75 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(75 - 1))))))))))))))))))))))))));
[afterMarker] Binary expression 75 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (false ? 1 : 75 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(75 - 1))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(75 - 1))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(75 - 1))))))))))))))))))))))))));
[beforeMarker] Binary expression 75 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(74))))))))))))))))))))))))));
[afterMarker] Binary expression 75 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(74))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 74 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 === 1 ? 1 : 74 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(74 - 1)))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 74 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 === 1 ? 1 : 74 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(74 - 1)))))))))))))))))))))))))));
[beforeMarker] Binary expression 74 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (false ? 1 : 74 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(74 - 1)))))))))))))))))))))))))));
[afterMarker] Binary expression 74 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (false ? 1 : 74 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(74 - 1)))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(74 - 1)))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(74 - 1)))))))))))))))))))))))))));
[beforeMarker] Binary expression 74 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(73)))))))))))))))))))))))))));
[afterMarker] Binary expression 74 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(73)))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 73 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 === 1 ? 1 : 73 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(73 - 1))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 73 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 === 1 ? 1 : 73 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(73 - 1))))))))))))))))))))))))))));
[beforeMarker] Binary expression 73 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (false ? 1 : 73 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(73 - 1))))))))))))))))))))))))))));
[afterMarker] Binary expression 73 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (false ? 1 : 73 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(73 - 1))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(73 - 1))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(73 - 1))))))))))))))))))))))))))));
[beforeMarker] Binary expression 73 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(72))))))))))))))))))))))))))));
[afterMarker] Binary expression 73 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(72))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 72 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 === 1 ? 1 : 72 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(72 - 1)))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 72 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 === 1 ? 1 : 72 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(72 - 1)))))))))))))))))))))))))))));
[beforeMarker] Binary expression 72 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (false ? 1 : 72 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(72 - 1)))))))))))))))))))))))))))));
[afterMarker] Binary expression 72 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (false ? 1 : 72 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(72 - 1)))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(72 - 1)))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(72 - 1)))))))))))))))))))))))))))));
[beforeMarker] Binary expression 72 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(71)))))))))))))))))))))))))))));
[afterMarker] Binary expression 72 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(71)))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 71 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 === 1 ? 1 : 71 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(71 - 1))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 71 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 === 1 ? 1 : 71 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(71 - 1))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 71 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (false ? 1 : 71 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(71 - 1))))))))))))))))))))))))))))));
[afterMarker] Binary expression 71 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (false ? 1 : 71 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(71 - 1))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(71 - 1))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(71 - 1))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 71 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(70))))))))))))))))))))))))))))));
[afterMarker] Binary expression 71 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(70))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 70 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 === 1 ? 1 : 70 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(70 - 1)))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 70 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 === 1 ? 1 : 70 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(70 - 1)))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 70 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (false ? 1 : 70 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(70 - 1)))))))))))))))))))))))))))))));
[afterMarker] Binary expression 70 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (false ? 1 : 70 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(70 - 1)))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(70 - 1)))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(70 - 1)))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 70 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(69)))))))))))))))))))))))))))))));
[afterMarker] Binary expression 70 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(69)))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 69 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 === 1 ? 1 : 69 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(69 - 1))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 69 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 === 1 ? 1 : 69 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(69 - 1))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 69 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (false ? 1 : 69 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(69 - 1))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 69 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (false ? 1 : 69 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(69 - 1))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(69 - 1))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(69 - 1))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 69 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(68))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 69 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(68))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 68 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 === 1 ? 1 : 68 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(68 - 1)))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 68 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 === 1 ? 1 : 68 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(68 - 1)))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 68 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (false ? 1 : 68 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(68 - 1)))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 68 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (false ? 1 : 68 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(68 - 1)))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(68 - 1)))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(68 - 1)))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 68 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(67)))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 68 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(67)))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 67 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 === 1 ? 1 : 67 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(67 - 1))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 67 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 === 1 ? 1 : 67 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(67 - 1))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 67 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (false ? 1 : 67 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(67 - 1))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 67 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (false ? 1 : 67 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(67 - 1))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(67 - 1))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(67 - 1))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 67 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(66))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 67 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(66))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 66 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 === 1 ? 1 : 66 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(66 - 1)))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 66 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 === 1 ? 1 : 66 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(66 - 1)))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 66 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (false ? 1 : 66 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(66 - 1)))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 66 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (false ? 1 : 66 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(66 - 1)))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(66 - 1)))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(66 - 1)))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 66 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(65)))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 66 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(65)))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 65 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 === 1 ? 1 : 65 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(65 - 1))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 65 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 === 1 ? 1 : 65 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(65 - 1))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 65 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (false ? 1 : 65 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(65 - 1))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 65 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (false ? 1 : 65 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(65 - 1))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(65 - 1))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(65 - 1))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 65 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(64))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 65 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(64))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 64 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 === 1 ? 1 : 64 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(64 - 1)))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 64 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 === 1 ? 1 : 64 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(64 - 1)))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 64 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (false ? 1 : 64 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(64 - 1)))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 64 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (false ? 1 : 64 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(64 - 1)))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(64 - 1)))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(64 - 1)))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 64 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(63)))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 64 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(63)))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 63 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 === 1 ? 1 : 63 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(63 - 1))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 63 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 === 1 ? 1 : 63 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(63 - 1))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 63 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (false ? 1 : 63 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(63 - 1))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 63 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (false ? 1 : 63 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(63 - 1))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(63 - 1))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(63 - 1))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 63 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(62))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 63 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(62))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 62 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 === 1 ? 1 : 62 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(62 - 1)))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 62 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 === 1 ? 1 : 62 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(62 - 1)))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 62 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (false ? 1 : 62 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(62 - 1)))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 62 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (false ? 1 : 62 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(62 - 1)))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(62 - 1)))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(62 - 1)))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 62 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(61)))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 62 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(61)))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 61 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 === 1 ? 1 : 61 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(61 - 1))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 61 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 === 1 ? 1 : 61 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(61 - 1))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 61 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (false ? 1 : 61 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(61 - 1))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 61 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (false ? 1 : 61 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(61 - 1))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(61 - 1))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(61 - 1))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 61 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(60))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 61 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(60))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 60 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 === 1 ? 1 : 60 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(60 - 1)))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 60 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 === 1 ? 1 : 60 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(60 - 1)))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 60 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (false ? 1 : 60 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(60 - 1)))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 60 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (false ? 1 : 60 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(60 - 1)))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(60 - 1)))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(60 - 1)))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 60 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(59)))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 60 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(59)))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 59 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 === 1 ? 1 : 59 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(59 - 1))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 59 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 === 1 ? 1 : 59 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(59 - 1))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 59 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (false ? 1 : 59 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(59 - 1))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 59 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (false ? 1 : 59 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(59 - 1))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(59 - 1))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(59 - 1))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 59 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(58))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 59 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(58))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 58 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 === 1 ? 1 : 58 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(58 - 1)))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 58 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 === 1 ? 1 : 58 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(58 - 1)))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 58 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (false ? 1 : 58 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(58 - 1)))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 58 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (false ? 1 : 58 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(58 - 1)))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(58 - 1)))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(58 - 1)))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 58 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(57)))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 58 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(57)))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 57 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 === 1 ? 1 : 57 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(57 - 1))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 57 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 === 1 ? 1 : 57 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(57 - 1))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 57 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (false ? 1 : 57 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(57 - 1))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 57 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (false ? 1 : 57 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(57 - 1))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(57 - 1))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(57 - 1))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 57 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(56))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 57 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(56))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 56 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 === 1 ? 1 : 56 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(56 - 1)))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 56 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 === 1 ? 1 : 56 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(56 - 1)))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 56 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (false ? 1 : 56 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(56 - 1)))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 56 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (false ? 1 : 56 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(56 - 1)))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(56 - 1)))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(56 - 1)))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 56 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(55)))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 56 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(55)))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 55 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 === 1 ? 1 : 55 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(55 - 1))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 55 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 === 1 ? 1 : 55 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(55 - 1))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 55 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (false ? 1 : 55 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(55 - 1))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 55 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (false ? 1 : 55 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(55 - 1))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(55 - 1))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(55 - 1))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 55 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(54))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 55 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(54))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 54 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 === 1 ? 1 : 54 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(54 - 1)))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 54 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 === 1 ? 1 : 54 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(54 - 1)))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 54 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (false ? 1 : 54 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(54 - 1)))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 54 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (false ? 1 : 54 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(54 - 1)))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(54 - 1)))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(54 - 1)))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 54 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(53)))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 54 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(53)))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 53 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 === 1 ? 1 : 53 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(53 - 1))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 53 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 === 1 ? 1 : 53 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(53 - 1))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 53 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (false ? 1 : 53 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(53 - 1))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 53 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (false ? 1 : 53 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(53 - 1))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(53 - 1))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(53 - 1))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 53 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(52))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 53 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(52))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 52 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 === 1 ? 1 : 52 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(52 - 1)))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 52 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 === 1 ? 1 : 52 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(52 - 1)))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 52 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (false ? 1 : 52 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(52 - 1)))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 52 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (false ? 1 : 52 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(52 - 1)))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(52 - 1)))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(52 - 1)))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 52 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(51)))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 52 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(51)))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 51 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 === 1 ? 1 : 51 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(51 - 1))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 51 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 === 1 ? 1 : 51 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(51 - 1))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 51 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (false ? 1 : 51 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(51 - 1))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 51 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (false ? 1 : 51 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(51 - 1))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(51 - 1))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(51 - 1))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 51 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(50))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 51 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(50))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 50 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 === 1 ? 1 : 50 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(50 - 1)))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 50 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 === 1 ? 1 : 50 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(50 - 1)))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 50 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (false ? 1 : 50 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(50 - 1)))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 50 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (false ? 1 : 50 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(50 - 1)))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(50 - 1)))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(50 - 1)))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 50 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(49)))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 50 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(49)))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 49 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 === 1 ? 1 : 49 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(49 - 1))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 49 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 === 1 ? 1 : 49 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(49 - 1))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 49 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (false ? 1 : 49 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(49 - 1))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 49 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (false ? 1 : 49 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(49 - 1))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(49 - 1))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(49 - 1))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 49 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(48))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 49 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(48))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 48 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 === 1 ? 1 : 48 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(48 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 48 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 === 1 ? 1 : 48 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(48 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 48 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (false ? 1 : 48 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(48 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 48 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (false ? 1 : 48 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(48 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(48 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(48 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 48 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(47)))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 48 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(47)))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 47 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 === 1 ? 1 : 47 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(47 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 47 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 === 1 ? 1 : 47 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(47 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 47 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (false ? 1 : 47 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(47 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 47 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (false ? 1 : 47 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(47 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(47 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(47 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 47 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(46))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 47 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(46))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 46 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 === 1 ? 1 : 46 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(46 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 46 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 === 1 ? 1 : 46 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(46 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 46 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (false ? 1 : 46 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(46 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 46 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (false ? 1 : 46 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(46 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(46 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(46 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 46 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(45)))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 46 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(45)))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 45 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 === 1 ? 1 : 45 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(45 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 45 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 === 1 ? 1 : 45 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(45 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 45 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (false ? 1 : 45 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(45 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 45 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (false ? 1 : 45 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(45 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(45 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(45 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 45 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(44))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 45 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(44))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 44 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 === 1 ? 1 : 44 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(44 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 44 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 === 1 ? 1 : 44 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(44 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 44 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (false ? 1 : 44 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(44 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 44 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (false ? 1 : 44 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(44 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(44 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(44 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 44 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(43)))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 44 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(43)))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 43 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 === 1 ? 1 : 43 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(43 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 43 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 === 1 ? 1 : 43 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(43 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 43 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (false ? 1 : 43 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(43 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 43 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (false ? 1 : 43 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(43 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(43 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(43 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 43 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(42))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 43 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(42))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 42 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 === 1 ? 1 : 42 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(42 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 42 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 === 1 ? 1 : 42 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(42 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 42 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (false ? 1 : 42 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(42 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 42 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (false ? 1 : 42 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(42 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(42 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(42 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 42 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(41)))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 42 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(41)))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 41 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 === 1 ? 1 : 41 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(41 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 41 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 === 1 ? 1 : 41 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(41 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 41 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (false ? 1 : 41 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(41 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 41 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (false ? 1 : 41 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(41 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(41 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(41 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 41 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(40))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 41 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(40))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 40 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 === 1 ? 1 : 40 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(40 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 40 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 === 1 ? 1 : 40 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(40 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 40 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (false ? 1 : 40 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(40 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 40 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (false ? 1 : 40 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(40 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(40 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(40 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 40 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(39)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 40 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(39)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 39 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 === 1 ? 1 : 39 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(39 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 39 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 === 1 ? 1 : 39 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(39 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 39 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (false ? 1 : 39 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(39 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 39 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (false ? 1 : 39 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(39 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(39 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(39 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 39 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(38))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 39 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(38))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 38 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 === 1 ? 1 : 38 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(38 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 38 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 === 1 ? 1 : 38 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(38 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 38 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (false ? 1 : 38 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(38 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 38 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (false ? 1 : 38 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(38 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(38 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(38 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 38 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(37)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 38 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(37)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 37 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 === 1 ? 1 : 37 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(37 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 37 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 === 1 ? 1 : 37 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(37 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 37 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (false ? 1 : 37 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(37 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 37 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (false ? 1 : 37 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(37 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(37 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(37 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 37 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(36))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 37 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(36))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 36 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 === 1 ? 1 : 36 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(36 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 36 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 === 1 ? 1 : 36 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(36 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 36 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (false ? 1 : 36 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(36 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 36 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (false ? 1 : 36 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(36 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(36 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(36 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 36 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(35)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 36 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(35)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 35 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 === 1 ? 1 : 35 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(35 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 35 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 === 1 ? 1 : 35 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(35 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 35 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (false ? 1 : 35 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(35 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 35 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (false ? 1 : 35 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(35 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(35 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(35 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 35 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(34))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 35 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(34))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 34 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 === 1 ? 1 : 34 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(34 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 34 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 === 1 ? 1 : 34 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(34 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 34 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (false ? 1 : 34 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(34 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 34 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (false ? 1 : 34 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(34 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(34 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(34 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 34 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(33)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 34 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(33)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 33 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 === 1 ? 1 : 33 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(33 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 33 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 === 1 ? 1 : 33 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(33 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 33 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (false ? 1 : 33 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(33 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 33 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (false ? 1 : 33 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(33 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(33 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(33 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 33 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(32))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 33 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(32))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 32 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 === 1 ? 1 : 32 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(32 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 32 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 === 1 ? 1 : 32 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(32 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 32 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (false ? 1 : 32 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(32 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 32 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (false ? 1 : 32 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(32 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(32 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(32 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 32 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(31)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 32 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(31)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 31 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 === 1 ? 1 : 31 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(31 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 31 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 === 1 ? 1 : 31 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(31 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 31 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (false ? 1 : 31 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(31 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 31 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (false ? 1 : 31 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(31 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(31 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(31 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 31 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(30))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 31 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(30))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 30 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 === 1 ? 1 : 30 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(30 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 30 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 === 1 ? 1 : 30 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(30 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 30 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (false ? 1 : 30 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(30 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 30 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (false ? 1 : 30 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(30 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(30 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(30 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 30 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(29)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 30 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(29)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 29 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 === 1 ? 1 : 29 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(29 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 29 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 === 1 ? 1 : 29 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(29 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 29 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (false ? 1 : 29 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(29 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 29 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (false ? 1 : 29 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(29 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(29 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(29 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 29 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(28))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 29 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(28))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 28 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 === 1 ? 1 : 28 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(28 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 28 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 === 1 ? 1 : 28 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(28 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 28 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (false ? 1 : 28 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(28 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 28 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (false ? 1 : 28 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(28 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(28 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(28 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 28 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(27)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 28 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(27)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 27 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 === 1 ? 1 : 27 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(27 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 27 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 === 1 ? 1 : 27 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(27 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 27 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (false ? 1 : 27 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(27 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 27 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (false ? 1 : 27 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(27 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(27 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(27 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 27 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(26))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 27 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(26))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 26 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 === 1 ? 1 : 26 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(26 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 26 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 === 1 ? 1 : 26 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(26 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 26 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (false ? 1 : 26 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(26 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 26 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (false ? 1 : 26 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(26 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(26 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(26 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 26 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(25)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 26 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(25)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 25 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 === 1 ? 1 : 25 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(25 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 25 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 === 1 ? 1 : 25 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(25 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 25 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (false ? 1 : 25 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(25 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 25 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (false ? 1 : 25 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(25 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(25 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(25 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 25 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(24))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 25 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(24))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 24 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 === 1 ? 1 : 24 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(24 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 24 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 === 1 ? 1 : 24 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(24 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 24 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (false ? 1 : 24 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(24 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 24 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (false ? 1 : 24 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(24 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(24 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(24 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 24 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(23)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 24 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(23)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 23 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 === 1 ? 1 : 23 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(23 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 23 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 === 1 ? 1 : 23 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(23 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 23 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (false ? 1 : 23 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(23 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 23 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (false ? 1 : 23 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(23 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(23 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(23 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 23 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(22))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 23 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(22))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 22 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 === 1 ? 1 : 22 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(22 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 22 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 === 1 ? 1 : 22 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(22 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 22 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (false ? 1 : 22 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(22 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 22 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (false ? 1 : 22 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(22 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(22 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(22 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 22 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(21)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 22 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(21)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 21 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 === 1 ? 1 : 21 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(21 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 21 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 === 1 ? 1 : 21 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(21 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 21 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (false ? 1 : 21 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(21 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 21 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (false ? 1 : 21 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(21 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(21 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(21 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 21 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(20))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 21 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(20))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 20 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 === 1 ? 1 : 20 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(20 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 20 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 === 1 ? 1 : 20 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(20 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 20 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (false ? 1 : 20 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(20 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 20 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (false ? 1 : 20 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(20 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(20 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(20 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 20 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(19)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 20 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(19)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 19 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 === 1 ? 1 : 19 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(19 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 19 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 === 1 ? 1 : 19 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(19 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 19 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (false ? 1 : 19 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(19 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 19 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (false ? 1 : 19 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(19 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(19 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(19 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 19 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(18))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 19 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(18))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 18 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 === 1 ? 1 : 18 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(18 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 18 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 === 1 ? 1 : 18 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(18 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 18 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (false ? 1 : 18 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(18 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 18 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (false ? 1 : 18 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(18 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(18 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(18 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 18 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(17)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 18 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(17)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 17 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 === 1 ? 1 : 17 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(17 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 17 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 === 1 ? 1 : 17 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(17 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 17 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (false ? 1 : 17 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(17 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 17 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (false ? 1 : 17 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(17 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(17 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(17 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 17 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(16))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 17 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(16))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 16 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 === 1 ? 1 : 16 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(16 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 16 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 === 1 ? 1 : 16 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(16 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 16 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (false ? 1 : 16 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(16 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 16 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (false ? 1 : 16 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(16 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(16 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(16 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 16 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(15)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 16 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(15)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 15 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 === 1 ? 1 : 15 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(15 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 15 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 === 1 ? 1 : 15 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(15 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 15 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (false ? 1 : 15 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(15 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 15 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (false ? 1 : 15 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(15 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(15 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(15 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 15 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(14))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 15 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(14))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 14 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 === 1 ? 1 : 14 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(14 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 14 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 === 1 ? 1 : 14 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(14 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 14 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (false ? 1 : 14 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(14 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 14 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (false ? 1 : 14 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(14 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(14 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(14 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 14 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(13)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 14 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(13)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 13 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 === 1 ? 1 : 13 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(13 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 13 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 === 1 ? 1 : 13 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(13 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 13 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (false ? 1 : 13 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(13 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 13 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (false ? 1 : 13 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(13 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(13 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(13 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 13 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(12))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 13 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(12))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 12 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 === 1 ? 1 : 12 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(12 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 12 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 === 1 ? 1 : 12 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(12 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 12 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (false ? 1 : 12 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(12 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 12 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (false ? 1 : 12 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(12 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(12 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(12 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 12 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(11)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 12 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(11)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 11 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 === 1 ? 1 : 11 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(11 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 11 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 === 1 ? 1 : 11 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(11 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 11 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (false ? 1 : 11 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(11 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 11 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (false ? 1 : 11 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(11 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(11 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(11 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 11 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(10))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 11 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(10))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 10 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 === 1 ? 1 : 10 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(10 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 10 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 === 1 ? 1 : 10 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(10 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 10 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (false ? 1 : 10 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(10 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 10 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (false ? 1 : 10 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(10 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(10 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(10 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 10 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(9)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 10 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(9)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 9 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 === 1 ? 1 : 9 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(9 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 9 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 === 1 ? 1 : 9 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(9 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 9 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (false ? 1 : 9 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(9 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 9 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (false ? 1 : 9 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(9 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(9 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(9 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 9 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(8))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 9 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(8))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 8 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 === 1 ? 1 : 8 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(8 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 8 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 === 1 ? 1 : 8 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(8 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 8 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (false ? 1 : 8 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(8 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 8 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (false ? 1 : 8 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(8 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(8 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(8 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 8 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(7)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 8 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(7)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 7 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 === 1 ? 1 : 7 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(7 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 7 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 === 1 ? 1 : 7 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(7 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 7 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (false ? 1 : 7 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(7 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 7 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (false ? 1 : 7 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(7 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(7 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(7 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 7 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(6))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 7 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(6))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 6 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 === 1 ? 1 : 6 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(6 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 6 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 === 1 ? 1 : 6 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(6 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 6 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (false ? 1 : 6 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(6 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 6 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (false ? 1 : 6 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(6 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(6 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(6 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 6 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(5)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 6 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(5)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 5 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 === 1 ? 1 : 5 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(5 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 5 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 === 1 ? 1 : 5 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(5 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 5 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (false ? 1 : 5 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(5 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 5 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (false ? 1 : 5 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(5 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(5 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(5 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 5 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(4))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 5 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(4))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 4 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 === 1 ? 1 : 4 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(4 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 4 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 === 1 ? 1 : 4 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(4 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 4 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (false ? 1 : 4 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(4 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 4 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (false ? 1 : 4 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(4 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(4 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(4 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 4 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(3)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 4 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(3)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 3 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 === 1 ? 1 : 3 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(3 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 3 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 === 1 ? 1 : 3 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(3 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 3 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (false ? 1 : 3 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(3 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 3 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (false ? 1 : 3 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(3 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(3 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(3 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 3 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(2))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 3 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(2))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 2 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * (2 === 1 ? 1 : 2 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(2 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 2 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * (2 === 1 ? 1 : 2 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(2 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 2 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * (false ? 1 : 2 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(2 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 2 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * (false ? 1 : 2 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(2 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * (2 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(2 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * (2 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(2 - 1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 2 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * (2 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 2 - 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * (2 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Function factorial takes in 1 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * (2 * (1 === 1 ? 1 : 1 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(1 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Function factorial takes in 1 as input n

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * (2 * (1 === 1 ? 1 : 1 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(1 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 1 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * (2 * (true ? 1 : 1 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(1 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 1 === 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * (2 * (true ? 1 : 1 * (n => { return n === 1 ? 1 : n * factorial(n - 1);})(1 - 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * (2 * 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * (2 * 1))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 2 * 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * 2)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 2 * 1 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * (3 * 2)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 3 * 2 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * 6))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 3 * 2 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * (4 * 6))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 4 * 6 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * 24)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 4 * 6 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * (5 * 24)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 5 * 24 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * 120))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 5 * 24 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * (6 * 120))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 6 * 120 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * 720)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 6 * 120 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * (7 * 720)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 7 * 720 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * 5040))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 7 * 720 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * (8 * 5040))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 8 * 5040 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * 40320)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 8 * 5040 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * (9 * 40320)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 9 * 40320 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * 362880))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 9 * 40320 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * (10 * 362880))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 10 * 362880 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * 3628800)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 10 * 362880 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * (11 * 3628800)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 11 * 3628800 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * 39916800))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 11 * 3628800 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * (12 * 39916800))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 12 * 39916800 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * 479001600)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 12 * 39916800 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * (13 * 479001600)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 13 * 479001600 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * 6227020800))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 13 * 479001600 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * (14 * 6227020800))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 14 * 6227020800 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * 87178291200)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 14 * 6227020800 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * (15 * 87178291200)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 15 * 87178291200 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * 1307674368000))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 15 * 87178291200 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * (16 * 1307674368000))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 16 * 1307674368000 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * 20922789888000)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 16 * 1307674368000 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * (17 * 20922789888000)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 17 * 20922789888000 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * 355687428096000))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 17 * 20922789888000 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * (18 * 355687428096000))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 18 * 355687428096000 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * 6402373705728000)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 18 * 355687428096000 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * (19 * 6402373705728000)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 19 * 6402373705728000 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * 121645100408832000))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 19 * 6402373705728000 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * (20 * 121645100408832000))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 20 * 121645100408832000 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * 2432902008176640000)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 20 * 121645100408832000 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * (21 * 2432902008176640000)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 21 * 2432902008176640000 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * 51090942171709440000))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 21 * 2432902008176640000 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * (22 * 51090942171709440000))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 22 * 51090942171709440000 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * 1.1240007277776077e+21)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 22 * 51090942171709440000 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * (23 * 1.1240007277776077e+21)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 23 * 1.1240007277776077e+21 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * 2.585201673888498e+22))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 23 * 1.1240007277776077e+21 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * (24 * 2.585201673888498e+22))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 24 * 2.585201673888498e+22 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * 6.204484017332394e+23)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 24 * 2.585201673888498e+22 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * (25 * 6.204484017332394e+23)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 25 * 6.204484017332394e+23 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * 1.5511210043330986e+25))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 25 * 6.204484017332394e+23 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * (26 * 1.5511210043330986e+25))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 26 * 1.5511210043330986e+25 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * 4.0329146112660565e+26)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 26 * 1.5511210043330986e+25 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * (27 * 4.0329146112660565e+26)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 27 * 4.0329146112660565e+26 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * 1.0888869450418352e+28))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 27 * 4.0329146112660565e+26 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * (28 * 1.0888869450418352e+28))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 28 * 1.0888869450418352e+28 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * 3.0488834461171384e+29)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 28 * 1.0888869450418352e+28 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * (29 * 3.0488834461171384e+29)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 29 * 3.0488834461171384e+29 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * 8.841761993739701e+30))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 29 * 3.0488834461171384e+29 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * (30 * 8.841761993739701e+30))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 30 * 8.841761993739701e+30 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * 2.6525285981219103e+32)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 30 * 8.841761993739701e+30 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * (31 * 2.6525285981219103e+32)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 31 * 2.6525285981219103e+32 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * 8.222838654177922e+33))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 31 * 2.6525285981219103e+32 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * (32 * 8.222838654177922e+33))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 32 * 8.222838654177922e+33 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * 2.631308369336935e+35)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 32 * 8.222838654177922e+33 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * (33 * 2.631308369336935e+35)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 33 * 2.631308369336935e+35 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * 8.683317618811886e+36))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 33 * 2.631308369336935e+35 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * (34 * 8.683317618811886e+36))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 34 * 8.683317618811886e+36 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * 2.9523279903960412e+38)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 34 * 8.683317618811886e+36 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * (35 * 2.9523279903960412e+38)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 35 * 2.9523279903960412e+38 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * 1.0333147966386144e+40))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 35 * 2.9523279903960412e+38 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * (36 * 1.0333147966386144e+40))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 36 * 1.0333147966386144e+40 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * 3.719933267899012e+41)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 36 * 1.0333147966386144e+40 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * (37 * 3.719933267899012e+41)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 37 * 3.719933267899012e+41 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * 1.3763753091226343e+43))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 37 * 3.719933267899012e+41 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * (38 * 1.3763753091226343e+43))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 38 * 1.3763753091226343e+43 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * 5.23022617466601e+44)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 38 * 1.3763753091226343e+43 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * (39 * 5.23022617466601e+44)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 39 * 5.23022617466601e+44 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * 2.0397882081197442e+46))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 39 * 5.23022617466601e+44 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * (40 * 2.0397882081197442e+46))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 40 * 2.0397882081197442e+46 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * 8.159152832478977e+47)))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 40 * 2.0397882081197442e+46 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * (41 * 8.159152832478977e+47)))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 41 * 8.159152832478977e+47 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * 3.3452526613163803e+49))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 41 * 8.159152832478977e+47 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * (42 * 3.3452526613163803e+49))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 42 * 3.3452526613163803e+49 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * 1.4050061177528798e+51)))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 42 * 3.3452526613163803e+49 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * (43 * 1.4050061177528798e+51)))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 43 * 1.4050061177528798e+51 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * 6.041526306337383e+52))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 43 * 1.4050061177528798e+51 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * (44 * 6.041526306337383e+52))))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 44 * 6.041526306337383e+52 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * 2.6582715747884485e+54)))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 44 * 6.041526306337383e+52 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * (45 * 2.6582715747884485e+54)))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 45 * 2.6582715747884485e+54 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * 1.1962222086548019e+56))))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 45 * 2.6582715747884485e+54 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * (46 * 1.1962222086548019e+56))))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 46 * 1.1962222086548019e+56 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * 5.5026221598120885e+57)))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 46 * 1.1962222086548019e+56 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * (47 * 5.5026221598120885e+57)))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 47 * 5.5026221598120885e+57 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * 2.5862324151116818e+59))))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 47 * 5.5026221598120885e+57 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * (48 * 2.5862324151116818e+59))))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 48 * 2.5862324151116818e+59 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * 1.2413915592536073e+61)))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 48 * 2.5862324151116818e+59 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * (49 * 1.2413915592536073e+61)))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 49 * 1.2413915592536073e+61 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * 6.082818640342675e+62))))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 49 * 1.2413915592536073e+61 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * (50 * 6.082818640342675e+62))))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 50 * 6.082818640342675e+62 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * 3.0414093201713376e+64)))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 50 * 6.082818640342675e+62 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * (51 * 3.0414093201713376e+64)))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 51 * 3.0414093201713376e+64 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * 1.5511187532873822e+66))))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 51 * 3.0414093201713376e+64 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * (52 * 1.5511187532873822e+66))))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 52 * 1.5511187532873822e+66 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * 8.065817517094388e+67)))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 52 * 1.5511187532873822e+66 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * (53 * 8.065817517094388e+67)))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 53 * 8.065817517094388e+67 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * 4.2748832840600255e+69))))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 53 * 8.065817517094388e+67 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * (54 * 4.2748832840600255e+69))))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 54 * 4.2748832840600255e+69 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * 2.308436973392414e+71)))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 54 * 4.2748832840600255e+69 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * (55 * 2.308436973392414e+71)))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 55 * 2.308436973392414e+71 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * 1.2696403353658276e+73))))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 55 * 2.308436973392414e+71 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * (56 * 1.2696403353658276e+73))))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 56 * 1.2696403353658276e+73 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * 7.109985878048635e+74)))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 56 * 1.2696403353658276e+73 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * (57 * 7.109985878048635e+74)))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 57 * 7.109985878048635e+74 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * 4.052691950487722e+76))))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 57 * 7.109985878048635e+74 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * (58 * 4.052691950487722e+76))))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 58 * 4.052691950487722e+76 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * 2.350561331282879e+78)))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 58 * 4.052691950487722e+76 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * (59 * 2.350561331282879e+78)))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 59 * 2.350561331282879e+78 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * 1.3868311854568986e+80))))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 59 * 2.350561331282879e+78 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * (60 * 1.3868311854568986e+80))))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 60 * 1.3868311854568986e+80 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * 8.320987112741392e+81)))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 60 * 1.3868311854568986e+80 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * (61 * 8.320987112741392e+81)))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 61 * 8.320987112741392e+81 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * 5.075802138772248e+83))))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 61 * 8.320987112741392e+81 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * (62 * 5.075802138772248e+83))))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 62 * 5.075802138772248e+83 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * 3.146997326038794e+85)))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 62 * 5.075802138772248e+83 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * (63 * 3.146997326038794e+85)))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 63 * 3.146997326038794e+85 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * 1.98260831540444e+87))))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 63 * 3.146997326038794e+85 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * (64 * 1.98260831540444e+87))))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 64 * 1.98260831540444e+87 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * 1.2688693218588417e+89)))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 64 * 1.98260831540444e+87 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * (65 * 1.2688693218588417e+89)))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 65 * 1.2688693218588417e+89 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * 8.247650592082472e+90))))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 65 * 1.2688693218588417e+89 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * (66 * 8.247650592082472e+90))))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 66 * 8.247650592082472e+90 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * 5.443449390774431e+92)))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 66 * 8.247650592082472e+90 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * (67 * 5.443449390774431e+92)))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 67 * 5.443449390774431e+92 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * 3.647111091818868e+94))))))))))))))))))))))))))))))));
[afterMarker] Binary expression 67 * 5.443449390774431e+92 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * (68 * 3.647111091818868e+94))))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 68 * 3.647111091818868e+94 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * 2.4800355424368305e+96)))))))))))))))))))))))))))))));
[afterMarker] Binary expression 68 * 3.647111091818868e+94 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * (69 * 2.4800355424368305e+96)))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 69 * 2.4800355424368305e+96 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * 1.711224524281413e+98))))))))))))))))))))))))))))));
[afterMarker] Binary expression 69 * 2.4800355424368305e+96 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * (70 * 1.711224524281413e+98))))))))))))))))))))))))))))));
[beforeMarker] Binary expression 70 * 1.711224524281413e+98 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * 1.197857166996989e+100)))))))))))))))))))))))))))));
[afterMarker] Binary expression 70 * 1.711224524281413e+98 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * (71 * 1.197857166996989e+100)))))))))))))))))))))))))))));
[beforeMarker] Binary expression 71 * 1.197857166996989e+100 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * 8.504785885678622e+101))))))))))))))))))))))))))));
[afterMarker] Binary expression 71 * 1.197857166996989e+100 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * (72 * 8.504785885678622e+101))))))))))))))))))))))))))));
[beforeMarker] Binary expression 72 * 8.504785885678622e+101 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * 6.123445837688608e+103)))))))))))))))))))))))))));
[afterMarker] Binary expression 72 * 8.504785885678622e+101 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * (73 * 6.123445837688608e+103)))))))))))))))))))))))))));
[beforeMarker] Binary expression 73 * 6.123445837688608e+103 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * 4.4701154615126834e+105))))))))))))))))))))))))));
[afterMarker] Binary expression 73 * 6.123445837688608e+103 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * (74 * 4.4701154615126834e+105))))))))))))))))))))))))));
[beforeMarker] Binary expression 74 * 4.4701154615126834e+105 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * 3.3078854415193856e+107)))))))))))))))))))))))));
[afterMarker] Binary expression 74 * 4.4701154615126834e+105 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * (75 * 3.3078854415193856e+107)))))))))))))))))))))))));
[beforeMarker] Binary expression 75 * 3.3078854415193856e+107 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * 2.480914081139539e+109))))))))))))))))))))))));
[afterMarker] Binary expression 75 * 3.3078854415193856e+107 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * (76 * 2.480914081139539e+109))))))))))))))))))))))));
[beforeMarker] Binary expression 76 * 2.480914081139539e+109 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * 1.8854947016660498e+111)))))))))))))))))))))));
[afterMarker] Binary expression 76 * 2.480914081139539e+109 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * (77 * 1.8854947016660498e+111)))))))))))))))))))))));
[beforeMarker] Binary expression 77 * 1.8854947016660498e+111 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * 1.4518309202828584e+113))))))))))))))))))))));
[afterMarker] Binary expression 77 * 1.8854947016660498e+111 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * (78 * 1.4518309202828584e+113))))))))))))))))))))));
[beforeMarker] Binary expression 78 * 1.4518309202828584e+113 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * 1.1324281178206295e+115)))))))))))))))))))));
[afterMarker] Binary expression 78 * 1.4518309202828584e+113 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * (79 * 1.1324281178206295e+115)))))))))))))))))))));
[beforeMarker] Binary expression 79 * 1.1324281178206295e+115 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * 8.946182130782973e+116))))))))))))))))))));
[afterMarker] Binary expression 79 * 1.1324281178206295e+115 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * (80 * 8.946182130782973e+116))))))))))))))))))));
[beforeMarker] Binary expression 80 * 8.946182130782973e+116 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * 7.156945704626378e+118)))))))))))))))))));
[afterMarker] Binary expression 80 * 8.946182130782973e+116 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * (81 * 7.156945704626378e+118)))))))))))))))))));
[beforeMarker] Binary expression 81 * 7.156945704626378e+118 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * 5.797126020747366e+120))))))))))))))))));
[afterMarker] Binary expression 81 * 7.156945704626378e+118 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * (82 * 5.797126020747366e+120))))))))))))))))));
[beforeMarker] Binary expression 82 * 5.797126020747366e+120 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * 4.75364333701284e+122)))))))))))))))));
[afterMarker] Binary expression 82 * 5.797126020747366e+120 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * (83 * 4.75364333701284e+122)))))))))))))))));
[beforeMarker] Binary expression 83 * 4.75364333701284e+122 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * 3.945523969720657e+124))))))))))))))));
[afterMarker] Binary expression 83 * 4.75364333701284e+122 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * (84 * 3.945523969720657e+124))))))))))))))));
[beforeMarker] Binary expression 84 * 3.945523969720657e+124 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * 3.314240134565352e+126)))))))))))))));
[afterMarker] Binary expression 84 * 3.945523969720657e+124 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * (85 * 3.314240134565352e+126)))))))))))))));
[beforeMarker] Binary expression 85 * 3.314240134565352e+126 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * 2.8171041143805494e+128))))))))))))));
[afterMarker] Binary expression 85 * 3.314240134565352e+126 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * (86 * 2.8171041143805494e+128))))))))))))));
[beforeMarker] Binary expression 86 * 2.8171041143805494e+128 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * 2.4227095383672724e+130)))))))))))));
[afterMarker] Binary expression 86 * 2.8171041143805494e+128 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * (87 * 2.4227095383672724e+130)))))))))))));
[beforeMarker] Binary expression 87 * 2.4227095383672724e+130 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * 2.107757298379527e+132))))))))))));
[afterMarker] Binary expression 87 * 2.4227095383672724e+130 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * (88 * 2.107757298379527e+132))))))))))));
[beforeMarker] Binary expression 88 * 2.107757298379527e+132 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * 1.8548264225739836e+134)))))))))));
[afterMarker] Binary expression 88 * 2.107757298379527e+132 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * (89 * 1.8548264225739836e+134)))))))))));
[beforeMarker] Binary expression 89 * 1.8548264225739836e+134 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * 1.6507955160908452e+136))))))))));
[afterMarker] Binary expression 89 * 1.8548264225739836e+134 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * (90 * 1.6507955160908452e+136))))))))));
[beforeMarker] Binary expression 90 * 1.6507955160908452e+136 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * 1.4857159644817607e+138)))))))));
[afterMarker] Binary expression 90 * 1.6507955160908452e+136 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * (91 * 1.4857159644817607e+138)))))))));
[beforeMarker] Binary expression 91 * 1.4857159644817607e+138 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * 1.3520015276784023e+140))))))));
[afterMarker] Binary expression 91 * 1.4857159644817607e+138 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * (92 * 1.3520015276784023e+140))))))));
[beforeMarker] Binary expression 92 * 1.3520015276784023e+140 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * 1.24384140546413e+142)))))));
[afterMarker] Binary expression 92 * 1.3520015276784023e+140 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * (93 * 1.24384140546413e+142)))))));
[beforeMarker] Binary expression 93 * 1.24384140546413e+142 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * 1.1567725070816409e+144))))));
[afterMarker] Binary expression 93 * 1.24384140546413e+142 evaluated

100 * (99 * (98 * (97 * (96 * (95 * (94 * 1.1567725070816409e+144))))));
[beforeMarker] Binary expression 94 * 1.1567725070816409e+144 evaluated

100 * (99 * (98 * (97 * (96 * (95 * 1.0873661566567424e+146)))));
[afterMarker] Binary expression 94 * 1.1567725070816409e+144 evaluated

100 * (99 * (98 * (97 * (96 * (95 * 1.0873661566567424e+146)))));
[beforeMarker] Binary expression 95 * 1.0873661566567424e+146 evaluated

100 * (99 * (98 * (97 * (96 * 1.0329978488239052e+148))));
[afterMarker] Binary expression 95 * 1.0873661566567424e+146 evaluated

100 * (99 * (98 * (97 * (96 * 1.0329978488239052e+148))));
[beforeMarker] Binary expression 96 * 1.0329978488239052e+148 evaluated

100 * (99 * (98 * (97 * 9.916779348709491e+149)));
[afterMarker] Binary expression 96 * 1.0329978488239052e+148 evaluated

100 * (99 * (98 * (97 * 9.916779348709491e+149)));
[beforeMarker] Binary expression 97 * 9.916779348709491e+149 evaluated

100 * (99 * (98 * 9.619275968248206e+151));
[afterMarker] Binary expression 97 * 9.916779348709491e+149 evaluated

100 * (99 * (98 * 9.619275968248206e+151));
[beforeMarker] Binary expression 98 * 9.619275968248206e+151 evaluated

100 * (99 * 9.426890448883242e+153);
[afterMarker] Binary expression 98 * 9.619275968248206e+151 evaluated

100 * (99 * 9.426890448883242e+153);
[beforeMarker] Binary expression 99 * 9.426890448883242e+153 evaluated

100 * 9.33262154439441e+155;
[afterMarker] Binary expression 99 * 9.426890448883242e+153 evaluated

100 * 9.33262154439441e+155;
[beforeMarker] Binary expression 100 * 9.33262154439441e+155 evaluated

9.33262154439441e+157;
[afterMarker] Binary expression 100 * 9.33262154439441e+155 evaluated

9.33262154439441e+157;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming Avoiding naming conflicts 1`] = `
"const f = (x_1, x_3, x_2) => g();const g = () => x_1 + x_3 + x_2;const x_1 = 1;const x_3 = 3;const x_2 = 2;f(0, 1, 2);
[noMarker] Start of evaluation

const f = (x_1, x_3, x_2) => g();const g = () => x_1 + x_3 + x_2;const x_1 = 1;const x_3 = 3;const x_2 = 2;f(0, 1, 2);
[beforeMarker] Constant f declared and substituted into the rest of block

const g = () => x_1 + x_3 + x_2;const x_1 = 1;const x_3 = 3;const x_2 = 2;((x_1, x_3, x_2) => g())(0, 1, 2);
[afterMarker] Constant f declared and substituted into the rest of block

const g = () => x_1 + x_3 + x_2;const x_1 = 1;const x_3 = 3;const x_2 = 2;((x_1, x_3, x_2) => g())(0, 1, 2);
[beforeMarker] Constant g declared and substituted into the rest of block

const x_1 = 1;const x_3 = 3;const x_2 = 2;((x_4, x_5, x_6) => (() => x_1 + x_3 + x_2)())(0, 1, 2);
[afterMarker] Constant g declared and substituted into the rest of block

const x_1 = 1;const x_3 = 3;const x_2 = 2;((x_4, x_5, x_6) => (() => x_1 + x_3 + x_2)())(0, 1, 2);
[beforeMarker] Constant x_1 declared and substituted into the rest of block

const x_3 = 3;const x_2 = 2;((x_4, x_5, x_6) => (() => 1 + x_3 + x_2)())(0, 1, 2);
[afterMarker] Constant x_1 declared and substituted into the rest of block

const x_3 = 3;const x_2 = 2;((x_4, x_5, x_6) => (() => 1 + x_3 + x_2)())(0, 1, 2);
[beforeMarker] Constant x_3 declared and substituted into the rest of block

const x_2 = 2;((x_4, x_5, x_6) => (() => 1 + 3 + x_2)())(0, 1, 2);
[afterMarker] Constant x_3 declared and substituted into the rest of block

const x_2 = 2;((x_4, x_5, x_6) => (() => 1 + 3 + x_2)())(0, 1, 2);
[beforeMarker] Constant x_2 declared and substituted into the rest of block

((x_4, x_5, x_6) => (() => 1 + 3 + 2)())(0, 1, 2);
[afterMarker] Constant x_2 declared and substituted into the rest of block

((x_4, x_5, x_6) => (() => 1 + 3 + 2)())(0, 1, 2);
[beforeMarker] 0, 1, 2 substituted into x_4, x_5, x_6 of (x_4, x_5, x_6) => (() => 1 + 3 + 2)()

(() => 1 + 3 + 2)();
[afterMarker] 0, 1, 2 substituted into x_4, x_5, x_6 of (x_4, x_5, x_6) => (() => 1 + 3 + 2)()

(() => 1 + 3 + 2)();
[beforeMarker] () => 1 + 3 + 2 runs

1 + 3 + 2;
[afterMarker] () => 1 + 3 + 2 runs

1 + 3 + 2;
[beforeMarker] Binary expression 1 + 3 evaluated

4 + 2;
[afterMarker] Binary expression 1 + 3 evaluated

4 + 2;
[beforeMarker] Binary expression 4 + 2 evaluated

6;
[afterMarker] Binary expression 4 + 2 evaluated

6;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming Basic 1`] = `
"const f = x => g();const g = () => x;const x = 1;f(0);
[noMarker] Start of evaluation

const f = x => g();const g = () => x;const x = 1;f(0);
[beforeMarker] Constant f declared and substituted into the rest of block

const g = () => x;const x = 1;(x => g())(0);
[afterMarker] Constant f declared and substituted into the rest of block

const g = () => x;const x = 1;(x => g())(0);
[beforeMarker] Constant g declared and substituted into the rest of block

const x = 1;(x_1 => (() => x)())(0);
[afterMarker] Constant g declared and substituted into the rest of block

const x = 1;(x_1 => (() => x)())(0);
[beforeMarker] Constant x declared and substituted into the rest of block

(x_1 => (() => 1)())(0);
[afterMarker] Constant x declared and substituted into the rest of block

(x_1 => (() => 1)())(0);
[beforeMarker] 0 substituted into x_1 of x_1 => (() => 1)()

(() => 1)();
[afterMarker] 0 substituted into x_1 of x_1 => (() => 1)()

(() => 1)();
[beforeMarker] () => 1 runs

1;
[afterMarker] () => 1 runs

1;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming multiple clash 2 for function declaration 1`] = `
"function g() { return x + x_1;}function f(x) { function h(x_1) { return x_2 + g(); } return h;}const x_2 = 0;const x_1 = 2;const x = 1;f(1)(1);
[noMarker] Start of evaluation

function g() { return x + x_1;}function f(x) { function h(x_1) { return x_2 + g(); } return h;}const x_2 = 0;const x_1 = 2;const x = 1;f(1)(1);
[beforeMarker] Function g declared, parameter(s)  required

function f(x_3) { function h(x_3) { return x_2 + (() => { return x + x_1; })(); } return h;}const x_2 = 0;const x_1 = 2;const x = 1;f(1)(1);
[afterMarker] Function g declared, parameter(s)  required

function f(x_3) { function h(x_3) { return x_2 + (() => { return x + x_1; })(); } return h;}const x_2 = 0;const x_1 = 2;const x = 1;f(1)(1);
[beforeMarker] Function f declared, parameter(s) x_3 required

const x_2 = 0;const x_1 = 2;const x = 1;(x_3 => { function h(x_3) { return x_2 + (() => { return x + x_1; })(); } return h;})(1)(1);
[afterMarker] Function f declared, parameter(s) x_3 required

const x_2 = 0;const x_1 = 2;const x = 1;(x_3 => { function h(x_3) { return x_2 + (() => { return x + x_1; })(); } return h;})(1)(1);
[beforeMarker] Constant x_2 declared and substituted into the rest of block

const x_1 = 2;const x = 1;(x_3 => { function h(x_3) { return 0 + (() => { return x + x_1; })(); } return h;})(1)(1);
[afterMarker] Constant x_2 declared and substituted into the rest of block

const x_1 = 2;const x = 1;(x_3 => { function h(x_3) { return 0 + (() => { return x + x_1; })(); } return h;})(1)(1);
[beforeMarker] Constant x_1 declared and substituted into the rest of block

const x = 1;(x_3 => { function h(x_3) { return 0 + (() => { return x + 2; })(); } return h;})(1)(1);
[afterMarker] Constant x_1 declared and substituted into the rest of block

const x = 1;(x_3 => { function h(x_3) { return 0 + (() => { return x + 2; })(); } return h;})(1)(1);
[beforeMarker] Constant x declared and substituted into the rest of block

(x_3 => { function h(x_3) { return 0 + (() => { return 1 + 2; })(); } return h;})(1)(1);
[afterMarker] Constant x declared and substituted into the rest of block

(x_3 => { function h(x_3) { return 0 + (() => { return 1 + 2; })(); } return h;})(1)(1);
[beforeMarker] Function f takes in 1 as input x_3

{ function h(x_3) { return 0 + (() => { return 1 + 2; })(); } return h;}(1);
[afterMarker] Function f takes in 1 as input x_3

{ function h(x_3) { return 0 + (() => { return 1 + 2; })(); } return h;}(1);
[beforeMarker] Function h declared, parameter(s) x_3 required

{ return x_3 => { return 0 + (() => { return 1 + 2; })(); };}(1);
[afterMarker] Function h declared, parameter(s) x_3 required

{ return x_3 => { return 0 + (() => { return 1 + 2; })(); };}(1);
[beforeMarker] x_3 => {
  return 0 + (() => {
    return 1 + 2;
  })();
} returned

(x_3 => { return 0 + (() => { return 1 + 2; })();})(1);
[afterMarker] x_3 => {
  return 0 + (() => {
    return 1 + 2;
  })();
} returned

(x_3 => { return 0 + (() => { return 1 + 2; })();})(1);
[beforeMarker] Function h takes in 1 as input x_3

0 + (() => { return 1 + 2;})();
[afterMarker] Function h takes in 1 as input x_3

0 + (() => { return 1 + 2;})();
[beforeMarker] () => {...} runs

0 + (1 + 2);
[afterMarker] () => {...} runs

0 + (1 + 2);
[beforeMarker] Binary expression 1 + 2 evaluated

0 + 3;
[afterMarker] Binary expression 1 + 2 evaluated

0 + 3;
[beforeMarker] Binary expression 0 + 3 evaluated

3;
[afterMarker] Binary expression 0 + 3 evaluated

3;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming multiple clash 2 for function expression 1`] = `
"function f(x) { function h(x_1) { return x_2 + g(); } return h;}function g() { return x + x_1;}const x_2 = 0;const x_1 = 2;const x = 1;f(1)(1);
[noMarker] Start of evaluation

function f(x) { function h(x_1) { return x_2 + g(); } return h;}function g() { return x + x_1;}const x_2 = 0;const x_1 = 2;const x = 1;f(1)(1);
[beforeMarker] Function f declared, parameter(s) x required

function g() { return x + x_1;}const x_2 = 0;const x_1 = 2;const x = 1;(x => { function h(x_1) { return x_2 + g(); } return h;})(1)(1);
[afterMarker] Function f declared, parameter(s) x required

function g() { return x + x_1;}const x_2 = 0;const x_1 = 2;const x = 1;(x => { function h(x_1) { return x_2 + g(); } return h;})(1)(1);
[beforeMarker] Function g declared, parameter(s)  required

const x_2 = 0;const x_1 = 2;const x = 1;(x_3 => { function h(x_3) { return x_2 + (() => { return x + x_1; })(); } return h;})(1)(1);
[afterMarker] Function g declared, parameter(s)  required

const x_2 = 0;const x_1 = 2;const x = 1;(x_3 => { function h(x_3) { return x_2 + (() => { return x + x_1; })(); } return h;})(1)(1);
[beforeMarker] Constant x_2 declared and substituted into the rest of block

const x_1 = 2;const x = 1;(x_3 => { function h(x_3) { return 0 + (() => { return x + x_1; })(); } return h;})(1)(1);
[afterMarker] Constant x_2 declared and substituted into the rest of block

const x_1 = 2;const x = 1;(x_3 => { function h(x_3) { return 0 + (() => { return x + x_1; })(); } return h;})(1)(1);
[beforeMarker] Constant x_1 declared and substituted into the rest of block

const x = 1;(x_3 => { function h(x_3) { return 0 + (() => { return x + 2; })(); } return h;})(1)(1);
[afterMarker] Constant x_1 declared and substituted into the rest of block

const x = 1;(x_3 => { function h(x_3) { return 0 + (() => { return x + 2; })(); } return h;})(1)(1);
[beforeMarker] Constant x declared and substituted into the rest of block

(x_3 => { function h(x_3) { return 0 + (() => { return 1 + 2; })(); } return h;})(1)(1);
[afterMarker] Constant x declared and substituted into the rest of block

(x_3 => { function h(x_3) { return 0 + (() => { return 1 + 2; })(); } return h;})(1)(1);
[beforeMarker] Function f takes in 1 as input x_3

{ function h(x_3) { return 0 + (() => { return 1 + 2; })(); } return h;}(1);
[afterMarker] Function f takes in 1 as input x_3

{ function h(x_3) { return 0 + (() => { return 1 + 2; })(); } return h;}(1);
[beforeMarker] Function h declared, parameter(s) x_3 required

{ return x_3 => { return 0 + (() => { return 1 + 2; })(); };}(1);
[afterMarker] Function h declared, parameter(s) x_3 required

{ return x_3 => { return 0 + (() => { return 1 + 2; })(); };}(1);
[beforeMarker] x_3 => {
  return 0 + (() => {
    return 1 + 2;
  })();
} returned

(x_3 => { return 0 + (() => { return 1 + 2; })();})(1);
[afterMarker] x_3 => {
  return 0 + (() => {
    return 1 + 2;
  })();
} returned

(x_3 => { return 0 + (() => { return 1 + 2; })();})(1);
[beforeMarker] Function h takes in 1 as input x_3

0 + (() => { return 1 + 2;})();
[afterMarker] Function h takes in 1 as input x_3

0 + (() => { return 1 + 2;})();
[beforeMarker] () => {...} runs

0 + (1 + 2);
[afterMarker] () => {...} runs

0 + (1 + 2);
[beforeMarker] Binary expression 1 + 2 evaluated

0 + 3;
[afterMarker] Binary expression 1 + 2 evaluated

0 + 3;
[beforeMarker] Binary expression 0 + 3 evaluated

3;
[afterMarker] Binary expression 0 + 3 evaluated

3;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming multiple clash 2 for lambda function 1`] = `
"const f = x => x_1 => x_2 + g();const g = () => x + x_1;const x_2 = 0;const x_1 = 2;const x = 1;f(1)(1);
[noMarker] Start of evaluation

const f = x => x_1 => x_2 + g();const g = () => x + x_1;const x_2 = 0;const x_1 = 2;const x = 1;f(1)(1);
[beforeMarker] Constant f declared and substituted into the rest of block

const g = () => x + x_1;const x_2 = 0;const x_1 = 2;const x = 1;(x => x_1 => x_2 + g())(1)(1);
[afterMarker] Constant f declared and substituted into the rest of block

const g = () => x + x_1;const x_2 = 0;const x_1 = 2;const x = 1;(x => x_1 => x_2 + g())(1)(1);
[beforeMarker] Constant g declared and substituted into the rest of block

const x_2 = 0;const x_1 = 2;const x = 1;(x_3 => x_4 => x_2 + (() => x + x_1)())(1)(1);
[afterMarker] Constant g declared and substituted into the rest of block

const x_2 = 0;const x_1 = 2;const x = 1;(x_3 => x_4 => x_2 + (() => x + x_1)())(1)(1);
[beforeMarker] Constant x_2 declared and substituted into the rest of block

const x_1 = 2;const x = 1;(x_3 => x_4 => 0 + (() => x + x_1)())(1)(1);
[afterMarker] Constant x_2 declared and substituted into the rest of block

const x_1 = 2;const x = 1;(x_3 => x_4 => 0 + (() => x + x_1)())(1)(1);
[beforeMarker] Constant x_1 declared and substituted into the rest of block

const x = 1;(x_3 => x_4 => 0 + (() => x + 2)())(1)(1);
[afterMarker] Constant x_1 declared and substituted into the rest of block

const x = 1;(x_3 => x_4 => 0 + (() => x + 2)())(1)(1);
[beforeMarker] Constant x declared and substituted into the rest of block

(x_3 => x_4 => 0 + (() => 1 + 2)())(1)(1);
[afterMarker] Constant x declared and substituted into the rest of block

(x_3 => x_4 => 0 + (() => 1 + 2)())(1)(1);
[beforeMarker] 1 substituted into x_3 of x_3 => x_4 => 0 + (() => 1 + 2)()

(x_4 => 0 + (() => 1 + 2)())(1);
[afterMarker] 1 substituted into x_3 of x_3 => x_4 => 0 + (() => 1 + 2)()

(x_4 => 0 + (() => 1 + 2)())(1);
[beforeMarker] 1 substituted into x_4 of x_4 => 0 + (() => 1 + 2)()

0 + (() => 1 + 2)();
[afterMarker] 1 substituted into x_4 of x_4 => 0 + (() => 1 + 2)()

0 + (() => 1 + 2)();
[beforeMarker] () => 1 + 2 runs

0 + (1 + 2);
[afterMarker] () => 1 + 2 runs

0 + (1 + 2);
[beforeMarker] Binary expression 1 + 2 evaluated

0 + 3;
[afterMarker] Binary expression 1 + 2 evaluated

0 + 3;
[beforeMarker] Binary expression 0 + 3 evaluated

3;
[afterMarker] Binary expression 0 + 3 evaluated

3;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming multiple clash for function declaration 1`] = `
"function g() { return x_2 + x_3;}function f(x_2) { function h(x_3) { return x_4 + g(); } return h;}const x_3 = 0;const x_2 = 2;const x_4 = 2;f(1)(1);
[noMarker] Start of evaluation

function g() { return x_2 + x_3;}function f(x_2) { function h(x_3) { return x_4 + g(); } return h;}const x_3 = 0;const x_2 = 2;const x_4 = 2;f(1)(1);
[beforeMarker] Function g declared, parameter(s)  required

function f(x_5) { function h(x_5) { return x_4 + (() => { return x_2 + x_3; })(); } return h;}const x_3 = 0;const x_2 = 2;const x_4 = 2;f(1)(1);
[afterMarker] Function g declared, parameter(s)  required

function f(x_5) { function h(x_5) { return x_4 + (() => { return x_2 + x_3; })(); } return h;}const x_3 = 0;const x_2 = 2;const x_4 = 2;f(1)(1);
[beforeMarker] Function f declared, parameter(s) x_5 required

const x_3 = 0;const x_2 = 2;const x_4 = 2;(x_5 => { function h(x_5) { return x_4 + (() => { return x_2 + x_3; })(); } return h;})(1)(1);
[afterMarker] Function f declared, parameter(s) x_5 required

const x_3 = 0;const x_2 = 2;const x_4 = 2;(x_5 => { function h(x_5) { return x_4 + (() => { return x_2 + x_3; })(); } return h;})(1)(1);
[beforeMarker] Constant x_3 declared and substituted into the rest of block

const x_2 = 2;const x_4 = 2;(x_5 => { function h(x_5) { return x_4 + (() => { return x_2 + 0; })(); } return h;})(1)(1);
[afterMarker] Constant x_3 declared and substituted into the rest of block

const x_2 = 2;const x_4 = 2;(x_5 => { function h(x_5) { return x_4 + (() => { return x_2 + 0; })(); } return h;})(1)(1);
[beforeMarker] Constant x_2 declared and substituted into the rest of block

const x_4 = 2;(x_5 => { function h(x_5) { return x_4 + (() => { return 2 + 0; })(); } return h;})(1)(1);
[afterMarker] Constant x_2 declared and substituted into the rest of block

const x_4 = 2;(x_5 => { function h(x_5) { return x_4 + (() => { return 2 + 0; })(); } return h;})(1)(1);
[beforeMarker] Constant x_4 declared and substituted into the rest of block

(x_5 => { function h(x_5) { return 2 + (() => { return 2 + 0; })(); } return h;})(1)(1);
[afterMarker] Constant x_4 declared and substituted into the rest of block

(x_5 => { function h(x_5) { return 2 + (() => { return 2 + 0; })(); } return h;})(1)(1);
[beforeMarker] Function f takes in 1 as input x_5

{ function h(x_5) { return 2 + (() => { return 2 + 0; })(); } return h;}(1);
[afterMarker] Function f takes in 1 as input x_5

{ function h(x_5) { return 2 + (() => { return 2 + 0; })(); } return h;}(1);
[beforeMarker] Function h declared, parameter(s) x_5 required

{ return x_5 => { return 2 + (() => { return 2 + 0; })(); };}(1);
[afterMarker] Function h declared, parameter(s) x_5 required

{ return x_5 => { return 2 + (() => { return 2 + 0; })(); };}(1);
[beforeMarker] x_5 => {
  return 2 + (() => {
    return 2 + 0;
  })();
} returned

(x_5 => { return 2 + (() => { return 2 + 0; })();})(1);
[afterMarker] x_5 => {
  return 2 + (() => {
    return 2 + 0;
  })();
} returned

(x_5 => { return 2 + (() => { return 2 + 0; })();})(1);
[beforeMarker] Function h takes in 1 as input x_5

2 + (() => { return 2 + 0;})();
[afterMarker] Function h takes in 1 as input x_5

2 + (() => { return 2 + 0;})();
[beforeMarker] () => {...} runs

2 + (2 + 0);
[afterMarker] () => {...} runs

2 + (2 + 0);
[beforeMarker] Binary expression 2 + 0 evaluated

2 + 2;
[afterMarker] Binary expression 2 + 0 evaluated

2 + 2;
[beforeMarker] Binary expression 2 + 2 evaluated

4;
[afterMarker] Binary expression 2 + 2 evaluated

4;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming multiple clash for function expression 1`] = `
"function f(x_2) { function h(x_3) { return x_4 + g(); } return h;}function g() { return x_2 + x_3;}const x_3 = 0;const x_2 = 2;const x_4 = 2;f(1)(1);
[noMarker] Start of evaluation

function f(x_2) { function h(x_3) { return x_4 + g(); } return h;}function g() { return x_2 + x_3;}const x_3 = 0;const x_2 = 2;const x_4 = 2;f(1)(1);
[beforeMarker] Function f declared, parameter(s) x_2 required

function g() { return x_2 + x_3;}const x_3 = 0;const x_2 = 2;const x_4 = 2;(x_2 => { function h(x_3) { return x_4 + g(); } return h;})(1)(1);
[afterMarker] Function f declared, parameter(s) x_2 required

function g() { return x_2 + x_3;}const x_3 = 0;const x_2 = 2;const x_4 = 2;(x_2 => { function h(x_3) { return x_4 + g(); } return h;})(1)(1);
[beforeMarker] Function g declared, parameter(s)  required

const x_3 = 0;const x_2 = 2;const x_4 = 2;(x_5 => { function h(x_5) { return x_4 + (() => { return x_2 + x_3; })(); } return h;})(1)(1);
[afterMarker] Function g declared, parameter(s)  required

const x_3 = 0;const x_2 = 2;const x_4 = 2;(x_5 => { function h(x_5) { return x_4 + (() => { return x_2 + x_3; })(); } return h;})(1)(1);
[beforeMarker] Constant x_3 declared and substituted into the rest of block

const x_2 = 2;const x_4 = 2;(x_5 => { function h(x_5) { return x_4 + (() => { return x_2 + 0; })(); } return h;})(1)(1);
[afterMarker] Constant x_3 declared and substituted into the rest of block

const x_2 = 2;const x_4 = 2;(x_5 => { function h(x_5) { return x_4 + (() => { return x_2 + 0; })(); } return h;})(1)(1);
[beforeMarker] Constant x_2 declared and substituted into the rest of block

const x_4 = 2;(x_5 => { function h(x_5) { return x_4 + (() => { return 2 + 0; })(); } return h;})(1)(1);
[afterMarker] Constant x_2 declared and substituted into the rest of block

const x_4 = 2;(x_5 => { function h(x_5) { return x_4 + (() => { return 2 + 0; })(); } return h;})(1)(1);
[beforeMarker] Constant x_4 declared and substituted into the rest of block

(x_5 => { function h(x_5) { return 2 + (() => { return 2 + 0; })(); } return h;})(1)(1);
[afterMarker] Constant x_4 declared and substituted into the rest of block

(x_5 => { function h(x_5) { return 2 + (() => { return 2 + 0; })(); } return h;})(1)(1);
[beforeMarker] Function f takes in 1 as input x_5

{ function h(x_5) { return 2 + (() => { return 2 + 0; })(); } return h;}(1);
[afterMarker] Function f takes in 1 as input x_5

{ function h(x_5) { return 2 + (() => { return 2 + 0; })(); } return h;}(1);
[beforeMarker] Function h declared, parameter(s) x_5 required

{ return x_5 => { return 2 + (() => { return 2 + 0; })(); };}(1);
[afterMarker] Function h declared, parameter(s) x_5 required

{ return x_5 => { return 2 + (() => { return 2 + 0; })(); };}(1);
[beforeMarker] x_5 => {
  return 2 + (() => {
    return 2 + 0;
  })();
} returned

(x_5 => { return 2 + (() => { return 2 + 0; })();})(1);
[afterMarker] x_5 => {
  return 2 + (() => {
    return 2 + 0;
  })();
} returned

(x_5 => { return 2 + (() => { return 2 + 0; })();})(1);
[beforeMarker] Function h takes in 1 as input x_5

2 + (() => { return 2 + 0;})();
[afterMarker] Function h takes in 1 as input x_5

2 + (() => { return 2 + 0;})();
[beforeMarker] () => {...} runs

2 + (2 + 0);
[afterMarker] () => {...} runs

2 + (2 + 0);
[beforeMarker] Binary expression 2 + 0 evaluated

2 + 2;
[afterMarker] Binary expression 2 + 0 evaluated

2 + 2;
[beforeMarker] Binary expression 2 + 2 evaluated

4;
[afterMarker] Binary expression 2 + 2 evaluated

4;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming multiple clash for lambda function 1`] = `
"const f = x_2 => x_3 => x_4 + g();const g = () => x_2 + x_3;const x_3 = 0;const x_2 = 2;const x_4 = 2;f(1)(1);
[noMarker] Start of evaluation

const f = x_2 => x_3 => x_4 + g();const g = () => x_2 + x_3;const x_3 = 0;const x_2 = 2;const x_4 = 2;f(1)(1);
[beforeMarker] Constant f declared and substituted into the rest of block

const g = () => x_2 + x_3;const x_3 = 0;const x_2 = 2;const x_4 = 2;(x_2 => x_3 => x_4 + g())(1)(1);
[afterMarker] Constant f declared and substituted into the rest of block

const g = () => x_2 + x_3;const x_3 = 0;const x_2 = 2;const x_4 = 2;(x_2 => x_3 => x_4 + g())(1)(1);
[beforeMarker] Constant g declared and substituted into the rest of block

const x_3 = 0;const x_2 = 2;const x_4 = 2;(x_5 => x_6 => x_4 + (() => x_2 + x_3)())(1)(1);
[afterMarker] Constant g declared and substituted into the rest of block

const x_3 = 0;const x_2 = 2;const x_4 = 2;(x_5 => x_6 => x_4 + (() => x_2 + x_3)())(1)(1);
[beforeMarker] Constant x_3 declared and substituted into the rest of block

const x_2 = 2;const x_4 = 2;(x_5 => x_6 => x_4 + (() => x_2 + 0)())(1)(1);
[afterMarker] Constant x_3 declared and substituted into the rest of block

const x_2 = 2;const x_4 = 2;(x_5 => x_6 => x_4 + (() => x_2 + 0)())(1)(1);
[beforeMarker] Constant x_2 declared and substituted into the rest of block

const x_4 = 2;(x_5 => x_6 => x_4 + (() => 2 + 0)())(1)(1);
[afterMarker] Constant x_2 declared and substituted into the rest of block

const x_4 = 2;(x_5 => x_6 => x_4 + (() => 2 + 0)())(1)(1);
[beforeMarker] Constant x_4 declared and substituted into the rest of block

(x_5 => x_6 => 2 + (() => 2 + 0)())(1)(1);
[afterMarker] Constant x_4 declared and substituted into the rest of block

(x_5 => x_6 => 2 + (() => 2 + 0)())(1)(1);
[beforeMarker] 1 substituted into x_5 of x_5 => x_6 => 2 + (() => 2 + 0)()

(x_6 => 2 + (() => 2 + 0)())(1);
[afterMarker] 1 substituted into x_5 of x_5 => x_6 => 2 + (() => 2 + 0)()

(x_6 => 2 + (() => 2 + 0)())(1);
[beforeMarker] 1 substituted into x_6 of x_6 => 2 + (() => 2 + 0)()

2 + (() => 2 + 0)();
[afterMarker] 1 substituted into x_6 of x_6 => 2 + (() => 2 + 0)()

2 + (() => 2 + 0)();
[beforeMarker] () => 2 + 0 runs

2 + (2 + 0);
[afterMarker] () => 2 + 0 runs

2 + (2 + 0);
[beforeMarker] Binary expression 2 + 0 evaluated

2 + 2;
[afterMarker] Binary expression 2 + 0 evaluated

2 + 2;
[beforeMarker] Binary expression 2 + 2 evaluated

4;
[afterMarker] Binary expression 2 + 2 evaluated

4;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming multiple clash for lambda function with block expression 1`] = `
"const f = x => { const x_1 = 1; return x_1 => x_2 + g();};const g = () => x + x_1;const x_2 = 0;const x_1 = 2;const x = 1;f(1)(1);
[noMarker] Start of evaluation

const f = x => { const x_1 = 1; return x_1 => x_2 + g();};const g = () => x + x_1;const x_2 = 0;const x_1 = 2;const x = 1;f(1)(1);
[beforeMarker] Constant f declared and substituted into the rest of block

const g = () => x + x_1;const x_2 = 0;const x_1 = 2;const x = 1;(x => { const x_1 = 1; return x_1 => x_2 + g();})(1)(1);
[afterMarker] Constant f declared and substituted into the rest of block

const g = () => x + x_1;const x_2 = 0;const x_1 = 2;const x = 1;(x => { const x_1 = 1; return x_1 => x_2 + g();})(1)(1);
[beforeMarker] Constant g declared and substituted into the rest of block

const x_2 = 0;const x_1 = 2;const x = 1;(x_3 => { const x_4 = 1; return x_4 => x_2 + (() => x + x_1)();})(1)(1);
[afterMarker] Constant g declared and substituted into the rest of block

const x_2 = 0;const x_1 = 2;const x = 1;(x_3 => { const x_4 = 1; return x_4 => x_2 + (() => x + x_1)();})(1)(1);
[beforeMarker] Constant x_2 declared and substituted into the rest of block

const x_1 = 2;const x = 1;(x_3 => { const x_4 = 1; return x_4 => 0 + (() => x + x_1)();})(1)(1);
[afterMarker] Constant x_2 declared and substituted into the rest of block

const x_1 = 2;const x = 1;(x_3 => { const x_4 = 1; return x_4 => 0 + (() => x + x_1)();})(1)(1);
[beforeMarker] Constant x_1 declared and substituted into the rest of block

const x = 1;(x_3 => { const x_4 = 1; return x_4 => 0 + (() => x + 2)();})(1)(1);
[afterMarker] Constant x_1 declared and substituted into the rest of block

const x = 1;(x_3 => { const x_4 = 1; return x_4 => 0 + (() => x + 2)();})(1)(1);
[beforeMarker] Constant x declared and substituted into the rest of block

(x_3 => { const x_4 = 1; return x_4 => 0 + (() => 1 + 2)();})(1)(1);
[afterMarker] Constant x declared and substituted into the rest of block

(x_3 => { const x_4 = 1; return x_4 => 0 + (() => 1 + 2)();})(1)(1);
[beforeMarker] Function f takes in 1 as input x_3

{ const x_4 = 1; return x_4 => 0 + (() => 1 + 2)();}(1);
[afterMarker] Function f takes in 1 as input x_3

{ const x_4 = 1; return x_4 => 0 + (() => 1 + 2)();}(1);
[beforeMarker] Constant x_4 declared and substituted into the rest of block

{ return x_4 => 0 + (() => 1 + 2)();}(1);
[afterMarker] Constant x_4 declared and substituted into the rest of block

{ return x_4 => 0 + (() => 1 + 2)();}(1);
[beforeMarker] x_4 => 0 + (() => 1 + 2)() returned

(x_4 => 0 + (() => 1 + 2)())(1);
[afterMarker] x_4 => 0 + (() => 1 + 2)() returned

(x_4 => 0 + (() => 1 + 2)())(1);
[beforeMarker] 1 substituted into x_4 of x_4 => 0 + (() => 1 + 2)()

0 + (() => 1 + 2)();
[afterMarker] 1 substituted into x_4 of x_4 => 0 + (() => 1 + 2)()

0 + (() => 1 + 2)();
[beforeMarker] () => 1 + 2 runs

0 + (1 + 2);
[afterMarker] () => 1 + 2 runs

0 + (1 + 2);
[beforeMarker] Binary expression 1 + 2 evaluated

0 + 3;
[afterMarker] Binary expression 1 + 2 evaluated

0 + 3;
[beforeMarker] Binary expression 0 + 3 evaluated

3;
[afterMarker] Binary expression 0 + 3 evaluated

3;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming renaming clash in replacement for function declaration 1`] = `
"function g() { return x_1 + x_2;}function f(x_1) { function h(x_2) { return g(); } return h;}const x_1 = 0;const x_2 = 0;f(1)(1);
[noMarker] Start of evaluation

function g() { return x_1 + x_2;}function f(x_1) { function h(x_2) { return g(); } return h;}const x_1 = 0;const x_2 = 0;f(1)(1);
[beforeMarker] Function g declared, parameter(s)  required

function f(x_3) { function h(x_3) { return (() => { return x_1 + x_2; })(); } return h;}const x_1 = 0;const x_2 = 0;f(1)(1);
[afterMarker] Function g declared, parameter(s)  required

function f(x_3) { function h(x_3) { return (() => { return x_1 + x_2; })(); } return h;}const x_1 = 0;const x_2 = 0;f(1)(1);
[beforeMarker] Function f declared, parameter(s) x_3 required

const x_1 = 0;const x_2 = 0;(x_3 => { function h(x_3) { return (() => { return x_1 + x_2; })(); } return h;})(1)(1);
[afterMarker] Function f declared, parameter(s) x_3 required

const x_1 = 0;const x_2 = 0;(x_3 => { function h(x_3) { return (() => { return x_1 + x_2; })(); } return h;})(1)(1);
[beforeMarker] Constant x_1 declared and substituted into the rest of block

const x_2 = 0;(x_3 => { function h(x_3) { return (() => { return 0 + x_2; })(); } return h;})(1)(1);
[afterMarker] Constant x_1 declared and substituted into the rest of block

const x_2 = 0;(x_3 => { function h(x_3) { return (() => { return 0 + x_2; })(); } return h;})(1)(1);
[beforeMarker] Constant x_2 declared and substituted into the rest of block

(x_3 => { function h(x_3) { return (() => { return 0 + 0; })(); } return h;})(1)(1);
[afterMarker] Constant x_2 declared and substituted into the rest of block

(x_3 => { function h(x_3) { return (() => { return 0 + 0; })(); } return h;})(1)(1);
[beforeMarker] Function f takes in 1 as input x_3

{ function h(x_3) { return (() => { return 0 + 0; })(); } return h;}(1);
[afterMarker] Function f takes in 1 as input x_3

{ function h(x_3) { return (() => { return 0 + 0; })(); } return h;}(1);
[beforeMarker] Function h declared, parameter(s) x_3 required

{ return x_3 => { return (() => { return 0 + 0; })(); };}(1);
[afterMarker] Function h declared, parameter(s) x_3 required

{ return x_3 => { return (() => { return 0 + 0; })(); };}(1);
[beforeMarker] x_3 => {
  return (() => {
    return 0 + 0;
  })();
} returned

(x_3 => { return (() => { return 0 + 0; })();})(1);
[afterMarker] x_3 => {
  return (() => {
    return 0 + 0;
  })();
} returned

(x_3 => { return (() => { return 0 + 0; })();})(1);
[beforeMarker] Function h takes in 1 as input x_3

(() => { return 0 + 0;})();
[afterMarker] Function h takes in 1 as input x_3

(() => { return 0 + 0;})();
[beforeMarker] () => {...} runs

0 + 0;
[afterMarker] () => {...} runs

0 + 0;
[beforeMarker] Binary expression 0 + 0 evaluated

0;
[afterMarker] Binary expression 0 + 0 evaluated

0;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming renaming clash in replacement for function expression 1`] = `
"function f(x_1) { function h(x_2) { return g(); } return h;}function g() { return x_1 + x_2;}const x_1 = 0;const x_2 = 0;f(1)(1);
[noMarker] Start of evaluation

function f(x_1) { function h(x_2) { return g(); } return h;}function g() { return x_1 + x_2;}const x_1 = 0;const x_2 = 0;f(1)(1);
[beforeMarker] Function f declared, parameter(s) x_1 required

function g() { return x_1 + x_2;}const x_1 = 0;const x_2 = 0;(x_1 => { function h(x_2) { return g(); } return h;})(1)(1);
[afterMarker] Function f declared, parameter(s) x_1 required

function g() { return x_1 + x_2;}const x_1 = 0;const x_2 = 0;(x_1 => { function h(x_2) { return g(); } return h;})(1)(1);
[beforeMarker] Function g declared, parameter(s)  required

const x_1 = 0;const x_2 = 0;(x_3 => { function h(x_3) { return (() => { return x_1 + x_2; })(); } return h;})(1)(1);
[afterMarker] Function g declared, parameter(s)  required

const x_1 = 0;const x_2 = 0;(x_3 => { function h(x_3) { return (() => { return x_1 + x_2; })(); } return h;})(1)(1);
[beforeMarker] Constant x_1 declared and substituted into the rest of block

const x_2 = 0;(x_3 => { function h(x_3) { return (() => { return 0 + x_2; })(); } return h;})(1)(1);
[afterMarker] Constant x_1 declared and substituted into the rest of block

const x_2 = 0;(x_3 => { function h(x_3) { return (() => { return 0 + x_2; })(); } return h;})(1)(1);
[beforeMarker] Constant x_2 declared and substituted into the rest of block

(x_3 => { function h(x_3) { return (() => { return 0 + 0; })(); } return h;})(1)(1);
[afterMarker] Constant x_2 declared and substituted into the rest of block

(x_3 => { function h(x_3) { return (() => { return 0 + 0; })(); } return h;})(1)(1);
[beforeMarker] Function f takes in 1 as input x_3

{ function h(x_3) { return (() => { return 0 + 0; })(); } return h;}(1);
[afterMarker] Function f takes in 1 as input x_3

{ function h(x_3) { return (() => { return 0 + 0; })(); } return h;}(1);
[beforeMarker] Function h declared, parameter(s) x_3 required

{ return x_3 => { return (() => { return 0 + 0; })(); };}(1);
[afterMarker] Function h declared, parameter(s) x_3 required

{ return x_3 => { return (() => { return 0 + 0; })(); };}(1);
[beforeMarker] x_3 => {
  return (() => {
    return 0 + 0;
  })();
} returned

(x_3 => { return (() => { return 0 + 0; })();})(1);
[afterMarker] x_3 => {
  return (() => {
    return 0 + 0;
  })();
} returned

(x_3 => { return (() => { return 0 + 0; })();})(1);
[beforeMarker] Function h takes in 1 as input x_3

(() => { return 0 + 0;})();
[afterMarker] Function h takes in 1 as input x_3

(() => { return 0 + 0;})();
[beforeMarker] () => {...} runs

0 + 0;
[afterMarker] () => {...} runs

0 + 0;
[beforeMarker] Binary expression 0 + 0 evaluated

0;
[afterMarker] Binary expression 0 + 0 evaluated

0;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming renaming clash in replacement for lambda function 1`] = `
"const g = () => x_1 + x_2;const f = x_1 => x_2 => g();const x_1 = 0;const x_2 = 0;f(1)(1);
[noMarker] Start of evaluation

const g = () => x_1 + x_2;const f = x_1 => x_2 => g();const x_1 = 0;const x_2 = 0;f(1)(1);
[beforeMarker] Constant g declared and substituted into the rest of block

const f = x_3 => x_4 => (() => x_1 + x_2)();const x_1 = 0;const x_2 = 0;f(1)(1);
[afterMarker] Constant g declared and substituted into the rest of block

const f = x_3 => x_4 => (() => x_1 + x_2)();const x_1 = 0;const x_2 = 0;f(1)(1);
[beforeMarker] Constant f declared and substituted into the rest of block

const x_1 = 0;const x_2 = 0;(x_3 => x_4 => (() => x_1 + x_2)())(1)(1);
[afterMarker] Constant f declared and substituted into the rest of block

const x_1 = 0;const x_2 = 0;(x_3 => x_4 => (() => x_1 + x_2)())(1)(1);
[beforeMarker] Constant x_1 declared and substituted into the rest of block

const x_2 = 0;(x_3 => x_4 => (() => 0 + x_2)())(1)(1);
[afterMarker] Constant x_1 declared and substituted into the rest of block

const x_2 = 0;(x_3 => x_4 => (() => 0 + x_2)())(1)(1);
[beforeMarker] Constant x_2 declared and substituted into the rest of block

(x_3 => x_4 => (() => 0 + 0)())(1)(1);
[afterMarker] Constant x_2 declared and substituted into the rest of block

(x_3 => x_4 => (() => 0 + 0)())(1)(1);
[beforeMarker] 1 substituted into x_3 of x_3 => x_4 => (() => 0 + 0)()

(x_4 => (() => 0 + 0)())(1);
[afterMarker] 1 substituted into x_3 of x_3 => x_4 => (() => 0 + 0)()

(x_4 => (() => 0 + 0)())(1);
[beforeMarker] 1 substituted into x_4 of x_4 => (() => 0 + 0)()

(() => 0 + 0)();
[afterMarker] 1 substituted into x_4 of x_4 => (() => 0 + 0)()

(() => 0 + 0)();
[beforeMarker] () => 0 + 0 runs

0 + 0;
[afterMarker] () => 0 + 0 runs

0 + 0;
[beforeMarker] Binary expression 0 + 0 evaluated

0;
[afterMarker] Binary expression 0 + 0 evaluated

0;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming renaming clash test for functions 1`] = `
"function f(w_8) { function h(w_9) { return w_8 + w_9 + g(); } return h;}function g() { return w_9;}const w_9 = 0;f(1)(2);
[noMarker] Start of evaluation

function f(w_8) { function h(w_9) { return w_8 + w_9 + g(); } return h;}function g() { return w_9;}const w_9 = 0;f(1)(2);
[beforeMarker] Function f declared, parameter(s) w_8 required

function g() { return w_9;}const w_9 = 0;(w_8 => { function h(w_9) { return w_8 + w_9 + g(); } return h;})(1)(2);
[afterMarker] Function f declared, parameter(s) w_8 required

function g() { return w_9;}const w_9 = 0;(w_8 => { function h(w_9) { return w_8 + w_9 + g(); } return h;})(1)(2);
[beforeMarker] Function g declared, parameter(s)  required

const w_9 = 0;(w_8 => { function h(w_10) { return w_8 + w_10 + (() => { return w_9; })(); } return h;})(1)(2);
[afterMarker] Function g declared, parameter(s)  required

const w_9 = 0;(w_8 => { function h(w_10) { return w_8 + w_10 + (() => { return w_9; })(); } return h;})(1)(2);
[beforeMarker] Constant w_9 declared and substituted into the rest of block

(w_8 => { function h(w_10) { return w_8 + w_10 + (() => { return 0; })(); } return h;})(1)(2);
[afterMarker] Constant w_9 declared and substituted into the rest of block

(w_8 => { function h(w_10) { return w_8 + w_10 + (() => { return 0; })(); } return h;})(1)(2);
[beforeMarker] Function f takes in 1 as input w_8

{ function h(w_10) { return 1 + w_10 + (() => { return 0; })(); } return h;}(2);
[afterMarker] Function f takes in 1 as input w_8

{ function h(w_10) { return 1 + w_10 + (() => { return 0; })(); } return h;}(2);
[beforeMarker] Function h declared, parameter(s) w_10 required

{ return w_10 => { return 1 + w_10 + (() => { return 0; })(); };}(2);
[afterMarker] Function h declared, parameter(s) w_10 required

{ return w_10 => { return 1 + w_10 + (() => { return 0; })(); };}(2);
[beforeMarker] w_10 => {
  return 1 + w_10 + (() => {
    return 0;
  })();
} returned

(w_10 => { return 1 + w_10 + (() => { return 0; })();})(2);
[afterMarker] w_10 => {
  return 1 + w_10 + (() => {
    return 0;
  })();
} returned

(w_10 => { return 1 + w_10 + (() => { return 0; })();})(2);
[beforeMarker] Function h takes in 2 as input w_10

1 + 2 + (() => { return 0;})();
[afterMarker] Function h takes in 2 as input w_10

1 + 2 + (() => { return 0;})();
[beforeMarker] Binary expression 1 + 2 evaluated

3 + (() => { return 0;})();
[afterMarker] Binary expression 1 + 2 evaluated

3 + (() => { return 0;})();
[beforeMarker] () => {...} runs

3 + 0;
[afterMarker] () => {...} runs

3 + 0;
[beforeMarker] Binary expression 3 + 0 evaluated

3;
[afterMarker] Binary expression 3 + 0 evaluated

3;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming renaming clash test for lambda function 1`] = `
"const f = w_11 => w_10 => w_11 + w_10 + g();const g = () => w_10;const w_10 = 0;f(1)(2);
[noMarker] Start of evaluation

const f = w_11 => w_10 => w_11 + w_10 + g();const g = () => w_10;const w_10 = 0;f(1)(2);
[beforeMarker] Constant f declared and substituted into the rest of block

const g = () => w_10;const w_10 = 0;(w_11 => w_10 => w_11 + w_10 + g())(1)(2);
[afterMarker] Constant f declared and substituted into the rest of block

const g = () => w_10;const w_10 = 0;(w_11 => w_10 => w_11 + w_10 + g())(1)(2);
[beforeMarker] Constant g declared and substituted into the rest of block

const w_10 = 0;(w_11 => w_12 => w_11 + w_12 + (() => w_10)())(1)(2);
[afterMarker] Constant g declared and substituted into the rest of block

const w_10 = 0;(w_11 => w_12 => w_11 + w_12 + (() => w_10)())(1)(2);
[beforeMarker] Constant w_10 declared and substituted into the rest of block

(w_11 => w_12 => w_11 + w_12 + (() => 0)())(1)(2);
[afterMarker] Constant w_10 declared and substituted into the rest of block

(w_11 => w_12 => w_11 + w_12 + (() => 0)())(1)(2);
[beforeMarker] 1 substituted into w_11 of w_11 => w_12 => w_11 + w_12 + (() => 0)()

(w_12 => 1 + w_12 + (() => 0)())(2);
[afterMarker] 1 substituted into w_11 of w_11 => w_12 => w_11 + w_12 + (() => 0)()

(w_12 => 1 + w_12 + (() => 0)())(2);
[beforeMarker] 2 substituted into w_12 of w_12 => 1 + w_12 + (() => 0)()

1 + 2 + (() => 0)();
[afterMarker] 2 substituted into w_12 of w_12 => 1 + w_12 + (() => 0)()

1 + 2 + (() => 0)();
[beforeMarker] Binary expression 1 + 2 evaluated

3 + (() => 0)();
[afterMarker] Binary expression 1 + 2 evaluated

3 + (() => 0)();
[beforeMarker] () => 0 runs

3 + 0;
[afterMarker] () => 0 runs

3 + 0;
[beforeMarker] Binary expression 3 + 0 evaluated

3;
[afterMarker] Binary expression 3 + 0 evaluated

3;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming renaming clash with declaration in replacement for function declaration 1`] = `
"function g() { const x_2 = 2; return x_1 + x_2 + x;}function f(x) { function h(x_1) { return x + g(); } return h;}const x_1 = 0;const x = 0;f(1)(1);
[noMarker] Start of evaluation

function g() { const x_2 = 2; return x_1 + x_2 + x;}function f(x) { function h(x_1) { return x + g(); } return h;}const x_1 = 0;const x = 0;f(1)(1);
[beforeMarker] Function g declared, parameter(s)  required

function f(x_2) { function h(x_3) { return x_2 + (() => { const x_2 = 2; return x_1 + x_2 + x; })(); } return h;}const x_1 = 0;const x = 0;f(1)(1);
[afterMarker] Function g declared, parameter(s)  required

function f(x_2) { function h(x_3) { return x_2 + (() => { const x_2 = 2; return x_1 + x_2 + x; })(); } return h;}const x_1 = 0;const x = 0;f(1)(1);
[beforeMarker] Function f declared, parameter(s) x_2 required

const x_1 = 0;const x = 0;(x_2 => { function h(x_3) { return x_2 + (() => { const x_2 = 2; return x_1 + x_2 + x; })(); } return h;})(1)(1);
[afterMarker] Function f declared, parameter(s) x_2 required

const x_1 = 0;const x = 0;(x_2 => { function h(x_3) { return x_2 + (() => { const x_2 = 2; return x_1 + x_2 + x; })(); } return h;})(1)(1);
[beforeMarker] Constant x_1 declared and substituted into the rest of block

const x = 0;(x_2 => { function h(x_3) { return x_2 + (() => { const x_2 = 2; return 0 + x_2 + x; })(); } return h;})(1)(1);
[afterMarker] Constant x_1 declared and substituted into the rest of block

const x = 0;(x_2 => { function h(x_3) { return x_2 + (() => { const x_2 = 2; return 0 + x_2 + x; })(); } return h;})(1)(1);
[beforeMarker] Constant x declared and substituted into the rest of block

(x_2 => { function h(x_3) { return x_2 + (() => { const x_2 = 2; return 0 + x_2 + 0; })(); } return h;})(1)(1);
[afterMarker] Constant x declared and substituted into the rest of block

(x_2 => { function h(x_3) { return x_2 + (() => { const x_2 = 2; return 0 + x_2 + 0; })(); } return h;})(1)(1);
[beforeMarker] Function f takes in 1 as input x_2

{ function h(x_3) { return 1 + (() => { const x_2 = 2; return 0 + x_2 + 0; })(); } return h;}(1);
[afterMarker] Function f takes in 1 as input x_2

{ function h(x_3) { return 1 + (() => { const x_2 = 2; return 0 + x_2 + 0; })(); } return h;}(1);
[beforeMarker] Function h declared, parameter(s) x_3 required

{ return x_3 => { return 1 + (() => { const x_2 = 2; return 0 + x_2 + 0; })(); };}(1);
[afterMarker] Function h declared, parameter(s) x_3 required

{ return x_3 => { return 1 + (() => { const x_2 = 2; return 0 + x_2 + 0; })(); };}(1);
[beforeMarker] x_3 => {
  return 1 + (() => {
    const x_2 = 2;
    return 0 + x_2 + 0;
  })();
} returned

(x_3 => { return 1 + (() => { const x_2 = 2; return 0 + x_2 + 0; })();})(1);
[afterMarker] x_3 => {
  return 1 + (() => {
    const x_2 = 2;
    return 0 + x_2 + 0;
  })();
} returned

(x_3 => { return 1 + (() => { const x_2 = 2; return 0 + x_2 + 0; })();})(1);
[beforeMarker] Function h takes in 1 as input x_3

1 + (() => { const x_2 = 2; return 0 + x_2 + 0;})();
[afterMarker] Function h takes in 1 as input x_3

1 + (() => { const x_2 = 2; return 0 + x_2 + 0;})();
[beforeMarker] () => {...} runs

1 + { const x_2 = 2; return 0 + x_2 + 0;};
[afterMarker] () => {...} runs

1 + { const x_2 = 2; return 0 + x_2 + 0;};
[beforeMarker] Constant x_2 declared and substituted into the rest of block

1 + { return 0 + 2 + 0;};
[afterMarker] Constant x_2 declared and substituted into the rest of block

1 + { return 0 + 2 + 0;};
[beforeMarker] 0 + 2 + 0 returned

1 + (0 + 2 + 0);
[afterMarker] 0 + 2 + 0 returned

1 + (0 + 2 + 0);
[beforeMarker] Binary expression 0 + 2 evaluated

1 + (2 + 0);
[afterMarker] Binary expression 0 + 2 evaluated

1 + (2 + 0);
[beforeMarker] Binary expression 2 + 0 evaluated

1 + 2;
[afterMarker] Binary expression 2 + 0 evaluated

1 + 2;
[beforeMarker] Binary expression 1 + 2 evaluated

3;
[afterMarker] Binary expression 1 + 2 evaluated

3;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming renaming clash with declaration in replacement for function expression 1`] = `
"function f(x) { function h(x_1) { return g(); } return h;}function g() { const x_2 = 2; return x_1 + x_2 + x;}const x_1 = 0;const x = 0;f(1)(1);
[noMarker] Start of evaluation

function f(x) { function h(x_1) { return g(); } return h;}function g() { const x_2 = 2; return x_1 + x_2 + x;}const x_1 = 0;const x = 0;f(1)(1);
[beforeMarker] Function f declared, parameter(s) x required

function g() { const x_2 = 2; return x_1 + x_2 + x;}const x_1 = 0;const x = 0;(x => { function h(x_1) { return g(); } return h;})(1)(1);
[afterMarker] Function f declared, parameter(s) x required

function g() { const x_2 = 2; return x_1 + x_2 + x;}const x_1 = 0;const x = 0;(x => { function h(x_1) { return g(); } return h;})(1)(1);
[beforeMarker] Function g declared, parameter(s)  required

const x_1 = 0;const x = 0;(x_2 => { function h(x_2) { return (() => { const x_2 = 2; return x_1 + x_2 + x; })(); } return h;})(1)(1);
[afterMarker] Function g declared, parameter(s)  required

const x_1 = 0;const x = 0;(x_2 => { function h(x_2) { return (() => { const x_2 = 2; return x_1 + x_2 + x; })(); } return h;})(1)(1);
[beforeMarker] Constant x_1 declared and substituted into the rest of block

const x = 0;(x_2 => { function h(x_2) { return (() => { const x_2 = 2; return 0 + x_2 + x; })(); } return h;})(1)(1);
[afterMarker] Constant x_1 declared and substituted into the rest of block

const x = 0;(x_2 => { function h(x_2) { return (() => { const x_2 = 2; return 0 + x_2 + x; })(); } return h;})(1)(1);
[beforeMarker] Constant x declared and substituted into the rest of block

(x_2 => { function h(x_2) { return (() => { const x_2 = 2; return 0 + x_2 + 0; })(); } return h;})(1)(1);
[afterMarker] Constant x declared and substituted into the rest of block

(x_2 => { function h(x_2) { return (() => { const x_2 = 2; return 0 + x_2 + 0; })(); } return h;})(1)(1);
[beforeMarker] Function f takes in 1 as input x_2

{ function h(x_2) { return (() => { const x_2 = 2; return 0 + x_2 + 0; })(); } return h;}(1);
[afterMarker] Function f takes in 1 as input x_2

{ function h(x_2) { return (() => { const x_2 = 2; return 0 + x_2 + 0; })(); } return h;}(1);
[beforeMarker] Function h declared, parameter(s) x_2 required

{ return x_2 => { return (() => { const x_2 = 2; return 0 + x_2 + 0; })(); };}(1);
[afterMarker] Function h declared, parameter(s) x_2 required

{ return x_2 => { return (() => { const x_2 = 2; return 0 + x_2 + 0; })(); };}(1);
[beforeMarker] x_2 => {
  return (() => {
    const x_2 = 2;
    return 0 + x_2 + 0;
  })();
} returned

(x_2 => { return (() => { const x_2 = 2; return 0 + x_2 + 0; })();})(1);
[afterMarker] x_2 => {
  return (() => {
    const x_2 = 2;
    return 0 + x_2 + 0;
  })();
} returned

(x_2 => { return (() => { const x_2 = 2; return 0 + x_2 + 0; })();})(1);
[beforeMarker] Function h takes in 1 as input x_2

(() => { const x_2 = 2; return 0 + x_2 + 0;})();
[afterMarker] Function h takes in 1 as input x_2

(() => { const x_2 = 2; return 0 + x_2 + 0;})();
[beforeMarker] () => {...} runs

{ const x_2 = 2; return 0 + x_2 + 0;};
[afterMarker] () => {...} runs

{ const x_2 = 2; return 0 + x_2 + 0;};
[beforeMarker] Constant x_2 declared and substituted into the rest of block

{ return 0 + 2 + 0;};
[afterMarker] Constant x_2 declared and substituted into the rest of block

{ return 0 + 2 + 0;};
[beforeMarker] 0 + 2 + 0 returned

0 + 2 + 0;
[afterMarker] 0 + 2 + 0 returned

0 + 2 + 0;
[beforeMarker] Binary expression 0 + 2 evaluated

2 + 0;
[afterMarker] Binary expression 0 + 2 evaluated

2 + 0;
[beforeMarker] Binary expression 2 + 0 evaluated

2;
[afterMarker] Binary expression 2 + 0 evaluated

2;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming renaming clash with declaration in replacement for lambda function 1`] = `
"const f = x => x_1 => g();const g = () => { const x_2 = 2; return x_1 + x + x_2;};const x = 0;const x_1 = 0;f(1)(1);
[noMarker] Start of evaluation

const f = x => x_1 => g();const g = () => { const x_2 = 2; return x_1 + x + x_2;};const x = 0;const x_1 = 0;f(1)(1);
[beforeMarker] Constant f declared and substituted into the rest of block

const g = () => { const x_2 = 2; return x_1 + x + x_2;};const x = 0;const x_1 = 0;(x => x_1 => g())(1)(1);
[afterMarker] Constant f declared and substituted into the rest of block

const g = () => { const x_2 = 2; return x_1 + x + x_2;};const x = 0;const x_1 = 0;(x => x_1 => g())(1)(1);
[beforeMarker] Constant g declared and substituted into the rest of block

const x = 0;const x_1 = 0;(x_2 => x_3 => (() => { const x_2 = 2; return x_1 + x + x_2;})())(1)(1);
[afterMarker] Constant g declared and substituted into the rest of block

const x = 0;const x_1 = 0;(x_2 => x_3 => (() => { const x_2 = 2; return x_1 + x + x_2;})())(1)(1);
[beforeMarker] Constant x declared and substituted into the rest of block

const x_1 = 0;(x_2 => x_3 => (() => { const x_2 = 2; return x_1 + 0 + x_2;})())(1)(1);
[afterMarker] Constant x declared and substituted into the rest of block

const x_1 = 0;(x_2 => x_3 => (() => { const x_2 = 2; return x_1 + 0 + x_2;})())(1)(1);
[beforeMarker] Constant x_1 declared and substituted into the rest of block

(x_2 => x_3 => (() => { const x_2 = 2; return 0 + 0 + x_2;})())(1)(1);
[afterMarker] Constant x_1 declared and substituted into the rest of block

(x_2 => x_3 => (() => { const x_2 = 2; return 0 + 0 + x_2;})())(1)(1);
[beforeMarker] 1 substituted into x_2 of x_2 => x_3 => (() => {
  const x_2 = 2;
  return 0 + 0 + x_2;
})()

(x_3 => (() => { const x_2 = 2; return 0 + 0 + x_2;})())(1);
[afterMarker] 1 substituted into x_2 of x_2 => x_3 => (() => {
  const x_2 = 2;
  return 0 + 0 + x_2;
})()

(x_3 => (() => { const x_2 = 2; return 0 + 0 + x_2;})())(1);
[beforeMarker] 1 substituted into x_3 of x_3 => (() => {
  const x_2 = 2;
  return 0 + 0 + x_2;
})()

(() => { const x_2 = 2; return 0 + 0 + x_2;})();
[afterMarker] 1 substituted into x_3 of x_3 => (() => {
  const x_2 = 2;
  return 0 + 0 + x_2;
})()

(() => { const x_2 = 2; return 0 + 0 + x_2;})();
[beforeMarker] () => {...} runs

{ const x_2 = 2; return 0 + 0 + x_2;};
[afterMarker] () => {...} runs

{ const x_2 = 2; return 0 + 0 + x_2;};
[beforeMarker] Constant x_2 declared and substituted into the rest of block

{ return 0 + 0 + 2;};
[afterMarker] Constant x_2 declared and substituted into the rest of block

{ return 0 + 0 + 2;};
[beforeMarker] 0 + 0 + 2 returned

0 + 0 + 2;
[afterMarker] 0 + 0 + 2 returned

0 + 0 + 2;
[beforeMarker] Binary expression 0 + 0 evaluated

0 + 2;
[afterMarker] Binary expression 0 + 0 evaluated

0 + 2;
[beforeMarker] Binary expression 0 + 2 evaluated

2;
[afterMarker] Binary expression 0 + 2 evaluated

2;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming renaming clash with parameter of function declaration in block 1`] = `
"function g() { return x_1;}function f(x_1) { function h(x_2) { return x_1 + g(); } return h;}const x_1 = 1;f(3)(2);
[noMarker] Start of evaluation

function g() { return x_1;}function f(x_1) { function h(x_2) { return x_1 + g(); } return h;}const x_1 = 1;f(3)(2);
[beforeMarker] Function g declared, parameter(s)  required

function f(x_3) { function h(x_2) { return x_3 + (() => { return x_1; })(); } return h;}const x_1 = 1;f(3)(2);
[afterMarker] Function g declared, parameter(s)  required

function f(x_3) { function h(x_2) { return x_3 + (() => { return x_1; })(); } return h;}const x_1 = 1;f(3)(2);
[beforeMarker] Function f declared, parameter(s) x_3 required

const x_1 = 1;(x_3 => { function h(x_2) { return x_3 + (() => { return x_1; })(); } return h;})(3)(2);
[afterMarker] Function f declared, parameter(s) x_3 required

const x_1 = 1;(x_3 => { function h(x_2) { return x_3 + (() => { return x_1; })(); } return h;})(3)(2);
[beforeMarker] Constant x_1 declared and substituted into the rest of block

(x_3 => { function h(x_2) { return x_3 + (() => { return 1; })(); } return h;})(3)(2);
[afterMarker] Constant x_1 declared and substituted into the rest of block

(x_3 => { function h(x_2) { return x_3 + (() => { return 1; })(); } return h;})(3)(2);
[beforeMarker] Function f takes in 3 as input x_3

{ function h(x_2) { return 3 + (() => { return 1; })(); } return h;}(2);
[afterMarker] Function f takes in 3 as input x_3

{ function h(x_2) { return 3 + (() => { return 1; })(); } return h;}(2);
[beforeMarker] Function h declared, parameter(s) x_2 required

{ return x_2 => { return 3 + (() => { return 1; })(); };}(2);
[afterMarker] Function h declared, parameter(s) x_2 required

{ return x_2 => { return 3 + (() => { return 1; })(); };}(2);
[beforeMarker] x_2 => {
  return 3 + (() => {
    return 1;
  })();
} returned

(x_2 => { return 3 + (() => { return 1; })();})(2);
[afterMarker] x_2 => {
  return 3 + (() => {
    return 1;
  })();
} returned

(x_2 => { return 3 + (() => { return 1; })();})(2);
[beforeMarker] Function h takes in 2 as input x_2

3 + (() => { return 1;})();
[afterMarker] Function h takes in 2 as input x_2

3 + (() => { return 1;})();
[beforeMarker] () => {...} runs

3 + 1;
[afterMarker] () => {...} runs

3 + 1;
[beforeMarker] Binary expression 3 + 1 evaluated

4;
[afterMarker] Binary expression 3 + 1 evaluated

4;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming renaming clash with parameter of lambda function declaration in block 1`] = `
"const g = () => x_1;const f = x_1 => { const h = x_2 => x_1 + g(); return h;};const x_1 = 1;f(3)(2);
[noMarker] Start of evaluation

const g = () => x_1;const f = x_1 => { const h = x_2 => x_1 + g(); return h;};const x_1 = 1;f(3)(2);
[beforeMarker] Constant g declared and substituted into the rest of block

const f = x_3 => { const h = x_2 => x_3 + (() => x_1)(); return h;};const x_1 = 1;f(3)(2);
[afterMarker] Constant g declared and substituted into the rest of block

const f = x_3 => { const h = x_2 => x_3 + (() => x_1)(); return h;};const x_1 = 1;f(3)(2);
[beforeMarker] Constant f declared and substituted into the rest of block

const x_1 = 1;(x_3 => { const h = x_2 => x_3 + (() => x_1)(); return h;})(3)(2);
[afterMarker] Constant f declared and substituted into the rest of block

const x_1 = 1;(x_3 => { const h = x_2 => x_3 + (() => x_1)(); return h;})(3)(2);
[beforeMarker] Constant x_1 declared and substituted into the rest of block

(x_3 => { const h = x_2 => x_3 + (() => 1)(); return h;})(3)(2);
[afterMarker] Constant x_1 declared and substituted into the rest of block

(x_3 => { const h = x_2 => x_3 + (() => 1)(); return h;})(3)(2);
[beforeMarker] Function f takes in 3 as input x_3

{ const h = x_2 => 3 + (() => 1)(); return h;}(2);
[afterMarker] Function f takes in 3 as input x_3

{ const h = x_2 => 3 + (() => 1)(); return h;}(2);
[beforeMarker] Constant h declared and substituted into the rest of block

{ return x_2 => 3 + (() => 1)();}(2);
[afterMarker] Constant h declared and substituted into the rest of block

{ return x_2 => 3 + (() => 1)();}(2);
[beforeMarker] x_2 => 3 + (() => 1)() returned

(x_2 => 3 + (() => 1)())(2);
[afterMarker] x_2 => 3 + (() => 1)() returned

(x_2 => 3 + (() => 1)())(2);
[beforeMarker] 2 substituted into x_2 of x_2 => 3 + (() => 1)()

3 + (() => 1)();
[afterMarker] 2 substituted into x_2 of x_2 => 3 + (() => 1)()

3 + (() => 1)();
[beforeMarker] () => 1 runs

3 + 1;
[afterMarker] () => 1 runs

3 + 1;
[beforeMarker] Binary expression 3 + 1 evaluated

4;
[afterMarker] Binary expression 3 + 1 evaluated

4;
[noMarker] Evaluation complete
"
`;

exports[`Alpha renaming renaming of outer parameter in lambda function 1`] = `
"const g = () => w_1;const f = w_1 => w_2 => w_1 + g();const w_1 = 0;f(1)(1);
[noMarker] Start of evaluation

const g = () => w_1;const f = w_1 => w_2 => w_1 + g();const w_1 = 0;f(1)(1);
[beforeMarker] Constant g declared and substituted into the rest of block

const f = w_3 => w_2 => w_3 + (() => w_1)();const w_1 = 0;f(1)(1);
[afterMarker] Constant g declared and substituted into the rest of block

const f = w_3 => w_2 => w_3 + (() => w_1)();const w_1 = 0;f(1)(1);
[beforeMarker] Constant f declared and substituted into the rest of block

const w_1 = 0;(w_3 => w_2 => w_3 + (() => w_1)())(1)(1);
[afterMarker] Constant f declared and substituted into the rest of block

const w_1 = 0;(w_3 => w_2 => w_3 + (() => w_1)())(1)(1);
[beforeMarker] Constant w_1 declared and substituted into the rest of block

(w_3 => w_2 => w_3 + (() => 0)())(1)(1);
[afterMarker] Constant w_1 declared and substituted into the rest of block

(w_3 => w_2 => w_3 + (() => 0)())(1)(1);
[beforeMarker] 1 substituted into w_3 of w_3 => w_2 => w_3 + (() => 0)()

(w_2 => 1 + (() => 0)())(1);
[afterMarker] 1 substituted into w_3 of w_3 => w_2 => w_3 + (() => 0)()

(w_2 => 1 + (() => 0)())(1);
[beforeMarker] 1 substituted into w_2 of w_2 => 1 + (() => 0)()

1 + (() => 0)();
[afterMarker] 1 substituted into w_2 of w_2 => 1 + (() => 0)()

1 + (() => 0)();
[beforeMarker] () => 0 runs

1 + 0;
[afterMarker] () => 0 runs

1 + 0;
[beforeMarker] Binary expression 1 + 0 evaluated

1;
[afterMarker] Binary expression 1 + 0 evaluated

1;
[noMarker] Evaluation complete
"
`;

exports[`Builtin math PI returns its value 1`] = `
"3.141592653589793;
[noMarker] Start of evaluation

3.141592653589793;
[noMarker] Evaluation complete
"
`;

exports[`Builtin math math_sin() returns NaN 1`] = `
"math_sin();
[noMarker] Start of evaluation

math_sin();
[beforeMarker] math_sin runs

NaN;
[afterMarker] math_sin runs

NaN;
[noMarker] Evaluation complete
"
`;

exports[`Builtin math negative numbers as arguments 1`] = `
"math_sin(-1);
[noMarker] Start of evaluation

math_sin(-1);
[beforeMarker] math_sin runs

-0.8414709848078965;
[afterMarker] math_sin runs

-0.8414709848078965;
[noMarker] Evaluation complete
"
`;

exports[`Church numerals 1`] = `
"const one = f => x => f(x);const inc = a => f => x => f(a(f)(x));const decode = a => a(x => x + 1)(0);decode(inc(inc(one))) === 3;
[noMarker] Start of evaluation

const one = f => x => f(x);const inc = a => f => x => f(a(f)(x));const decode = a => a(x => x + 1)(0);decode(inc(inc(one))) === 3;
[beforeMarker] Constant one declared and substituted into the rest of block

const inc = a => f => x => f(a(f)(x));const decode = a => a(x => x + 1)(0);decode(inc(inc(f => x => f(x)))) === 3;
[afterMarker] Constant one declared and substituted into the rest of block

const inc = a => f => x => f(a(f)(x));const decode = a => a(x => x + 1)(0);decode(inc(inc(f => x => f(x)))) === 3;
[beforeMarker] Constant inc declared and substituted into the rest of block

const decode = a => a(x => x + 1)(0);decode((a => f => x => f(a(f)(x)))((a => f => x => f(a(f)(x)))(f => x => f(x)))) === 3;
[afterMarker] Constant inc declared and substituted into the rest of block

const decode = a => a(x => x + 1)(0);decode((a => f => x => f(a(f)(x)))((a => f => x => f(a(f)(x)))(f => x => f(x)))) === 3;
[beforeMarker] Constant decode declared and substituted into the rest of block

(a => a(x => x + 1)(0))((a => f => x => f(a(f)(x)))((a => f => x => f(a(f)(x)))(f => x => f(x)))) === 3;
[afterMarker] Constant decode declared and substituted into the rest of block

(a => a(x => x + 1)(0))((a => f => x => f(a(f)(x)))((a => f => x => f(a(f)(x)))(f => x => f(x)))) === 3;
[beforeMarker] f => x => f(x) substituted into a of a => f => x => f(a(f)(x))

(a => a(x => x + 1)(0))((a => f => x => f(a(f)(x)))(f => x => f((f => x => f(x))(f)(x)))) === 3;
[afterMarker] f => x => f(x) substituted into a of a => f => x => f(a(f)(x))

(a => a(x => x + 1)(0))((a => f => x => f(a(f)(x)))(f => x => f((f => x => f(x))(f)(x)))) === 3;
[beforeMarker] f => x => f((f => x => f(x))(f)(x)) substituted into a of a => f => x => f(a(f)(x))

(a => a(x => x + 1)(0))(f => x => f((f => x => f((f => x => f(x))(f)(x)))(f)(x))) === 3;
[afterMarker] f => x => f((f => x => f(x))(f)(x)) substituted into a of a => f => x => f(a(f)(x))

(a => a(x => x + 1)(0))(f => x => f((f => x => f((f => x => f(x))(f)(x)))(f)(x))) === 3;
[beforeMarker] f => x => f((f => x => f((f => x => f(x))(f)(x)))(f)(x)) substituted into a of a => a(x => x + 1)(0)

(f => x => f((f => x => f((f => x => f(x))(f)(x)))(f)(x)))(x => x + 1)(0) === 3;
[afterMarker] f => x => f((f => x => f((f => x => f(x))(f)(x)))(f)(x)) substituted into a of a => a(x => x + 1)(0)

(f => x => f((f => x => f((f => x => f(x))(f)(x)))(f)(x)))(x => x + 1)(0) === 3;
[beforeMarker] x => x + 1 substituted into f of f => x => f((f => x => f((f => x => f(x))(f)(x)))(f)(x))

(x => (x => x + 1)((f => x => f((f => x => f(x))(f)(x)))(x => x + 1)(x)))(0) === 3;
[afterMarker] x => x + 1 substituted into f of f => x => f((f => x => f((f => x => f(x))(f)(x)))(f)(x))

(x => (x => x + 1)((f => x => f((f => x => f(x))(f)(x)))(x => x + 1)(x)))(0) === 3;
[beforeMarker] 0 substituted into x of x => (x => x + 1)((f => x => f((f => x => f(x))(f)(x)))(x => x + 1)(x))

(x => x + 1)((f => x => f((f => x => f(x))(f)(x)))(x => x + 1)(0)) === 3;
[afterMarker] 0 substituted into x of x => (x => x + 1)((f => x => f((f => x => f(x))(f)(x)))(x => x + 1)(x))

(x => x + 1)((f => x => f((f => x => f(x))(f)(x)))(x => x + 1)(0)) === 3;
[beforeMarker] x => x + 1 substituted into f of f => x => f((f => x => f(x))(f)(x))

(x => x + 1)((x => (x => x + 1)((f => x => f(x))(x => x + 1)(x)))(0)) === 3;
[afterMarker] x => x + 1 substituted into f of f => x => f((f => x => f(x))(f)(x))

(x => x + 1)((x => (x => x + 1)((f => x => f(x))(x => x + 1)(x)))(0)) === 3;
[beforeMarker] 0 substituted into x of x => (x => x + 1)((f => x => f(x))(x => x + 1)(x))

(x => x + 1)((x => x + 1)((f => x => f(x))(x => x + 1)(0))) === 3;
[afterMarker] 0 substituted into x of x => (x => x + 1)((f => x => f(x))(x => x + 1)(x))

(x => x + 1)((x => x + 1)((f => x => f(x))(x => x + 1)(0))) === 3;
[beforeMarker] x => x + 1 substituted into f of f => x => f(x)

(x => x + 1)((x => x + 1)((x => (x => x + 1)(x))(0))) === 3;
[afterMarker] x => x + 1 substituted into f of f => x => f(x)

(x => x + 1)((x => x + 1)((x => (x => x + 1)(x))(0))) === 3;
[beforeMarker] 0 substituted into x of x => (x => x + 1)(x)

(x => x + 1)((x => x + 1)((x => x + 1)(0))) === 3;
[afterMarker] 0 substituted into x of x => (x => x + 1)(x)

(x => x + 1)((x => x + 1)((x => x + 1)(0))) === 3;
[beforeMarker] 0 substituted into x of x => x + 1

(x => x + 1)((x => x + 1)(0 + 1)) === 3;
[afterMarker] 0 substituted into x of x => x + 1

(x => x + 1)((x => x + 1)(0 + 1)) === 3;
[beforeMarker] Binary expression 0 + 1 evaluated

(x => x + 1)((x => x + 1)(1)) === 3;
[afterMarker] Binary expression 0 + 1 evaluated

(x => x + 1)((x => x + 1)(1)) === 3;
[beforeMarker] 1 substituted into x of x => x + 1

(x => x + 1)(1 + 1) === 3;
[afterMarker] 1 substituted into x of x => x + 1

(x => x + 1)(1 + 1) === 3;
[beforeMarker] Binary expression 1 + 1 evaluated

(x => x + 1)(2) === 3;
[afterMarker] Binary expression 1 + 1 evaluated

(x => x + 1)(2) === 3;
[beforeMarker] 2 substituted into x of x => x + 1

2 + 1 === 3;
[afterMarker] 2 substituted into x of x => x + 1

2 + 1 === 3;
[beforeMarker] Binary expression 2 + 1 evaluated

3 === 3;
[afterMarker] Binary expression 2 + 1 evaluated

3 === 3;
[beforeMarker] Binary expression 3 === 3 evaluated

true;
[afterMarker] Binary expression 3 === 3 evaluated

true;
[noMarker] Evaluation complete
"
`;

exports[`Error handling on calling functions Incorrect number of argument (less) 1`] = `
"function foo(a) { return a;}foo();
[noMarker] Start of evaluation

function foo(a) { return a;}foo();
[beforeMarker] Function foo declared, parameter(s) a required

(a => { return a;})();
[afterMarker] Function foo declared, parameter(s) a required

(a => { return a;})();
[beforeMarker] Line 5: Expected 1 arguments, but got 0.

(a => { return a;})();
[noMarker] Evaluation stuck
"
`;

exports[`Error handling on calling functions Incorrect number of argument (more) 1`] = `
"function foo(a) { return a;}foo(1, 2, 3);
[noMarker] Start of evaluation

function foo(a) { return a;}foo(1, 2, 3);
[beforeMarker] Function foo declared, parameter(s) a required

(a => { return a;})(1, 2, 3);
[afterMarker] Function foo declared, parameter(s) a required

(a => { return a;})(1, 2, 3);
[beforeMarker] Line 5: Expected 1 arguments, but got 3.

(a => { return a;})(1, 2, 3);
[noMarker] Evaluation stuck
"
`;

exports[`Error handling on calling functions Literal function should error 1`] = `
"(1)(2);
[noMarker] Start of evaluation

(1)(2);
[beforeMarker] Line 2: Calling non-function value 1

(1)(2);
[noMarker] Evaluation stuck
"
`;

exports[`Error handling on calling functions Literal function should error 2 1`] = `
"(1 * 3)(2 * 3 + 10);
[noMarker] Start of evaluation

(1 * 3)(2 * 3 + 10);
[beforeMarker] Binary expression 1 * 3 evaluated

(3)(2 * 3 + 10);
[afterMarker] Binary expression 1 * 3 evaluated

(3)(2 * 3 + 10);
[beforeMarker] Binary expression 2 * 3 evaluated

(3)(6 + 10);
[afterMarker] Binary expression 2 * 3 evaluated

(3)(6 + 10);
[beforeMarker] Binary expression 6 + 10 evaluated

(3)(16);
[afterMarker] Binary expression 6 + 10 evaluated

(3)(16);
[beforeMarker] Line 2: Calling non-function value 3

(3)(16);
[noMarker] Evaluation stuck
"
`;

exports[`Evaluation of empty code and imports Evaluate empty program 1`] = `
"
[noMarker] Start of evaluation

undefined;
[noMarker] Evaluation complete
"
`;

exports[`Expressions Conditional Expression 1`] = `
"-1 * 3 === 3 ? 2 * 4 - 7 : 1 + 3 * 6;
[noMarker] Start of evaluation
-1 * 3 === 3 ? 2 * 4 - 7 : 1 + 3 * 6;
[beforeMarker] Binary expression -1 * 3 evaluated
-3 === 3 ? 2 * 4 - 7 : 1 + 3 * 6;
[afterMarker] Binary expression -1 * 3 evaluated
-3 === 3 ? 2 * 4 - 7 : 1 + 3 * 6;
[beforeMarker] Binary expression -3 === 3 evaluated
false ? 2 * 4 - 7 : 1 + 3 * 6;
[afterMarker] Binary expression -3 === 3 evaluated
false ? 2 * 4 - 7 : 1 + 3 * 6;
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated
1 + 3 * 6;
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated
1 + 3 * 6;
[beforeMarker] Binary expression 3 * 6 evaluated
1 + 18;
[afterMarker] Binary expression 3 * 6 evaluated
1 + 18;
[beforeMarker] Binary expression 1 + 18 evaluated
19;
[afterMarker] Binary expression 1 + 18 evaluated
19;
[noMarker] Evaluation complete
"
`;

exports[`Expressions Extra step for UnaryExpression 1`] = `
"-(1 - 5);
[noMarker] Start of evaluation
-(1 - 5);
[beforeMarker] Binary expression 1 - 5 evaluated
--4;
[afterMarker] Binary expression 1 - 5 evaluated
--4;
[beforeMarker] Unary expression evaluated, value -4 negated.
4;
[afterMarker] Unary expression evaluated, value -4 negated.
4;
[noMarker] Evaluation complete
"
`;

exports[`Expressions Logical Expression 1`] = `
"!!!true || true;
[noMarker] Start of evaluation
!!!true || true;
[beforeMarker] Unary expression evaluated, boolean true negated.
!!false || true;
[afterMarker] Unary expression evaluated, boolean true negated.
!!false || true;
[beforeMarker] Unary expression evaluated, boolean false negated.
!true || true;
[afterMarker] Unary expression evaluated, boolean false negated.
!true || true;
[beforeMarker] Unary expression evaluated, boolean true negated.
false || true;
[afterMarker] Unary expression evaluated, boolean true negated.
false || true;
[beforeMarker] OR operation evaluated, left of operator is false, continue evaluating right of operator
true;
[afterMarker] OR operation evaluated, left of operator is false, continue evaluating right of operator
true;
[noMarker] Evaluation complete
"
`;

exports[`Expressions No extra step for UnaryExpression 1`] = `
"-(1 + 2);
[noMarker] Start of evaluation
-(1 + 2);
[beforeMarker] Binary expression 1 + 2 evaluated
-3;
[afterMarker] Binary expression 1 + 2 evaluated
-3;
[noMarker] Evaluation complete
"
`;

exports[`Expressions Unary and Binary Expressions 1`] = `
"-1 + 2 * 3 - (5 * 6 - 7);
[noMarker] Start of evaluation
-1 + 2 * 3 - (5 * 6 - 7);
[beforeMarker] Binary expression 2 * 3 evaluated
-1 + 6 - (5 * 6 - 7);
[afterMarker] Binary expression 2 * 3 evaluated
-1 + 6 - (5 * 6 - 7);
[beforeMarker] Binary expression -1 + 6 evaluated
5 - (5 * 6 - 7);
[afterMarker] Binary expression -1 + 6 evaluated
5 - (5 * 6 - 7);
[beforeMarker] Binary expression 5 * 6 evaluated
5 - (30 - 7);
[afterMarker] Binary expression 5 * 6 evaluated
5 - (30 - 7);
[beforeMarker] Binary expression 30 - 7 evaluated
5 - 23;
[afterMarker] Binary expression 30 - 7 evaluated
5 - 23;
[beforeMarker] Binary expression 5 - 23 evaluated
-18;
[afterMarker] Binary expression 5 - 23 evaluated
-18;
[noMarker] Evaluation complete
"
`;

exports[`Expressions: Binary operators And-shortcut-false test case 1`] = `
"if (false && 1 + 2 === 1 + 2) { 1;} else { 2;}
[noMarker] Start of evaluation

if (false && 1 + 2 === 1 + 2) { 1;} else { 2;}
[beforeMarker] AND operation evaluated, left of operator is false, stop evaluation

if (false) { 1;} else { 2;}
[afterMarker] AND operation evaluated, left of operator is false, stop evaluation

if (false) { 1;} else { 2;}
[beforeMarker] If statement evaluated, condition false, proceed to else block

{ undefined; 2;}
[afterMarker] If statement evaluated, condition false, proceed to else block

{ undefined; 2;}
[beforeMarker] undefined finished evaluating

{ 2;}
[afterMarker] undefined finished evaluating

{ 2;}
[beforeMarker] 2; finished evaluating

2;
[afterMarker] 2; finished evaluating

2;
[noMarker] Evaluation complete
"
`;

exports[`Expressions: Binary operators And-shortcut-true test case 1`] = `
"if (true && 1 + 2 === 2 + 3) { 1;} else { 2;}
[noMarker] Start of evaluation

if (true && 1 + 2 === 2 + 3) { 1;} else { 2;}
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

if (1 + 2 === 2 + 3) { 1;} else { 2;}
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

if (1 + 2 === 2 + 3) { 1;} else { 2;}
[beforeMarker] Binary expression 1 + 2 evaluated

if (3 === 2 + 3) { 1;} else { 2;}
[afterMarker] Binary expression 1 + 2 evaluated

if (3 === 2 + 3) { 1;} else { 2;}
[beforeMarker] Binary expression 2 + 3 evaluated

if (3 === 5) { 1;} else { 2;}
[afterMarker] Binary expression 2 + 3 evaluated

if (3 === 5) { 1;} else { 2;}
[beforeMarker] Binary expression 3 === 5 evaluated

if (false) { 1;} else { 2;}
[afterMarker] Binary expression 3 === 5 evaluated

if (false) { 1;} else { 2;}
[beforeMarker] If statement evaluated, condition false, proceed to else block

{ undefined; 2;}
[afterMarker] If statement evaluated, condition false, proceed to else block

{ undefined; 2;}
[beforeMarker] undefined finished evaluating

{ 2;}
[afterMarker] undefined finished evaluating

{ 2;}
[beforeMarker] 2; finished evaluating

2;
[afterMarker] 2; finished evaluating

2;
[noMarker] Evaluation complete
"
`;

exports[`Expressions: Binary operators Left-binary-reduce test case 1`] = `
"if (1 + 2 + 3 === 1 + 2 + 3) { 1;} else { 2;}
[noMarker] Start of evaluation

if (1 + 2 + 3 === 1 + 2 + 3) { 1;} else { 2;}
[beforeMarker] Binary expression 1 + 2 evaluated

if (3 + 3 === 1 + 2 + 3) { 1;} else { 2;}
[afterMarker] Binary expression 1 + 2 evaluated

if (3 + 3 === 1 + 2 + 3) { 1;} else { 2;}
[beforeMarker] Binary expression 3 + 3 evaluated

if (6 === 1 + 2 + 3) { 1;} else { 2;}
[afterMarker] Binary expression 3 + 3 evaluated

if (6 === 1 + 2 + 3) { 1;} else { 2;}
[beforeMarker] Binary expression 1 + 2 evaluated

if (6 === 3 + 3) { 1;} else { 2;}
[afterMarker] Binary expression 1 + 2 evaluated

if (6 === 3 + 3) { 1;} else { 2;}
[beforeMarker] Binary expression 3 + 3 evaluated

if (6 === 6) { 1;} else { 2;}
[afterMarker] Binary expression 3 + 3 evaluated

if (6 === 6) { 1;} else { 2;}
[beforeMarker] Binary expression 6 === 6 evaluated

if (true) { 1;} else { 2;}
[afterMarker] Binary expression 6 === 6 evaluated

if (true) { 1;} else { 2;}
[beforeMarker] If statement evaluated, condition true, proceed to if block

{ undefined; 1;}
[afterMarker] If statement evaluated, condition true, proceed to if block

{ undefined; 1;}
[beforeMarker] undefined finished evaluating

{ 1;}
[afterMarker] undefined finished evaluating

{ 1;}
[beforeMarker] 1; finished evaluating

1;
[afterMarker] 1; finished evaluating

1;
[noMarker] Evaluation complete
"
`;

exports[`Expressions: Binary operators Or-shortcut-false test case 1`] = `
"if (false || 1 + 2 === 1 + 2) { 1;} else { 2;}
[noMarker] Start of evaluation

if (false || 1 + 2 === 1 + 2) { 1;} else { 2;}
[beforeMarker] OR operation evaluated, left of operator is false, continue evaluating right of operator

if (1 + 2 === 1 + 2) { 1;} else { 2;}
[afterMarker] OR operation evaluated, left of operator is false, continue evaluating right of operator

if (1 + 2 === 1 + 2) { 1;} else { 2;}
[beforeMarker] Binary expression 1 + 2 evaluated

if (3 === 1 + 2) { 1;} else { 2;}
[afterMarker] Binary expression 1 + 2 evaluated

if (3 === 1 + 2) { 1;} else { 2;}
[beforeMarker] Binary expression 1 + 2 evaluated

if (3 === 3) { 1;} else { 2;}
[afterMarker] Binary expression 1 + 2 evaluated

if (3 === 3) { 1;} else { 2;}
[beforeMarker] Binary expression 3 === 3 evaluated

if (true) { 1;} else { 2;}
[afterMarker] Binary expression 3 === 3 evaluated

if (true) { 1;} else { 2;}
[beforeMarker] If statement evaluated, condition true, proceed to if block

{ undefined; 1;}
[afterMarker] If statement evaluated, condition true, proceed to if block

{ undefined; 1;}
[beforeMarker] undefined finished evaluating

{ 1;}
[afterMarker] undefined finished evaluating

{ 1;}
[beforeMarker] 1; finished evaluating

1;
[afterMarker] 1; finished evaluating

1;
[noMarker] Evaluation complete
"
`;

exports[`Expressions: Binary operators Or-shortcut-true test case 1`] = `
"if (true || 1 + 2 === 2 + 3) { 1;} else { 2;}
[noMarker] Start of evaluation

if (true || 1 + 2 === 2 + 3) { 1;} else { 2;}
[beforeMarker] OR operation evaluated, left of operator is true, stop evaluation

if (true) { 1;} else { 2;}
[afterMarker] OR operation evaluated, left of operator is true, stop evaluation

if (true) { 1;} else { 2;}
[beforeMarker] If statement evaluated, condition true, proceed to if block

{ undefined; 1;}
[afterMarker] If statement evaluated, condition true, proceed to if block

{ undefined; 1;}
[beforeMarker] undefined finished evaluating

{ 1;}
[afterMarker] undefined finished evaluating

{ 1;}
[beforeMarker] 1; finished evaluating

1;
[afterMarker] 1; finished evaluating

1;
[noMarker] Evaluation complete
"
`;

exports[`Expressions: Binary operators Prim-binary-reduce test case 1`] = `
"if (1 >= 2) { 1;} else { 2;}
[noMarker] Start of evaluation

if (1 >= 2) { 1;} else { 2;}
[beforeMarker] Binary expression 1 >= 2 evaluated

if (false) { 1;} else { 2;}
[afterMarker] Binary expression 1 >= 2 evaluated

if (false) { 1;} else { 2;}
[beforeMarker] If statement evaluated, condition false, proceed to else block

{ undefined; 2;}
[afterMarker] If statement evaluated, condition false, proceed to else block

{ undefined; 2;}
[beforeMarker] undefined finished evaluating

{ 2;}
[afterMarker] undefined finished evaluating

{ 2;}
[beforeMarker] 2; finished evaluating

2;
[afterMarker] 2; finished evaluating

2;
[noMarker] Evaluation complete
"
`;

exports[`Expressions: Binary operators Right-binary-reduce test case 1`] = `
"if (1 >= 1 + 1) { 1;} else { 2;}
[noMarker] Start of evaluation

if (1 >= 1 + 1) { 1;} else { 2;}
[beforeMarker] Binary expression 1 + 1 evaluated

if (1 >= 2) { 1;} else { 2;}
[afterMarker] Binary expression 1 + 1 evaluated

if (1 >= 2) { 1;} else { 2;}
[beforeMarker] Binary expression 1 >= 2 evaluated

if (false) { 1;} else { 2;}
[afterMarker] Binary expression 1 >= 2 evaluated

if (false) { 1;} else { 2;}
[beforeMarker] If statement evaluated, condition false, proceed to else block

{ undefined; 2;}
[afterMarker] If statement evaluated, condition false, proceed to else block

{ undefined; 2;}
[beforeMarker] undefined finished evaluating

{ 2;}
[afterMarker] undefined finished evaluating

{ 2;}
[beforeMarker] 2; finished evaluating

2;
[afterMarker] 2; finished evaluating

2;
[noMarker] Evaluation complete
"
`;

exports[`Expressions: conditionals Conditional-false-reduce test case 1`] = `
"false ? 1 + 2 : 2 + 3;
[noMarker] Start of evaluation

false ? 1 + 2 : 2 + 3;
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

2 + 3;
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

2 + 3;
[beforeMarker] Binary expression 2 + 3 evaluated

5;
[afterMarker] Binary expression 2 + 3 evaluated

5;
[noMarker] Evaluation complete
"
`;

exports[`Expressions: conditionals Conditional-predicate-reduce test case 1`] = `
"1 + 1 === 2 ? 1 + 2 : 2 + 3;
[noMarker] Start of evaluation

1 + 1 === 2 ? 1 + 2 : 2 + 3;
[beforeMarker] Binary expression 1 + 1 evaluated

2 === 2 ? 1 + 2 : 2 + 3;
[afterMarker] Binary expression 1 + 1 evaluated

2 === 2 ? 1 + 2 : 2 + 3;
[beforeMarker] Binary expression 2 === 2 evaluated

true ? 1 + 2 : 2 + 3;
[afterMarker] Binary expression 2 === 2 evaluated

true ? 1 + 2 : 2 + 3;
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

1 + 2;
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

1 + 2;
[beforeMarker] Binary expression 1 + 2 evaluated

3;
[afterMarker] Binary expression 1 + 2 evaluated

3;
[noMarker] Evaluation complete
"
`;

exports[`Expressions: conditionals Conditional-true-reduce test case 1`] = `
"true ? 1 + 2 : 2 + 3;
[noMarker] Start of evaluation

true ? 1 + 2 : 2 + 3;
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

1 + 2;
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

1 + 2;
[beforeMarker] Binary expression 1 + 2 evaluated

3;
[afterMarker] Binary expression 1 + 2 evaluated

3;
[noMarker] Evaluation complete
"
`;

exports[`Expresssions: Blocks Block-expression-empty-reduce test case 1`] = `
"function foo(x) {}foo(0);
[noMarker] Start of evaluation

function foo(x) {}foo(0);
[beforeMarker] Function foo declared, parameter(s) x required

(x => {})(0);
[afterMarker] Function foo declared, parameter(s) x required

(x => {})(0);
[beforeMarker] Function foo takes in 0 as input x

{};
[afterMarker] Function foo takes in 0 as input x

{};
[beforeMarker] Empty block expression evaluated

undefined;
[afterMarker] Empty block expression evaluated

undefined;
[noMarker] Evaluation complete
"
`;

exports[`Expresssions: Blocks Block-expression-intro test case 1`] = `
"function foo(x) { 1 + 1;}foo(0);
[noMarker] Start of evaluation

function foo(x) { 1 + 1;}foo(0);
[beforeMarker] Function foo declared, parameter(s) x required

(x => { 1 + 1;})(0);
[afterMarker] Function foo declared, parameter(s) x required

(x => { 1 + 1;})(0);
[beforeMarker] Function foo takes in 0 as input x

{ 1 + 1;};
[afterMarker] Function foo takes in 0 as input x

{ 1 + 1;};
[beforeMarker] Binary expression 1 + 1 evaluated

{ 2;};
[afterMarker] Binary expression 1 + 1 evaluated

{ 2;};
[beforeMarker] 2; finished evaluating

undefined;
[afterMarker] 2; finished evaluating

undefined;
[noMarker] Evaluation complete
"
`;

exports[`Expresssions: Blocks Block-expression-single-reduce test case 1`] = `
"function foo(x) { 1;}foo(0);
[noMarker] Start of evaluation

function foo(x) { 1;}foo(0);
[beforeMarker] Function foo declared, parameter(s) x required

(x => { 1;})(0);
[afterMarker] Function foo declared, parameter(s) x required

(x => { 1;})(0);
[beforeMarker] Function foo takes in 0 as input x

{ 1;};
[afterMarker] Function foo takes in 0 as input x

{ 1;};
[beforeMarker] 1; finished evaluating

undefined;
[afterMarker] 1; finished evaluating

undefined;
[noMarker] Evaluation complete
"
`;

exports[`Function declaration with if else block 1`] = `
"function f() { const x = 2; if (true) { 5 + x; return 2; } else {}}f();
[noMarker] Start of evaluation

function f() { const x = 2; if (true) { 5 + x; return 2; } else {}}f();
[beforeMarker] Function f declared, parameter(s)  required

(() => { const x = 2; if (true) { 5 + x; return 2; } else {}})();
[afterMarker] Function f declared, parameter(s)  required

(() => { const x = 2; if (true) { 5 + x; return 2; } else {}})();
[beforeMarker] () => {...} runs

{ const x = 2; if (true) { 5 + x; return 2; } else {}};
[afterMarker] () => {...} runs

{ const x = 2; if (true) { 5 + x; return 2; } else {}};
[beforeMarker] Constant x declared and substituted into the rest of block

{ if (true) { 5 + 2; return 2; } else {}};
[afterMarker] Constant x declared and substituted into the rest of block

{ if (true) { 5 + 2; return 2; } else {}};
[beforeMarker] If statement evaluated, condition true, proceed to if block

{ { undefined; 5 + 2; return 2; }};
[afterMarker] If statement evaluated, condition true, proceed to if block

{ { undefined; 5 + 2; return 2; }};
[beforeMarker] Binary expression 5 + 2 evaluated

{ { undefined; 7; return 2; }};
[afterMarker] Binary expression 5 + 2 evaluated

{ { undefined; 7; return 2; }};
[beforeMarker] undefined finished evaluating

{ { 7; return 2; }};
[afterMarker] undefined finished evaluating

{ { 7; return 2; }};
[beforeMarker] 7 finished evaluating

{ { return 2; }};
[afterMarker] 7 finished evaluating

{ { return 2; }};
[beforeMarker] return 2; finished evaluating

{ return 2;};
[afterMarker] return 2; finished evaluating

{ return 2;};
[beforeMarker] 2 returned

2;
[afterMarker] 2 returned

2;
[noMarker] Evaluation complete
"
`;

exports[`If else statements test else 1`] = `
"if (1 !== 1) { 1;} else if (2 !== 2) { 2;} else { 3;}
[noMarker] Start of evaluation

if (1 !== 1) { 1;} else if (2 !== 2) { 2;} else { 3;}
[beforeMarker] Binary expression 1 !== 1 evaluated

if (false) { 1;} else if (2 !== 2) { 2;} else { 3;}
[afterMarker] Binary expression 1 !== 1 evaluated

if (false) { 1;} else if (2 !== 2) { 2;} else { 3;}
[beforeMarker] If statement evaluated, condition false, proceed to else block

if (2 !== 2) { 2;} else { 3;}
[afterMarker] If statement evaluated, condition false, proceed to else block

if (2 !== 2) { 2;} else { 3;}
[beforeMarker] Binary expression 2 !== 2 evaluated

if (false) { 2;} else { 3;}
[afterMarker] Binary expression 2 !== 2 evaluated

if (false) { 2;} else { 3;}
[beforeMarker] If statement evaluated, condition false, proceed to else block

{ undefined; 3;}
[afterMarker] If statement evaluated, condition false, proceed to else block

{ undefined; 3;}
[beforeMarker] undefined finished evaluating

{ 3;}
[afterMarker] undefined finished evaluating

{ 3;}
[beforeMarker] 3; finished evaluating

3;
[afterMarker] 3; finished evaluating

3;
[noMarker] Evaluation complete
"
`;

exports[`If else statements test else if 1`] = `
"if (1 !== 1) { 1;} else if (2 === 2) { 2;} else { 3;}
[noMarker] Start of evaluation

if (1 !== 1) { 1;} else if (2 === 2) { 2;} else { 3;}
[beforeMarker] Binary expression 1 !== 1 evaluated

if (false) { 1;} else if (2 === 2) { 2;} else { 3;}
[afterMarker] Binary expression 1 !== 1 evaluated

if (false) { 1;} else if (2 === 2) { 2;} else { 3;}
[beforeMarker] If statement evaluated, condition false, proceed to else block

if (2 === 2) { 2;} else { 3;}
[afterMarker] If statement evaluated, condition false, proceed to else block

if (2 === 2) { 2;} else { 3;}
[beforeMarker] Binary expression 2 === 2 evaluated

if (true) { 2;} else { 3;}
[afterMarker] Binary expression 2 === 2 evaluated

if (true) { 2;} else { 3;}
[beforeMarker] If statement evaluated, condition true, proceed to if block

{ undefined; 2;}
[afterMarker] If statement evaluated, condition true, proceed to if block

{ undefined; 2;}
[beforeMarker] undefined finished evaluating

{ 2;}
[afterMarker] undefined finished evaluating

{ 2;}
[beforeMarker] 2; finished evaluating

2;
[afterMarker] 2; finished evaluating

2;
[noMarker] Evaluation complete
"
`;

exports[`If else statements test if 1`] = `
"if (1 === 1) { 1;} else if (2 === 2) { 2;} else { 3;}
[noMarker] Start of evaluation

if (1 === 1) { 1;} else if (2 === 2) { 2;} else { 3;}
[beforeMarker] Binary expression 1 === 1 evaluated

if (true) { 1;} else if (2 === 2) { 2;} else { 3;}
[afterMarker] Binary expression 1 === 1 evaluated

if (true) { 1;} else if (2 === 2) { 2;} else { 3;}
[beforeMarker] If statement evaluated, condition true, proceed to if block

{ undefined; 1;}
[afterMarker] If statement evaluated, condition true, proceed to if block

{ undefined; 1;}
[beforeMarker] undefined finished evaluating

{ 1;}
[afterMarker] undefined finished evaluating

{ 1;}
[beforeMarker] 1; finished evaluating

1;
[afterMarker] 1; finished evaluating

1;
[noMarker] Evaluation complete
"
`;

exports[`Lambda expression Basic bi function 1`] = `
"const add = (x, y) => x + y;add(2, 3);
[noMarker] Start of evaluation

const add = (x, y) => x + y;add(2, 3);
[beforeMarker] Constant add declared and substituted into the rest of block

((x, y) => x + y)(2, 3);
[afterMarker] Constant add declared and substituted into the rest of block

((x, y) => x + y)(2, 3);
[beforeMarker] 2, 3 substituted into x, y of (x, y) => x + y

2 + 3;
[afterMarker] 2, 3 substituted into x, y of (x, y) => x + y

2 + 3;
[beforeMarker] Binary expression 2 + 3 evaluated

5;
[afterMarker] Binary expression 2 + 3 evaluated

5;
[noMarker] Evaluation complete
"
`;

exports[`Lambda expression Basic function 1`] = `
"const y = 2;const f = x => x + y;f(1);
[noMarker] Start of evaluation

const y = 2;const f = x => x + y;f(1);
[beforeMarker] Constant y declared and substituted into the rest of block

const f = x => x + 2;f(1);
[afterMarker] Constant y declared and substituted into the rest of block

const f = x => x + 2;f(1);
[beforeMarker] Constant f declared and substituted into the rest of block

(x => x + 2)(1);
[afterMarker] Constant f declared and substituted into the rest of block

(x => x + 2)(1);
[beforeMarker] 1 substituted into x of x => x + 2

1 + 2;
[afterMarker] 1 substituted into x of x => x + 2

1 + 2;
[beforeMarker] Binary expression 1 + 2 evaluated

3;
[afterMarker] Binary expression 1 + 2 evaluated

3;
[noMarker] Evaluation complete
"
`;

exports[`Lambda expression Currying 1`] = `
"const add = x => y => x + y;add(2)(3);
[noMarker] Start of evaluation

const add = x => y => x + y;add(2)(3);
[beforeMarker] Constant add declared and substituted into the rest of block

(x => y => x + y)(2)(3);
[afterMarker] Constant add declared and substituted into the rest of block

(x => y => x + y)(2)(3);
[beforeMarker] 2 substituted into x of x => y => x + y

(y => 2 + y)(3);
[afterMarker] 2 substituted into x of x => y => x + y

(y => 2 + y)(3);
[beforeMarker] 3 substituted into y of y => 2 + y

2 + 3;
[afterMarker] 3 substituted into y of y => 2 + y

2 + 3;
[beforeMarker] Binary expression 2 + 3 evaluated

5;
[afterMarker] Binary expression 2 + 3 evaluated

5;
[noMarker] Evaluation complete
"
`;

exports[`Lambda expression Recursive function call 1`] = `
"const factorial = n => n === 0 ? 1 : n * factorial(n - 1);factorial(2);
[noMarker] Start of evaluation

const factorial = n => n === 0 ? 1 : n * factorial(n - 1);factorial(2);
[beforeMarker] Constant factorial declared and substituted into the rest of block

(n => n === 0 ? 1 : n * factorial(n - 1))(2);
[afterMarker] Constant factorial declared and substituted into the rest of block

(n => n === 0 ? 1 : n * factorial(n - 1))(2);
[beforeMarker] 2 substituted into n of n => n === 0 ? 1 : n * factorial(n - 1)

2 === 0 ? 1 : 2 * (n => n === 0 ? 1 : n * factorial(n - 1))(2 - 1);
[afterMarker] 2 substituted into n of n => n === 0 ? 1 : n * factorial(n - 1)

2 === 0 ? 1 : 2 * (n => n === 0 ? 1 : n * factorial(n - 1))(2 - 1);
[beforeMarker] Binary expression 2 === 0 evaluated

false ? 1 : 2 * (n => n === 0 ? 1 : n * factorial(n - 1))(2 - 1);
[afterMarker] Binary expression 2 === 0 evaluated

false ? 1 : 2 * (n => n === 0 ? 1 : n * factorial(n - 1))(2 - 1);
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

2 * (n => n === 0 ? 1 : n * factorial(n - 1))(2 - 1);
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

2 * (n => n === 0 ? 1 : n * factorial(n - 1))(2 - 1);
[beforeMarker] Binary expression 2 - 1 evaluated

2 * (n => n === 0 ? 1 : n * factorial(n - 1))(1);
[afterMarker] Binary expression 2 - 1 evaluated

2 * (n => n === 0 ? 1 : n * factorial(n - 1))(1);
[beforeMarker] 1 substituted into n of n => n === 0 ? 1 : n * factorial(n - 1)

2 * (1 === 0 ? 1 : 1 * (n => n === 0 ? 1 : n * factorial(n - 1))(1 - 1));
[afterMarker] 1 substituted into n of n => n === 0 ? 1 : n * factorial(n - 1)

2 * (1 === 0 ? 1 : 1 * (n => n === 0 ? 1 : n * factorial(n - 1))(1 - 1));
[beforeMarker] Binary expression 1 === 0 evaluated

2 * (false ? 1 : 1 * (n => n === 0 ? 1 : n * factorial(n - 1))(1 - 1));
[afterMarker] Binary expression 1 === 0 evaluated

2 * (false ? 1 : 1 * (n => n === 0 ? 1 : n * factorial(n - 1))(1 - 1));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

2 * (1 * (n => n === 0 ? 1 : n * factorial(n - 1))(1 - 1));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

2 * (1 * (n => n === 0 ? 1 : n * factorial(n - 1))(1 - 1));
[beforeMarker] Binary expression 1 - 1 evaluated

2 * (1 * (n => n === 0 ? 1 : n * factorial(n - 1))(0));
[afterMarker] Binary expression 1 - 1 evaluated

2 * (1 * (n => n === 0 ? 1 : n * factorial(n - 1))(0));
[beforeMarker] 0 substituted into n of n => n === 0 ? 1 : n * factorial(n - 1)

2 * (1 * (0 === 0 ? 1 : 0 * (n => n === 0 ? 1 : n * factorial(n - 1))(0 - 1)));
[afterMarker] 0 substituted into n of n => n === 0 ? 1 : n * factorial(n - 1)

2 * (1 * (0 === 0 ? 1 : 0 * (n => n === 0 ? 1 : n * factorial(n - 1))(0 - 1)));
[beforeMarker] Binary expression 0 === 0 evaluated

2 * (1 * (true ? 1 : 0 * (n => n === 0 ? 1 : n * factorial(n - 1))(0 - 1)));
[afterMarker] Binary expression 0 === 0 evaluated

2 * (1 * (true ? 1 : 0 * (n => n === 0 ? 1 : n * factorial(n - 1))(0 - 1)));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

2 * (1 * 1);
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

2 * (1 * 1);
[beforeMarker] Binary expression 1 * 1 evaluated

2 * 1;
[afterMarker] Binary expression 1 * 1 evaluated

2 * 1;
[beforeMarker] Binary expression 2 * 1 evaluated

2;
[afterMarker] Binary expression 2 * 1 evaluated

2;
[noMarker] Evaluation complete
"
`;

exports[`List operations Append on list of null 1`] = `
"const a = list(null);append(a, a);
[noMarker] Start of evaluation

const a = list(null);append(a, a);
[beforeMarker] list runs

const a = [null, null];append(a, a);
[afterMarker] list runs

const a = [null, null];append(a, a);
[beforeMarker] Constant a declared and substituted into the rest of block

append([null, null], [null, null]);
[afterMarker] Constant a declared and substituted into the rest of block

append([null, null], [null, null]);
[beforeMarker] append runs

$append([null, null], [null, null], xs => xs);
[afterMarker] append runs

$append([null, null], [null, null], xs => xs);
[beforeMarker] $append runs

((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([null, null], [null, null], xs => xs);
[afterMarker] $append runs

((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([null, null], [null, null], xs => xs);
[beforeMarker] [null, null], [null, null], xs => xs substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

is_null([null, null]) ? (xs => xs)([null, null]) : $append(tail([null, null]), [null, null], zs => (xs => xs)(pair(head([null, null]), zs)));
[afterMarker] [null, null], [null, null], xs => xs substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

is_null([null, null]) ? (xs => xs)([null, null]) : $append(tail([null, null]), [null, null], zs => (xs => xs)(pair(head([null, null]), zs)));
[beforeMarker] is_null runs

false ? (xs => xs)([null, null]) : $append(tail([null, null]), [null, null], zs => (xs => xs)(pair(head([null, null]), zs)));
[afterMarker] is_null runs

false ? (xs => xs)([null, null]) : $append(tail([null, null]), [null, null], zs => (xs => xs)(pair(head([null, null]), zs)));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

$append(tail([null, null]), [null, null], zs => (xs => xs)(pair(head([null, null]), zs)));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

$append(tail([null, null]), [null, null], zs => (xs => xs)(pair(head([null, null]), zs)));
[beforeMarker] tail runs

$append(null, [null, null], zs => (xs => xs)(pair(head([null, null]), zs)));
[afterMarker] tail runs

$append(null, [null, null], zs => (xs => xs)(pair(head([null, null]), zs)));
[beforeMarker] $append runs

((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))(null, [null, null], zs => (xs => xs)(pair(head([null, null]), zs)));
[afterMarker] $append runs

((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))(null, [null, null], zs => (xs => xs)(pair(head([null, null]), zs)));
[beforeMarker] null, [null, null], zs => (xs => xs)(pair(head([null, null]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

is_null(null) ? (zs => (xs => xs)(pair(head([null, null]), zs)))([null, null]) : $append(tail(null), [null, null], zs => (zs => (xs => xs)(pair(head([null, null]), zs)))(pair(head(null), zs)));
[afterMarker] null, [null, null], zs => (xs => xs)(pair(head([null, null]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

is_null(null) ? (zs => (xs => xs)(pair(head([null, null]), zs)))([null, null]) : $append(tail(null), [null, null], zs => (zs => (xs => xs)(pair(head([null, null]), zs)))(pair(head(null), zs)));
[beforeMarker] is_null runs

true ? (zs => (xs => xs)(pair(head([null, null]), zs)))([null, null]) : $append(tail(null), [null, null], zs => (zs => (xs => xs)(pair(head([null, null]), zs)))(pair(head(null), zs)));
[afterMarker] is_null runs

true ? (zs => (xs => xs)(pair(head([null, null]), zs)))([null, null]) : $append(tail(null), [null, null], zs => (zs => (xs => xs)(pair(head([null, null]), zs)))(pair(head(null), zs)));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

(zs => (xs => xs)(pair(head([null, null]), zs)))([null, null]);
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

(zs => (xs => xs)(pair(head([null, null]), zs)))([null, null]);
[beforeMarker] [null, null] substituted into zs of zs => (xs => xs)(pair(head([null, null]), zs))

(xs => xs)(pair(head([null, null]), [null, null]));
[afterMarker] [null, null] substituted into zs of zs => (xs => xs)(pair(head([null, null]), zs))

(xs => xs)(pair(head([null, null]), [null, null]));
[beforeMarker] head runs

(xs => xs)(pair(null, [null, null]));
[afterMarker] head runs

(xs => xs)(pair(null, [null, null]));
[beforeMarker] pair runs

(xs => xs)([null, [null, null]]);
[afterMarker] pair runs

(xs => xs)([null, [null, null]]);
[beforeMarker] [null, [null, null]] substituted into xs of xs => xs

[null, [null, null]];
[afterMarker] [null, [null, null]] substituted into xs of xs => xs

[null, [null, null]];
[noMarker] Evaluation complete
"
`;

exports[`List operations accumulate on list 1`] = `
"accumulate((x, y) => x + y, 0, list(1, 2, 3)) === 6;
[noMarker] Start of evaluation

accumulate((x, y) => x + y, 0, list(1, 2, 3)) === 6;
[beforeMarker] list runs

accumulate((x, y) => x + y, 0, [1, [2, [3, null]]]) === 6;
[afterMarker] list runs

accumulate((x, y) => x + y, 0, [1, [2, [3, null]]]) === 6;
[beforeMarker] accumulate runs

$accumulate((x, y) => x + y, 0, [1, [2, [3, null]]], x => x) === 6;
[afterMarker] accumulate runs

$accumulate((x, y) => x + y, 0, [1, [2, [3, null]]], x => x) === 6;
[beforeMarker] $accumulate runs

((f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x))))((x, y) => x + y, 0, [1, [2, [3, null]]], x => x) === 6;
[afterMarker] $accumulate runs

((f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x))))((x, y) => x + y, 0, [1, [2, [3, null]]], x => x) === 6;
[beforeMarker] (x, y) => x + y, 0, [1, [2, [3, null]]], x => x substituted into f, initial, xs, cont of (f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x)))

(is_null([1, [2, [3, null]]]) ? (x => x)(0) : $accumulate((x, y) => x + y, 0, tail([1, [2, [3, null]]]), x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))) === 6;
[afterMarker] (x, y) => x + y, 0, [1, [2, [3, null]]], x => x substituted into f, initial, xs, cont of (f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x)))

(is_null([1, [2, [3, null]]]) ? (x => x)(0) : $accumulate((x, y) => x + y, 0, tail([1, [2, [3, null]]]), x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))) === 6;
[beforeMarker] is_null runs

(false ? (x => x)(0) : $accumulate((x, y) => x + y, 0, tail([1, [2, [3, null]]]), x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))) === 6;
[afterMarker] is_null runs

(false ? (x => x)(0) : $accumulate((x, y) => x + y, 0, tail([1, [2, [3, null]]]), x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))) === 6;
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

$accumulate((x, y) => x + y, 0, tail([1, [2, [3, null]]]), x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x))) === 6;
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

$accumulate((x, y) => x + y, 0, tail([1, [2, [3, null]]]), x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x))) === 6;
[beforeMarker] tail runs

$accumulate((x, y) => x + y, 0, [2, [3, null]], x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x))) === 6;
[afterMarker] tail runs

$accumulate((x, y) => x + y, 0, [2, [3, null]], x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x))) === 6;
[beforeMarker] $accumulate runs

((f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x))))((x, y) => x + y, 0, [2, [3, null]], x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x))) === 6;
[afterMarker] $accumulate runs

((f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x))))((x, y) => x + y, 0, [2, [3, null]], x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x))) === 6;
[beforeMarker] (x, y) => x + y, 0, [2, [3, null]], x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)) substituted into f, initial, xs, cont of (f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x)))

(is_null([2, [3, null]]) ? (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(0) : $accumulate((x, y) => x + y, 0, tail([2, [3, null]]), x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))) === 6;
[afterMarker] (x, y) => x + y, 0, [2, [3, null]], x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)) substituted into f, initial, xs, cont of (f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x)))

(is_null([2, [3, null]]) ? (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(0) : $accumulate((x, y) => x + y, 0, tail([2, [3, null]]), x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))) === 6;
[beforeMarker] is_null runs

(false ? (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(0) : $accumulate((x, y) => x + y, 0, tail([2, [3, null]]), x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))) === 6;
[afterMarker] is_null runs

(false ? (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(0) : $accumulate((x, y) => x + y, 0, tail([2, [3, null]]), x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))) === 6;
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

$accumulate((x, y) => x + y, 0, tail([2, [3, null]]), x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x))) === 6;
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

$accumulate((x, y) => x + y, 0, tail([2, [3, null]]), x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x))) === 6;
[beforeMarker] tail runs

$accumulate((x, y) => x + y, 0, [3, null], x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x))) === 6;
[afterMarker] tail runs

$accumulate((x, y) => x + y, 0, [3, null], x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x))) === 6;
[beforeMarker] $accumulate runs

((f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x))))((x, y) => x + y, 0, [3, null], x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x))) === 6;
[afterMarker] $accumulate runs

((f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x))))((x, y) => x + y, 0, [3, null], x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x))) === 6;
[beforeMarker] (x, y) => x + y, 0, [3, null], x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)) substituted into f, initial, xs, cont of (f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x)))

(is_null([3, null]) ? (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(0) : $accumulate((x, y) => x + y, 0, tail([3, null]), x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x)))) === 6;
[afterMarker] (x, y) => x + y, 0, [3, null], x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)) substituted into f, initial, xs, cont of (f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x)))

(is_null([3, null]) ? (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(0) : $accumulate((x, y) => x + y, 0, tail([3, null]), x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x)))) === 6;
[beforeMarker] is_null runs

(false ? (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(0) : $accumulate((x, y) => x + y, 0, tail([3, null]), x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x)))) === 6;
[afterMarker] is_null runs

(false ? (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(0) : $accumulate((x, y) => x + y, 0, tail([3, null]), x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x)))) === 6;
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

$accumulate((x, y) => x + y, 0, tail([3, null]), x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x))) === 6;
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

$accumulate((x, y) => x + y, 0, tail([3, null]), x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x))) === 6;
[beforeMarker] tail runs

$accumulate((x, y) => x + y, 0, null, x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x))) === 6;
[afterMarker] tail runs

$accumulate((x, y) => x + y, 0, null, x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x))) === 6;
[beforeMarker] $accumulate runs

((f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x))))((x, y) => x + y, 0, null, x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x))) === 6;
[afterMarker] $accumulate runs

((f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x))))((x, y) => x + y, 0, null, x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x))) === 6;
[beforeMarker] (x, y) => x + y, 0, null, x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x)) substituted into f, initial, xs, cont of (f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x)))

(is_null(null) ? (x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x)))(0) : $accumulate((x, y) => x + y, 0, tail(null), x => (x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x)))(((x, y) => x + y)(head(null), x)))) === 6;
[afterMarker] (x, y) => x + y, 0, null, x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x)) substituted into f, initial, xs, cont of (f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x)))

(is_null(null) ? (x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x)))(0) : $accumulate((x, y) => x + y, 0, tail(null), x => (x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x)))(((x, y) => x + y)(head(null), x)))) === 6;
[beforeMarker] is_null runs

(true ? (x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x)))(0) : $accumulate((x, y) => x + y, 0, tail(null), x => (x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x)))(((x, y) => x + y)(head(null), x)))) === 6;
[afterMarker] is_null runs

(true ? (x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x)))(0) : $accumulate((x, y) => x + y, 0, tail(null), x => (x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x)))(((x, y) => x + y)(head(null), x)))) === 6;
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

(x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x)))(0) === 6;
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

(x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x)))(0) === 6;
[beforeMarker] 0 substituted into x of x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x))

(x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), 0)) === 6;
[afterMarker] 0 substituted into x of x => (x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), x))

(x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(head([3, null]), 0)) === 6;
[beforeMarker] head runs

(x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(3, 0)) === 6;
[afterMarker] head runs

(x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(((x, y) => x + y)(3, 0)) === 6;
[beforeMarker] 3, 0 substituted into x, y of (x, y) => x + y

(x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(3 + 0) === 6;
[afterMarker] 3, 0 substituted into x, y of (x, y) => x + y

(x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(3 + 0) === 6;
[beforeMarker] Binary expression 3 + 0 evaluated

(x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(3) === 6;
[afterMarker] Binary expression 3 + 0 evaluated

(x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x)))(3) === 6;
[beforeMarker] 3 substituted into x of x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x))

(x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), 3)) === 6;
[afterMarker] 3 substituted into x of x => (x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), x))

(x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(head([2, [3, null]]), 3)) === 6;
[beforeMarker] head runs

(x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(2, 3)) === 6;
[afterMarker] head runs

(x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(((x, y) => x + y)(2, 3)) === 6;
[beforeMarker] 2, 3 substituted into x, y of (x, y) => x + y

(x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(2 + 3) === 6;
[afterMarker] 2, 3 substituted into x, y of (x, y) => x + y

(x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(2 + 3) === 6;
[beforeMarker] Binary expression 2 + 3 evaluated

(x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(5) === 6;
[afterMarker] Binary expression 2 + 3 evaluated

(x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x)))(5) === 6;
[beforeMarker] 5 substituted into x of x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x))

(x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), 5)) === 6;
[afterMarker] 5 substituted into x of x => (x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), x))

(x => x)(((x, y) => x + y)(head([1, [2, [3, null]]]), 5)) === 6;
[beforeMarker] head runs

(x => x)(((x, y) => x + y)(1, 5)) === 6;
[afterMarker] head runs

(x => x)(((x, y) => x + y)(1, 5)) === 6;
[beforeMarker] 1, 5 substituted into x, y of (x, y) => x + y

(x => x)(1 + 5) === 6;
[afterMarker] 1, 5 substituted into x, y of (x, y) => x + y

(x => x)(1 + 5) === 6;
[beforeMarker] Binary expression 1 + 5 evaluated

(x => x)(6) === 6;
[afterMarker] Binary expression 1 + 5 evaluated

(x => x)(6) === 6;
[beforeMarker] 6 substituted into x of x => x

6 === 6;
[afterMarker] 6 substituted into x of x => x

6 === 6;
[beforeMarker] Binary expression 6 === 6 evaluated

true;
[afterMarker] Binary expression 6 === 6 evaluated

true;
[noMarker] Evaluation complete
"
`;

exports[`List operations filter on list 1`] = `
"equal(filter(x => x % 2 === 1, list(1, 2, 3)), list(1, 3));
[noMarker] Start of evaluation

equal(filter(x => x % 2 === 1, list(1, 2, 3)), list(1, 3));
[beforeMarker] list runs

equal(filter(x => x % 2 === 1, [1, [2, [3, null]]]), list(1, 3));
[afterMarker] list runs

equal(filter(x => x % 2 === 1, [1, [2, [3, null]]]), list(1, 3));
[beforeMarker] filter runs

equal($filter(x => x % 2 === 1, [1, [2, [3, null]]], null), list(1, 3));
[afterMarker] filter runs

equal($filter(x => x % 2 === 1, [1, [2, [3, null]]], null), list(1, 3));
[beforeMarker] $filter runs

equal(((pred, xs, acc) => is_null(xs) ? reverse(acc) : pred(head(xs)) ? $filter(pred, tail(xs), pair(head(xs), acc)) : $filter(pred, tail(xs), acc))(x => x % 2 === 1, [1, [2, [3, null]]], null), list(1, 3));
[afterMarker] $filter runs

equal(((pred, xs, acc) => is_null(xs) ? reverse(acc) : pred(head(xs)) ? $filter(pred, tail(xs), pair(head(xs), acc)) : $filter(pred, tail(xs), acc))(x => x % 2 === 1, [1, [2, [3, null]]], null), list(1, 3));
[beforeMarker] x => x % 2 === 1, [1, [2, [3, null]]], null substituted into pred, xs, acc of (pred, xs, acc) => is_null(xs) ? reverse(acc) : pred(head(xs)) ? $filter(pred, tail(xs), pair(head(xs), acc)) : $filter(pred, tail(xs), acc)

equal(is_null([1, [2, [3, null]]]) ? reverse(null) : (x => x % 2 === 1)(head([1, [2, [3, null]]])) ? $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), pair(head([1, [2, [3, null]]]), null)) : $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), null), list(1, 3));
[afterMarker] x => x % 2 === 1, [1, [2, [3, null]]], null substituted into pred, xs, acc of (pred, xs, acc) => is_null(xs) ? reverse(acc) : pred(head(xs)) ? $filter(pred, tail(xs), pair(head(xs), acc)) : $filter(pred, tail(xs), acc)

equal(is_null([1, [2, [3, null]]]) ? reverse(null) : (x => x % 2 === 1)(head([1, [2, [3, null]]])) ? $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), pair(head([1, [2, [3, null]]]), null)) : $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), null), list(1, 3));
[beforeMarker] is_null runs

equal(false ? reverse(null) : (x => x % 2 === 1)(head([1, [2, [3, null]]])) ? $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), pair(head([1, [2, [3, null]]]), null)) : $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), null), list(1, 3));
[afterMarker] is_null runs

equal(false ? reverse(null) : (x => x % 2 === 1)(head([1, [2, [3, null]]])) ? $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), pair(head([1, [2, [3, null]]]), null)) : $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), null), list(1, 3));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal((x => x % 2 === 1)(head([1, [2, [3, null]]])) ? $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), pair(head([1, [2, [3, null]]]), null)) : $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), null), list(1, 3));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal((x => x % 2 === 1)(head([1, [2, [3, null]]])) ? $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), pair(head([1, [2, [3, null]]]), null)) : $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), null), list(1, 3));
[beforeMarker] head runs

equal((x => x % 2 === 1)(1) ? $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), pair(head([1, [2, [3, null]]]), null)) : $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), null), list(1, 3));
[afterMarker] head runs

equal((x => x % 2 === 1)(1) ? $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), pair(head([1, [2, [3, null]]]), null)) : $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), null), list(1, 3));
[beforeMarker] 1 substituted into x of x => x % 2 === 1

equal(1 % 2 === 1 ? $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), pair(head([1, [2, [3, null]]]), null)) : $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), null), list(1, 3));
[afterMarker] 1 substituted into x of x => x % 2 === 1

equal(1 % 2 === 1 ? $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), pair(head([1, [2, [3, null]]]), null)) : $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), null), list(1, 3));
[beforeMarker] Binary expression 1 % 2 evaluated

equal(1 === 1 ? $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), pair(head([1, [2, [3, null]]]), null)) : $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), null), list(1, 3));
[afterMarker] Binary expression 1 % 2 evaluated

equal(1 === 1 ? $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), pair(head([1, [2, [3, null]]]), null)) : $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), null), list(1, 3));
[beforeMarker] Binary expression 1 === 1 evaluated

equal(true ? $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), pair(head([1, [2, [3, null]]]), null)) : $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), null), list(1, 3));
[afterMarker] Binary expression 1 === 1 evaluated

equal(true ? $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), pair(head([1, [2, [3, null]]]), null)) : $filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), null), list(1, 3));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

equal($filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), pair(head([1, [2, [3, null]]]), null)), list(1, 3));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

equal($filter(x => x % 2 === 1, tail([1, [2, [3, null]]]), pair(head([1, [2, [3, null]]]), null)), list(1, 3));
[beforeMarker] tail runs

equal($filter(x => x % 2 === 1, [2, [3, null]], pair(head([1, [2, [3, null]]]), null)), list(1, 3));
[afterMarker] tail runs

equal($filter(x => x % 2 === 1, [2, [3, null]], pair(head([1, [2, [3, null]]]), null)), list(1, 3));
[beforeMarker] head runs

equal($filter(x => x % 2 === 1, [2, [3, null]], pair(1, null)), list(1, 3));
[afterMarker] head runs

equal($filter(x => x % 2 === 1, [2, [3, null]], pair(1, null)), list(1, 3));
[beforeMarker] pair runs

equal($filter(x => x % 2 === 1, [2, [3, null]], [1, null]), list(1, 3));
[afterMarker] pair runs

equal($filter(x => x % 2 === 1, [2, [3, null]], [1, null]), list(1, 3));
[beforeMarker] $filter runs

equal(((pred, xs, acc) => is_null(xs) ? reverse(acc) : pred(head(xs)) ? $filter(pred, tail(xs), pair(head(xs), acc)) : $filter(pred, tail(xs), acc))(x => x % 2 === 1, [2, [3, null]], [1, null]), list(1, 3));
[afterMarker] $filter runs

equal(((pred, xs, acc) => is_null(xs) ? reverse(acc) : pred(head(xs)) ? $filter(pred, tail(xs), pair(head(xs), acc)) : $filter(pred, tail(xs), acc))(x => x % 2 === 1, [2, [3, null]], [1, null]), list(1, 3));
[beforeMarker] x => x % 2 === 1, [2, [3, null]], [1, null] substituted into pred, xs, acc of (pred, xs, acc) => is_null(xs) ? reverse(acc) : pred(head(xs)) ? $filter(pred, tail(xs), pair(head(xs), acc)) : $filter(pred, tail(xs), acc)

equal(is_null([2, [3, null]]) ? reverse([1, null]) : (x => x % 2 === 1)(head([2, [3, null]])) ? $filter(x => x % 2 === 1, tail([2, [3, null]]), pair(head([2, [3, null]]), [1, null])) : $filter(x => x % 2 === 1, tail([2, [3, null]]), [1, null]), list(1, 3));
[afterMarker] x => x % 2 === 1, [2, [3, null]], [1, null] substituted into pred, xs, acc of (pred, xs, acc) => is_null(xs) ? reverse(acc) : pred(head(xs)) ? $filter(pred, tail(xs), pair(head(xs), acc)) : $filter(pred, tail(xs), acc)

equal(is_null([2, [3, null]]) ? reverse([1, null]) : (x => x % 2 === 1)(head([2, [3, null]])) ? $filter(x => x % 2 === 1, tail([2, [3, null]]), pair(head([2, [3, null]]), [1, null])) : $filter(x => x % 2 === 1, tail([2, [3, null]]), [1, null]), list(1, 3));
[beforeMarker] is_null runs

equal(false ? reverse([1, null]) : (x => x % 2 === 1)(head([2, [3, null]])) ? $filter(x => x % 2 === 1, tail([2, [3, null]]), pair(head([2, [3, null]]), [1, null])) : $filter(x => x % 2 === 1, tail([2, [3, null]]), [1, null]), list(1, 3));
[afterMarker] is_null runs

equal(false ? reverse([1, null]) : (x => x % 2 === 1)(head([2, [3, null]])) ? $filter(x => x % 2 === 1, tail([2, [3, null]]), pair(head([2, [3, null]]), [1, null])) : $filter(x => x % 2 === 1, tail([2, [3, null]]), [1, null]), list(1, 3));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal((x => x % 2 === 1)(head([2, [3, null]])) ? $filter(x => x % 2 === 1, tail([2, [3, null]]), pair(head([2, [3, null]]), [1, null])) : $filter(x => x % 2 === 1, tail([2, [3, null]]), [1, null]), list(1, 3));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal((x => x % 2 === 1)(head([2, [3, null]])) ? $filter(x => x % 2 === 1, tail([2, [3, null]]), pair(head([2, [3, null]]), [1, null])) : $filter(x => x % 2 === 1, tail([2, [3, null]]), [1, null]), list(1, 3));
[beforeMarker] head runs

equal((x => x % 2 === 1)(2) ? $filter(x => x % 2 === 1, tail([2, [3, null]]), pair(head([2, [3, null]]), [1, null])) : $filter(x => x % 2 === 1, tail([2, [3, null]]), [1, null]), list(1, 3));
[afterMarker] head runs

equal((x => x % 2 === 1)(2) ? $filter(x => x % 2 === 1, tail([2, [3, null]]), pair(head([2, [3, null]]), [1, null])) : $filter(x => x % 2 === 1, tail([2, [3, null]]), [1, null]), list(1, 3));
[beforeMarker] 2 substituted into x of x => x % 2 === 1

equal(2 % 2 === 1 ? $filter(x => x % 2 === 1, tail([2, [3, null]]), pair(head([2, [3, null]]), [1, null])) : $filter(x => x % 2 === 1, tail([2, [3, null]]), [1, null]), list(1, 3));
[afterMarker] 2 substituted into x of x => x % 2 === 1

equal(2 % 2 === 1 ? $filter(x => x % 2 === 1, tail([2, [3, null]]), pair(head([2, [3, null]]), [1, null])) : $filter(x => x % 2 === 1, tail([2, [3, null]]), [1, null]), list(1, 3));
[beforeMarker] Binary expression 2 % 2 evaluated

equal(0 === 1 ? $filter(x => x % 2 === 1, tail([2, [3, null]]), pair(head([2, [3, null]]), [1, null])) : $filter(x => x % 2 === 1, tail([2, [3, null]]), [1, null]), list(1, 3));
[afterMarker] Binary expression 2 % 2 evaluated

equal(0 === 1 ? $filter(x => x % 2 === 1, tail([2, [3, null]]), pair(head([2, [3, null]]), [1, null])) : $filter(x => x % 2 === 1, tail([2, [3, null]]), [1, null]), list(1, 3));
[beforeMarker] Binary expression 0 === 1 evaluated

equal(false ? $filter(x => x % 2 === 1, tail([2, [3, null]]), pair(head([2, [3, null]]), [1, null])) : $filter(x => x % 2 === 1, tail([2, [3, null]]), [1, null]), list(1, 3));
[afterMarker] Binary expression 0 === 1 evaluated

equal(false ? $filter(x => x % 2 === 1, tail([2, [3, null]]), pair(head([2, [3, null]]), [1, null])) : $filter(x => x % 2 === 1, tail([2, [3, null]]), [1, null]), list(1, 3));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal($filter(x => x % 2 === 1, tail([2, [3, null]]), [1, null]), list(1, 3));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal($filter(x => x % 2 === 1, tail([2, [3, null]]), [1, null]), list(1, 3));
[beforeMarker] tail runs

equal($filter(x => x % 2 === 1, [3, null], [1, null]), list(1, 3));
[afterMarker] tail runs

equal($filter(x => x % 2 === 1, [3, null], [1, null]), list(1, 3));
[beforeMarker] $filter runs

equal(((pred, xs, acc) => is_null(xs) ? reverse(acc) : pred(head(xs)) ? $filter(pred, tail(xs), pair(head(xs), acc)) : $filter(pred, tail(xs), acc))(x => x % 2 === 1, [3, null], [1, null]), list(1, 3));
[afterMarker] $filter runs

equal(((pred, xs, acc) => is_null(xs) ? reverse(acc) : pred(head(xs)) ? $filter(pred, tail(xs), pair(head(xs), acc)) : $filter(pred, tail(xs), acc))(x => x % 2 === 1, [3, null], [1, null]), list(1, 3));
[beforeMarker] x => x % 2 === 1, [3, null], [1, null] substituted into pred, xs, acc of (pred, xs, acc) => is_null(xs) ? reverse(acc) : pred(head(xs)) ? $filter(pred, tail(xs), pair(head(xs), acc)) : $filter(pred, tail(xs), acc)

equal(is_null([3, null]) ? reverse([1, null]) : (x => x % 2 === 1)(head([3, null])) ? $filter(x => x % 2 === 1, tail([3, null]), pair(head([3, null]), [1, null])) : $filter(x => x % 2 === 1, tail([3, null]), [1, null]), list(1, 3));
[afterMarker] x => x % 2 === 1, [3, null], [1, null] substituted into pred, xs, acc of (pred, xs, acc) => is_null(xs) ? reverse(acc) : pred(head(xs)) ? $filter(pred, tail(xs), pair(head(xs), acc)) : $filter(pred, tail(xs), acc)

equal(is_null([3, null]) ? reverse([1, null]) : (x => x % 2 === 1)(head([3, null])) ? $filter(x => x % 2 === 1, tail([3, null]), pair(head([3, null]), [1, null])) : $filter(x => x % 2 === 1, tail([3, null]), [1, null]), list(1, 3));
[beforeMarker] is_null runs

equal(false ? reverse([1, null]) : (x => x % 2 === 1)(head([3, null])) ? $filter(x => x % 2 === 1, tail([3, null]), pair(head([3, null]), [1, null])) : $filter(x => x % 2 === 1, tail([3, null]), [1, null]), list(1, 3));
[afterMarker] is_null runs

equal(false ? reverse([1, null]) : (x => x % 2 === 1)(head([3, null])) ? $filter(x => x % 2 === 1, tail([3, null]), pair(head([3, null]), [1, null])) : $filter(x => x % 2 === 1, tail([3, null]), [1, null]), list(1, 3));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal((x => x % 2 === 1)(head([3, null])) ? $filter(x => x % 2 === 1, tail([3, null]), pair(head([3, null]), [1, null])) : $filter(x => x % 2 === 1, tail([3, null]), [1, null]), list(1, 3));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal((x => x % 2 === 1)(head([3, null])) ? $filter(x => x % 2 === 1, tail([3, null]), pair(head([3, null]), [1, null])) : $filter(x => x % 2 === 1, tail([3, null]), [1, null]), list(1, 3));
[beforeMarker] head runs

equal((x => x % 2 === 1)(3) ? $filter(x => x % 2 === 1, tail([3, null]), pair(head([3, null]), [1, null])) : $filter(x => x % 2 === 1, tail([3, null]), [1, null]), list(1, 3));
[afterMarker] head runs

equal((x => x % 2 === 1)(3) ? $filter(x => x % 2 === 1, tail([3, null]), pair(head([3, null]), [1, null])) : $filter(x => x % 2 === 1, tail([3, null]), [1, null]), list(1, 3));
[beforeMarker] 3 substituted into x of x => x % 2 === 1

equal(3 % 2 === 1 ? $filter(x => x % 2 === 1, tail([3, null]), pair(head([3, null]), [1, null])) : $filter(x => x % 2 === 1, tail([3, null]), [1, null]), list(1, 3));
[afterMarker] 3 substituted into x of x => x % 2 === 1

equal(3 % 2 === 1 ? $filter(x => x % 2 === 1, tail([3, null]), pair(head([3, null]), [1, null])) : $filter(x => x % 2 === 1, tail([3, null]), [1, null]), list(1, 3));
[beforeMarker] Binary expression 3 % 2 evaluated

equal(1 === 1 ? $filter(x => x % 2 === 1, tail([3, null]), pair(head([3, null]), [1, null])) : $filter(x => x % 2 === 1, tail([3, null]), [1, null]), list(1, 3));
[afterMarker] Binary expression 3 % 2 evaluated

equal(1 === 1 ? $filter(x => x % 2 === 1, tail([3, null]), pair(head([3, null]), [1, null])) : $filter(x => x % 2 === 1, tail([3, null]), [1, null]), list(1, 3));
[beforeMarker] Binary expression 1 === 1 evaluated

equal(true ? $filter(x => x % 2 === 1, tail([3, null]), pair(head([3, null]), [1, null])) : $filter(x => x % 2 === 1, tail([3, null]), [1, null]), list(1, 3));
[afterMarker] Binary expression 1 === 1 evaluated

equal(true ? $filter(x => x % 2 === 1, tail([3, null]), pair(head([3, null]), [1, null])) : $filter(x => x % 2 === 1, tail([3, null]), [1, null]), list(1, 3));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

equal($filter(x => x % 2 === 1, tail([3, null]), pair(head([3, null]), [1, null])), list(1, 3));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

equal($filter(x => x % 2 === 1, tail([3, null]), pair(head([3, null]), [1, null])), list(1, 3));
[beforeMarker] tail runs

equal($filter(x => x % 2 === 1, null, pair(head([3, null]), [1, null])), list(1, 3));
[afterMarker] tail runs

equal($filter(x => x % 2 === 1, null, pair(head([3, null]), [1, null])), list(1, 3));
[beforeMarker] head runs

equal($filter(x => x % 2 === 1, null, pair(3, [1, null])), list(1, 3));
[afterMarker] head runs

equal($filter(x => x % 2 === 1, null, pair(3, [1, null])), list(1, 3));
[beforeMarker] pair runs

equal($filter(x => x % 2 === 1, null, [3, [1, null]]), list(1, 3));
[afterMarker] pair runs

equal($filter(x => x % 2 === 1, null, [3, [1, null]]), list(1, 3));
[beforeMarker] $filter runs

equal(((pred, xs, acc) => is_null(xs) ? reverse(acc) : pred(head(xs)) ? $filter(pred, tail(xs), pair(head(xs), acc)) : $filter(pred, tail(xs), acc))(x => x % 2 === 1, null, [3, [1, null]]), list(1, 3));
[afterMarker] $filter runs

equal(((pred, xs, acc) => is_null(xs) ? reverse(acc) : pred(head(xs)) ? $filter(pred, tail(xs), pair(head(xs), acc)) : $filter(pred, tail(xs), acc))(x => x % 2 === 1, null, [3, [1, null]]), list(1, 3));
[beforeMarker] x => x % 2 === 1, null, [3, [1, null]] substituted into pred, xs, acc of (pred, xs, acc) => is_null(xs) ? reverse(acc) : pred(head(xs)) ? $filter(pred, tail(xs), pair(head(xs), acc)) : $filter(pred, tail(xs), acc)

equal(is_null(null) ? reverse([3, [1, null]]) : (x => x % 2 === 1)(head(null)) ? $filter(x => x % 2 === 1, tail(null), pair(head(null), [3, [1, null]])) : $filter(x => x % 2 === 1, tail(null), [3, [1, null]]), list(1, 3));
[afterMarker] x => x % 2 === 1, null, [3, [1, null]] substituted into pred, xs, acc of (pred, xs, acc) => is_null(xs) ? reverse(acc) : pred(head(xs)) ? $filter(pred, tail(xs), pair(head(xs), acc)) : $filter(pred, tail(xs), acc)

equal(is_null(null) ? reverse([3, [1, null]]) : (x => x % 2 === 1)(head(null)) ? $filter(x => x % 2 === 1, tail(null), pair(head(null), [3, [1, null]])) : $filter(x => x % 2 === 1, tail(null), [3, [1, null]]), list(1, 3));
[beforeMarker] is_null runs

equal(true ? reverse([3, [1, null]]) : (x => x % 2 === 1)(head(null)) ? $filter(x => x % 2 === 1, tail(null), pair(head(null), [3, [1, null]])) : $filter(x => x % 2 === 1, tail(null), [3, [1, null]]), list(1, 3));
[afterMarker] is_null runs

equal(true ? reverse([3, [1, null]]) : (x => x % 2 === 1)(head(null)) ? $filter(x => x % 2 === 1, tail(null), pair(head(null), [3, [1, null]])) : $filter(x => x % 2 === 1, tail(null), [3, [1, null]]), list(1, 3));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

equal(reverse([3, [1, null]]), list(1, 3));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

equal(reverse([3, [1, null]]), list(1, 3));
[beforeMarker] reverse runs

equal($reverse([3, [1, null]], null), list(1, 3));
[afterMarker] reverse runs

equal($reverse([3, [1, null]], null), list(1, 3));
[beforeMarker] $reverse runs

equal(((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([3, [1, null]], null), list(1, 3));
[afterMarker] $reverse runs

equal(((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([3, [1, null]], null), list(1, 3));
[beforeMarker] [3, [1, null]], null substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

equal(is_null([3, [1, null]]) ? null : $reverse(tail([3, [1, null]]), pair(head([3, [1, null]]), null)), list(1, 3));
[afterMarker] [3, [1, null]], null substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

equal(is_null([3, [1, null]]) ? null : $reverse(tail([3, [1, null]]), pair(head([3, [1, null]]), null)), list(1, 3));
[beforeMarker] is_null runs

equal(false ? null : $reverse(tail([3, [1, null]]), pair(head([3, [1, null]]), null)), list(1, 3));
[afterMarker] is_null runs

equal(false ? null : $reverse(tail([3, [1, null]]), pair(head([3, [1, null]]), null)), list(1, 3));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal($reverse(tail([3, [1, null]]), pair(head([3, [1, null]]), null)), list(1, 3));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal($reverse(tail([3, [1, null]]), pair(head([3, [1, null]]), null)), list(1, 3));
[beforeMarker] tail runs

equal($reverse([1, null], pair(head([3, [1, null]]), null)), list(1, 3));
[afterMarker] tail runs

equal($reverse([1, null], pair(head([3, [1, null]]), null)), list(1, 3));
[beforeMarker] head runs

equal($reverse([1, null], pair(3, null)), list(1, 3));
[afterMarker] head runs

equal($reverse([1, null], pair(3, null)), list(1, 3));
[beforeMarker] pair runs

equal($reverse([1, null], [3, null]), list(1, 3));
[afterMarker] pair runs

equal($reverse([1, null], [3, null]), list(1, 3));
[beforeMarker] $reverse runs

equal(((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([1, null], [3, null]), list(1, 3));
[afterMarker] $reverse runs

equal(((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([1, null], [3, null]), list(1, 3));
[beforeMarker] [1, null], [3, null] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

equal(is_null([1, null]) ? [3, null] : $reverse(tail([1, null]), pair(head([1, null]), [3, null])), list(1, 3));
[afterMarker] [1, null], [3, null] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

equal(is_null([1, null]) ? [3, null] : $reverse(tail([1, null]), pair(head([1, null]), [3, null])), list(1, 3));
[beforeMarker] is_null runs

equal(false ? [3, null] : $reverse(tail([1, null]), pair(head([1, null]), [3, null])), list(1, 3));
[afterMarker] is_null runs

equal(false ? [3, null] : $reverse(tail([1, null]), pair(head([1, null]), [3, null])), list(1, 3));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal($reverse(tail([1, null]), pair(head([1, null]), [3, null])), list(1, 3));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal($reverse(tail([1, null]), pair(head([1, null]), [3, null])), list(1, 3));
[beforeMarker] tail runs

equal($reverse(null, pair(head([1, null]), [3, null])), list(1, 3));
[afterMarker] tail runs

equal($reverse(null, pair(head([1, null]), [3, null])), list(1, 3));
[beforeMarker] head runs

equal($reverse(null, pair(1, [3, null])), list(1, 3));
[afterMarker] head runs

equal($reverse(null, pair(1, [3, null])), list(1, 3));
[beforeMarker] pair runs

equal($reverse(null, [1, [3, null]]), list(1, 3));
[afterMarker] pair runs

equal($reverse(null, [1, [3, null]]), list(1, 3));
[beforeMarker] $reverse runs

equal(((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))(null, [1, [3, null]]), list(1, 3));
[afterMarker] $reverse runs

equal(((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))(null, [1, [3, null]]), list(1, 3));
[beforeMarker] null, [1, [3, null]] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

equal(is_null(null) ? [1, [3, null]] : $reverse(tail(null), pair(head(null), [1, [3, null]])), list(1, 3));
[afterMarker] null, [1, [3, null]] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

equal(is_null(null) ? [1, [3, null]] : $reverse(tail(null), pair(head(null), [1, [3, null]])), list(1, 3));
[beforeMarker] is_null runs

equal(true ? [1, [3, null]] : $reverse(tail(null), pair(head(null), [1, [3, null]])), list(1, 3));
[afterMarker] is_null runs

equal(true ? [1, [3, null]] : $reverse(tail(null), pair(head(null), [1, [3, null]])), list(1, 3));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

equal([1, [3, null]], list(1, 3));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

equal([1, [3, null]], list(1, 3));
[beforeMarker] list runs

equal([1, [3, null]], [1, [3, null]]);
[afterMarker] list runs

equal([1, [3, null]], [1, [3, null]]);
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)([1, [3, null]], [1, [3, null]]);
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)([1, [3, null]], [1, [3, null]]);
[beforeMarker] [1, [3, null]], [1, [3, null]] substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

is_pair([1, [3, null]]) ? is_pair([1, [3, null]]) && equal(head([1, [3, null]]), head([1, [3, null]])) && equal(tail([1, [3, null]]), tail([1, [3, null]])) : is_null([1, [3, null]]) ? is_null([1, [3, null]]) : is_number([1, [3, null]]) ? is_number([1, [3, null]]) && [1, [3, null]] === [1, [3, null]] : is_boolean([1, [3, null]]) ? is_boolean([1, [3, null]]) && ([1, [3, null]] && [1, [3, null]] || ![1, [3, null]] && ![1, [3, null]]) : is_string([1, [3, null]]) ? is_string([1, [3, null]]) && [1, [3, null]] === [1, [3, null]] : is_undefined([1, [3, null]]) ? is_undefined([1, [3, null]]) : is_function([1, [3, null]]) ? is_function([1, [3, null]]) && [1, [3, null]] === [1, [3, null]] : fals;
[afterMarker] [1, [3, null]], [1, [3, null]] substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

is_pair([1, [3, null]]) ? is_pair([1, [3, null]]) && equal(head([1, [3, null]]), head([1, [3, null]])) && equal(tail([1, [3, null]]), tail([1, [3, null]])) : is_null([1, [3, null]]) ? is_null([1, [3, null]]) : is_number([1, [3, null]]) ? is_number([1, [3, null]]) && [1, [3, null]] === [1, [3, null]] : is_boolean([1, [3, null]]) ? is_boolean([1, [3, null]]) && ([1, [3, null]] && [1, [3, null]] || ![1, [3, null]] && ![1, [3, null]]) : is_string([1, [3, null]]) ? is_string([1, [3, null]]) && [1, [3, null]] === [1, [3, null]] : is_undefined([1, [3, null]]) ? is_undefined([1, [3, null]]) : is_function([1, [3, null]]) ? is_function([1, [3, null]]) && [1, [3, null]] === [1, [3, null]] : fals;
[beforeMarker] is_pair runs

true ? is_pair([1, [3, null]]) && equal(head([1, [3, null]]), head([1, [3, null]])) && equal(tail([1, [3, null]]), tail([1, [3, null]])) : is_null([1, [3, null]]) ? is_null([1, [3, null]]) : is_number([1, [3, null]]) ? is_number([1, [3, null]]) && [1, [3, null]] === [1, [3, null]] : is_boolean([1, [3, null]]) ? is_boolean([1, [3, null]]) && ([1, [3, null]] && [1, [3, null]] || ![1, [3, null]] && ![1, [3, null]]) : is_string([1, [3, null]]) ? is_string([1, [3, null]]) && [1, [3, null]] === [1, [3, null]] : is_undefined([1, [3, null]]) ? is_undefined([1, [3, null]]) : is_function([1, [3, null]]) ? is_function([1, [3, null]]) && [1, [3, null]] === [1, [3, null]] : fals;
[afterMarker] is_pair runs

true ? is_pair([1, [3, null]]) && equal(head([1, [3, null]]), head([1, [3, null]])) && equal(tail([1, [3, null]]), tail([1, [3, null]])) : is_null([1, [3, null]]) ? is_null([1, [3, null]]) : is_number([1, [3, null]]) ? is_number([1, [3, null]]) && [1, [3, null]] === [1, [3, null]] : is_boolean([1, [3, null]]) ? is_boolean([1, [3, null]]) && ([1, [3, null]] && [1, [3, null]] || ![1, [3, null]] && ![1, [3, null]]) : is_string([1, [3, null]]) ? is_string([1, [3, null]]) && [1, [3, null]] === [1, [3, null]] : is_undefined([1, [3, null]]) ? is_undefined([1, [3, null]]) : is_function([1, [3, null]]) ? is_function([1, [3, null]]) && [1, [3, null]] === [1, [3, null]] : fals;
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_pair([1, [3, null]]) && equal(head([1, [3, null]]), head([1, [3, null]])) && equal(tail([1, [3, null]]), tail([1, [3, null]]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_pair([1, [3, null]]) && equal(head([1, [3, null]]), head([1, [3, null]])) && equal(tail([1, [3, null]]), tail([1, [3, null]]));
[beforeMarker] is_pair runs

true && equal(head([1, [3, null]]), head([1, [3, null]])) && equal(tail([1, [3, null]]), tail([1, [3, null]]));
[afterMarker] is_pair runs

true && equal(head([1, [3, null]]), head([1, [3, null]])) && equal(tail([1, [3, null]]), tail([1, [3, null]]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(head([1, [3, null]]), head([1, [3, null]])) && equal(tail([1, [3, null]]), tail([1, [3, null]]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(head([1, [3, null]]), head([1, [3, null]])) && equal(tail([1, [3, null]]), tail([1, [3, null]]));
[beforeMarker] head runs

equal(1, head([1, [3, null]])) && equal(tail([1, [3, null]]), tail([1, [3, null]]));
[afterMarker] head runs

equal(1, head([1, [3, null]])) && equal(tail([1, [3, null]]), tail([1, [3, null]]));
[beforeMarker] head runs

equal(1, 1) && equal(tail([1, [3, null]]), tail([1, [3, null]]));
[afterMarker] head runs

equal(1, 1) && equal(tail([1, [3, null]]), tail([1, [3, null]]));
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(1, 1) && equal(tail([1, [3, null]]), tail([1, [3, null]]));
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(1, 1) && equal(tail([1, [3, null]]), tail([1, [3, null]]));
[beforeMarker] 1, 1 substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair(1) ? is_pair(1) && equal(head(1), head(1)) && equal(tail(1), tail(1)) : is_null(1) ? is_null(1) : is_number(1) ? is_number(1) && 1 === 1 : is_boolean(1) ? is_boolean(1) && (1 && 1 || !1 && !1) : is_string(1) ? is_string(1) && 1 === 1 : is_undefined(1) ? is_undefined(1) : is_function(1) ? is_function(1) && 1 === 1 : fals) && equal(tail([1, [3, null]]), tail([1, [3, null]]));
[afterMarker] 1, 1 substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair(1) ? is_pair(1) && equal(head(1), head(1)) && equal(tail(1), tail(1)) : is_null(1) ? is_null(1) : is_number(1) ? is_number(1) && 1 === 1 : is_boolean(1) ? is_boolean(1) && (1 && 1 || !1 && !1) : is_string(1) ? is_string(1) && 1 === 1 : is_undefined(1) ? is_undefined(1) : is_function(1) ? is_function(1) && 1 === 1 : fals) && equal(tail([1, [3, null]]), tail([1, [3, null]]));
[beforeMarker] is_pair runs

(false ? is_pair(1) && equal(head(1), head(1)) && equal(tail(1), tail(1)) : is_null(1) ? is_null(1) : is_number(1) ? is_number(1) && 1 === 1 : is_boolean(1) ? is_boolean(1) && (1 && 1 || !1 && !1) : is_string(1) ? is_string(1) && 1 === 1 : is_undefined(1) ? is_undefined(1) : is_function(1) ? is_function(1) && 1 === 1 : fals) && equal(tail([1, [3, null]]), tail([1, [3, null]]));
[afterMarker] is_pair runs

(false ? is_pair(1) && equal(head(1), head(1)) && equal(tail(1), tail(1)) : is_null(1) ? is_null(1) : is_number(1) ? is_number(1) && 1 === 1 : is_boolean(1) ? is_boolean(1) && (1 && 1 || !1 && !1) : is_string(1) ? is_string(1) && 1 === 1 : is_undefined(1) ? is_undefined(1) : is_function(1) ? is_function(1) && 1 === 1 : fals) && equal(tail([1, [3, null]]), tail([1, [3, null]]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_null(1) ? is_null(1) : is_number(1) ? is_number(1) && 1 === 1 : is_boolean(1) ? is_boolean(1) && (1 && 1 || !1 && !1) : is_string(1) ? is_string(1) && 1 === 1 : is_undefined(1) ? is_undefined(1) : is_function(1) ? is_function(1) && 1 === 1 : fals) && equal(tail([1, [3, null]]), tail([1, [3, null]]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_null(1) ? is_null(1) : is_number(1) ? is_number(1) && 1 === 1 : is_boolean(1) ? is_boolean(1) && (1 && 1 || !1 && !1) : is_string(1) ? is_string(1) && 1 === 1 : is_undefined(1) ? is_undefined(1) : is_function(1) ? is_function(1) && 1 === 1 : fals) && equal(tail([1, [3, null]]), tail([1, [3, null]]));
[beforeMarker] is_null runs

(false ? is_null(1) : is_number(1) ? is_number(1) && 1 === 1 : is_boolean(1) ? is_boolean(1) && (1 && 1 || !1 && !1) : is_string(1) ? is_string(1) && 1 === 1 : is_undefined(1) ? is_undefined(1) : is_function(1) ? is_function(1) && 1 === 1 : fals) && equal(tail([1, [3, null]]), tail([1, [3, null]]));
[afterMarker] is_null runs

(false ? is_null(1) : is_number(1) ? is_number(1) && 1 === 1 : is_boolean(1) ? is_boolean(1) && (1 && 1 || !1 && !1) : is_string(1) ? is_string(1) && 1 === 1 : is_undefined(1) ? is_undefined(1) : is_function(1) ? is_function(1) && 1 === 1 : fals) && equal(tail([1, [3, null]]), tail([1, [3, null]]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_number(1) ? is_number(1) && 1 === 1 : is_boolean(1) ? is_boolean(1) && (1 && 1 || !1 && !1) : is_string(1) ? is_string(1) && 1 === 1 : is_undefined(1) ? is_undefined(1) : is_function(1) ? is_function(1) && 1 === 1 : fals) && equal(tail([1, [3, null]]), tail([1, [3, null]]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_number(1) ? is_number(1) && 1 === 1 : is_boolean(1) ? is_boolean(1) && (1 && 1 || !1 && !1) : is_string(1) ? is_string(1) && 1 === 1 : is_undefined(1) ? is_undefined(1) : is_function(1) ? is_function(1) && 1 === 1 : fals) && equal(tail([1, [3, null]]), tail([1, [3, null]]));
[beforeMarker] is_number runs

(true ? is_number(1) && 1 === 1 : is_boolean(1) ? is_boolean(1) && (1 && 1 || !1 && !1) : is_string(1) ? is_string(1) && 1 === 1 : is_undefined(1) ? is_undefined(1) : is_function(1) ? is_function(1) && 1 === 1 : fals) && equal(tail([1, [3, null]]), tail([1, [3, null]]));
[afterMarker] is_number runs

(true ? is_number(1) && 1 === 1 : is_boolean(1) ? is_boolean(1) && (1 && 1 || !1 && !1) : is_string(1) ? is_string(1) && 1 === 1 : is_undefined(1) ? is_undefined(1) : is_function(1) ? is_function(1) && 1 === 1 : fals) && equal(tail([1, [3, null]]), tail([1, [3, null]]));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_number(1) && 1 === 1 && equal(tail([1, [3, null]]), tail([1, [3, null]]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_number(1) && 1 === 1 && equal(tail([1, [3, null]]), tail([1, [3, null]]));
[beforeMarker] is_number runs

true && 1 === 1 && equal(tail([1, [3, null]]), tail([1, [3, null]]));
[afterMarker] is_number runs

true && 1 === 1 && equal(tail([1, [3, null]]), tail([1, [3, null]]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

1 === 1 && equal(tail([1, [3, null]]), tail([1, [3, null]]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

1 === 1 && equal(tail([1, [3, null]]), tail([1, [3, null]]));
[beforeMarker] Binary expression 1 === 1 evaluated

true && equal(tail([1, [3, null]]), tail([1, [3, null]]));
[afterMarker] Binary expression 1 === 1 evaluated

true && equal(tail([1, [3, null]]), tail([1, [3, null]]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(tail([1, [3, null]]), tail([1, [3, null]]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(tail([1, [3, null]]), tail([1, [3, null]]));
[beforeMarker] tail runs

equal([3, null], tail([1, [3, null]]));
[afterMarker] tail runs

equal([3, null], tail([1, [3, null]]));
[beforeMarker] tail runs

equal([3, null], [3, null]);
[afterMarker] tail runs

equal([3, null], [3, null]);
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)([3, null], [3, null]);
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)([3, null], [3, null]);
[beforeMarker] [3, null], [3, null] substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

is_pair([3, null]) ? is_pair([3, null]) && equal(head([3, null]), head([3, null])) && equal(tail([3, null]), tail([3, null])) : is_null([3, null]) ? is_null([3, null]) : is_number([3, null]) ? is_number([3, null]) && [3, null] === [3, null] : is_boolean([3, null]) ? is_boolean([3, null]) && ([3, null] && [3, null] || ![3, null] && ![3, null]) : is_string([3, null]) ? is_string([3, null]) && [3, null] === [3, null] : is_undefined([3, null]) ? is_undefined([3, null]) : is_function([3, null]) ? is_function([3, null]) && [3, null] === [3, null] : fals;
[afterMarker] [3, null], [3, null] substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

is_pair([3, null]) ? is_pair([3, null]) && equal(head([3, null]), head([3, null])) && equal(tail([3, null]), tail([3, null])) : is_null([3, null]) ? is_null([3, null]) : is_number([3, null]) ? is_number([3, null]) && [3, null] === [3, null] : is_boolean([3, null]) ? is_boolean([3, null]) && ([3, null] && [3, null] || ![3, null] && ![3, null]) : is_string([3, null]) ? is_string([3, null]) && [3, null] === [3, null] : is_undefined([3, null]) ? is_undefined([3, null]) : is_function([3, null]) ? is_function([3, null]) && [3, null] === [3, null] : fals;
[beforeMarker] is_pair runs

true ? is_pair([3, null]) && equal(head([3, null]), head([3, null])) && equal(tail([3, null]), tail([3, null])) : is_null([3, null]) ? is_null([3, null]) : is_number([3, null]) ? is_number([3, null]) && [3, null] === [3, null] : is_boolean([3, null]) ? is_boolean([3, null]) && ([3, null] && [3, null] || ![3, null] && ![3, null]) : is_string([3, null]) ? is_string([3, null]) && [3, null] === [3, null] : is_undefined([3, null]) ? is_undefined([3, null]) : is_function([3, null]) ? is_function([3, null]) && [3, null] === [3, null] : fals;
[afterMarker] is_pair runs

true ? is_pair([3, null]) && equal(head([3, null]), head([3, null])) && equal(tail([3, null]), tail([3, null])) : is_null([3, null]) ? is_null([3, null]) : is_number([3, null]) ? is_number([3, null]) && [3, null] === [3, null] : is_boolean([3, null]) ? is_boolean([3, null]) && ([3, null] && [3, null] || ![3, null] && ![3, null]) : is_string([3, null]) ? is_string([3, null]) && [3, null] === [3, null] : is_undefined([3, null]) ? is_undefined([3, null]) : is_function([3, null]) ? is_function([3, null]) && [3, null] === [3, null] : fals;
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_pair([3, null]) && equal(head([3, null]), head([3, null])) && equal(tail([3, null]), tail([3, null]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_pair([3, null]) && equal(head([3, null]), head([3, null])) && equal(tail([3, null]), tail([3, null]));
[beforeMarker] is_pair runs

true && equal(head([3, null]), head([3, null])) && equal(tail([3, null]), tail([3, null]));
[afterMarker] is_pair runs

true && equal(head([3, null]), head([3, null])) && equal(tail([3, null]), tail([3, null]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(head([3, null]), head([3, null])) && equal(tail([3, null]), tail([3, null]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(head([3, null]), head([3, null])) && equal(tail([3, null]), tail([3, null]));
[beforeMarker] head runs

equal(3, head([3, null])) && equal(tail([3, null]), tail([3, null]));
[afterMarker] head runs

equal(3, head([3, null])) && equal(tail([3, null]), tail([3, null]));
[beforeMarker] head runs

equal(3, 3) && equal(tail([3, null]), tail([3, null]));
[afterMarker] head runs

equal(3, 3) && equal(tail([3, null]), tail([3, null]));
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(3, 3) && equal(tail([3, null]), tail([3, null]));
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(3, 3) && equal(tail([3, null]), tail([3, null]));
[beforeMarker] 3, 3 substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair(3) ? is_pair(3) && equal(head(3), head(3)) && equal(tail(3), tail(3)) : is_null(3) ? is_null(3) : is_number(3) ? is_number(3) && 3 === 3 : is_boolean(3) ? is_boolean(3) && (3 && 3 || !3 && !3) : is_string(3) ? is_string(3) && 3 === 3 : is_undefined(3) ? is_undefined(3) : is_function(3) ? is_function(3) && 3 === 3 : fals) && equal(tail([3, null]), tail([3, null]));
[afterMarker] 3, 3 substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair(3) ? is_pair(3) && equal(head(3), head(3)) && equal(tail(3), tail(3)) : is_null(3) ? is_null(3) : is_number(3) ? is_number(3) && 3 === 3 : is_boolean(3) ? is_boolean(3) && (3 && 3 || !3 && !3) : is_string(3) ? is_string(3) && 3 === 3 : is_undefined(3) ? is_undefined(3) : is_function(3) ? is_function(3) && 3 === 3 : fals) && equal(tail([3, null]), tail([3, null]));
[beforeMarker] is_pair runs

(false ? is_pair(3) && equal(head(3), head(3)) && equal(tail(3), tail(3)) : is_null(3) ? is_null(3) : is_number(3) ? is_number(3) && 3 === 3 : is_boolean(3) ? is_boolean(3) && (3 && 3 || !3 && !3) : is_string(3) ? is_string(3) && 3 === 3 : is_undefined(3) ? is_undefined(3) : is_function(3) ? is_function(3) && 3 === 3 : fals) && equal(tail([3, null]), tail([3, null]));
[afterMarker] is_pair runs

(false ? is_pair(3) && equal(head(3), head(3)) && equal(tail(3), tail(3)) : is_null(3) ? is_null(3) : is_number(3) ? is_number(3) && 3 === 3 : is_boolean(3) ? is_boolean(3) && (3 && 3 || !3 && !3) : is_string(3) ? is_string(3) && 3 === 3 : is_undefined(3) ? is_undefined(3) : is_function(3) ? is_function(3) && 3 === 3 : fals) && equal(tail([3, null]), tail([3, null]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_null(3) ? is_null(3) : is_number(3) ? is_number(3) && 3 === 3 : is_boolean(3) ? is_boolean(3) && (3 && 3 || !3 && !3) : is_string(3) ? is_string(3) && 3 === 3 : is_undefined(3) ? is_undefined(3) : is_function(3) ? is_function(3) && 3 === 3 : fals) && equal(tail([3, null]), tail([3, null]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_null(3) ? is_null(3) : is_number(3) ? is_number(3) && 3 === 3 : is_boolean(3) ? is_boolean(3) && (3 && 3 || !3 && !3) : is_string(3) ? is_string(3) && 3 === 3 : is_undefined(3) ? is_undefined(3) : is_function(3) ? is_function(3) && 3 === 3 : fals) && equal(tail([3, null]), tail([3, null]));
[beforeMarker] is_null runs

(false ? is_null(3) : is_number(3) ? is_number(3) && 3 === 3 : is_boolean(3) ? is_boolean(3) && (3 && 3 || !3 && !3) : is_string(3) ? is_string(3) && 3 === 3 : is_undefined(3) ? is_undefined(3) : is_function(3) ? is_function(3) && 3 === 3 : fals) && equal(tail([3, null]), tail([3, null]));
[afterMarker] is_null runs

(false ? is_null(3) : is_number(3) ? is_number(3) && 3 === 3 : is_boolean(3) ? is_boolean(3) && (3 && 3 || !3 && !3) : is_string(3) ? is_string(3) && 3 === 3 : is_undefined(3) ? is_undefined(3) : is_function(3) ? is_function(3) && 3 === 3 : fals) && equal(tail([3, null]), tail([3, null]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_number(3) ? is_number(3) && 3 === 3 : is_boolean(3) ? is_boolean(3) && (3 && 3 || !3 && !3) : is_string(3) ? is_string(3) && 3 === 3 : is_undefined(3) ? is_undefined(3) : is_function(3) ? is_function(3) && 3 === 3 : fals) && equal(tail([3, null]), tail([3, null]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_number(3) ? is_number(3) && 3 === 3 : is_boolean(3) ? is_boolean(3) && (3 && 3 || !3 && !3) : is_string(3) ? is_string(3) && 3 === 3 : is_undefined(3) ? is_undefined(3) : is_function(3) ? is_function(3) && 3 === 3 : fals) && equal(tail([3, null]), tail([3, null]));
[beforeMarker] is_number runs

(true ? is_number(3) && 3 === 3 : is_boolean(3) ? is_boolean(3) && (3 && 3 || !3 && !3) : is_string(3) ? is_string(3) && 3 === 3 : is_undefined(3) ? is_undefined(3) : is_function(3) ? is_function(3) && 3 === 3 : fals) && equal(tail([3, null]), tail([3, null]));
[afterMarker] is_number runs

(true ? is_number(3) && 3 === 3 : is_boolean(3) ? is_boolean(3) && (3 && 3 || !3 && !3) : is_string(3) ? is_string(3) && 3 === 3 : is_undefined(3) ? is_undefined(3) : is_function(3) ? is_function(3) && 3 === 3 : fals) && equal(tail([3, null]), tail([3, null]));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_number(3) && 3 === 3 && equal(tail([3, null]), tail([3, null]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_number(3) && 3 === 3 && equal(tail([3, null]), tail([3, null]));
[beforeMarker] is_number runs

true && 3 === 3 && equal(tail([3, null]), tail([3, null]));
[afterMarker] is_number runs

true && 3 === 3 && equal(tail([3, null]), tail([3, null]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

3 === 3 && equal(tail([3, null]), tail([3, null]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

3 === 3 && equal(tail([3, null]), tail([3, null]));
[beforeMarker] Binary expression 3 === 3 evaluated

true && equal(tail([3, null]), tail([3, null]));
[afterMarker] Binary expression 3 === 3 evaluated

true && equal(tail([3, null]), tail([3, null]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(tail([3, null]), tail([3, null]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(tail([3, null]), tail([3, null]));
[beforeMarker] tail runs

equal(null, tail([3, null]));
[afterMarker] tail runs

equal(null, tail([3, null]));
[beforeMarker] tail runs

equal(null, null);
[afterMarker] tail runs

equal(null, null);
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(null, null);
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(null, null);
[beforeMarker] null, null substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

is_pair(null) ? is_pair(null) && equal(head(null), head(null)) && equal(tail(null), tail(null)) : is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals;
[afterMarker] null, null substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

is_pair(null) ? is_pair(null) && equal(head(null), head(null)) && equal(tail(null), tail(null)) : is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals;
[beforeMarker] is_pair runs

false ? is_pair(null) && equal(head(null), head(null)) && equal(tail(null), tail(null)) : is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals;
[afterMarker] is_pair runs

false ? is_pair(null) && equal(head(null), head(null)) && equal(tail(null), tail(null)) : is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals;
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals;
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals;
[beforeMarker] is_null runs

true ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals;
[afterMarker] is_null runs

true ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals;
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_null(null);
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_null(null);
[beforeMarker] is_null runs

true;
[afterMarker] is_null runs

true;
[noMarker] Evaluation complete
"
`;

exports[`List operations flatmap 1`] = `
"const flatMap = (f, xs) => accumulate((acc, init) => append(f(acc), init), null, xs);equal(flatMap(x => list(x, x + 1), list(2, 3, 4)), list(2, 3, 3, 4, 4, 5));
[noMarker] Start of evaluation

const flatMap = (f, xs) => accumulate((acc, init) => append(f(acc), init), null, xs);equal(flatMap(x => list(x, x + 1), list(2, 3, 4)), list(2, 3, 3, 4, 4, 5));
[beforeMarker] Constant flatMap declared and substituted into the rest of block

equal(((f, xs) => accumulate((acc, init) => append(f(acc), init), null, xs))(x => list(x, x + 1), list(2, 3, 4)), list(2, 3, 3, 4, 4, 5));
[afterMarker] Constant flatMap declared and substituted into the rest of block

equal(((f, xs) => accumulate((acc, init) => append(f(acc), init), null, xs))(x => list(x, x + 1), list(2, 3, 4)), list(2, 3, 3, 4, 4, 5));
[beforeMarker] list runs

equal(((f, xs) => accumulate((acc, init) => append(f(acc), init), null, xs))(x => list(x, x + 1), [2, [3, [4, null]]]), list(2, 3, 3, 4, 4, 5));
[afterMarker] list runs

equal(((f, xs) => accumulate((acc, init) => append(f(acc), init), null, xs))(x => list(x, x + 1), [2, [3, [4, null]]]), list(2, 3, 3, 4, 4, 5));
[beforeMarker] x => list(x, x + 1), [2, [3, [4, null]]] substituted into f, xs of (f, xs) => accumulate((acc, init) => append(f(acc), init), null, xs)

equal(accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, [2, [3, [4, null]]]), list(2, 3, 3, 4, 4, 5));
[afterMarker] x => list(x, x + 1), [2, [3, [4, null]]] substituted into f, xs of (f, xs) => accumulate((acc, init) => append(f(acc), init), null, xs)

equal(accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, [2, [3, [4, null]]]), list(2, 3, 3, 4, 4, 5));
[beforeMarker] accumulate runs

equal($accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, [2, [3, [4, null]]], x => x), list(2, 3, 3, 4, 4, 5));
[afterMarker] accumulate runs

equal($accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, [2, [3, [4, null]]], x => x), list(2, 3, 3, 4, 4, 5));
[beforeMarker] $accumulate runs

equal(((f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x))))((acc, init) => append((x => list(x, x + 1))(acc), init), null, [2, [3, [4, null]]], x => x), list(2, 3, 3, 4, 4, 5));
[afterMarker] $accumulate runs

equal(((f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x))))((acc, init) => append((x => list(x, x + 1))(acc), init), null, [2, [3, [4, null]]], x => x), list(2, 3, 3, 4, 4, 5));
[beforeMarker] (acc, init) => append((x => list(x, x + 1))(acc), init), null, [2, [3, [4, null]]], x => x substituted into f, initial, xs, cont of (f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x)))

equal(is_null([2, [3, [4, null]]]) ? (x => x)(null) : $accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail([2, [3, [4, null]]]), x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x))), list(2, 3, 3, 4, 4, 5));
[afterMarker] (acc, init) => append((x => list(x, x + 1))(acc), init), null, [2, [3, [4, null]]], x => x substituted into f, initial, xs, cont of (f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x)))

equal(is_null([2, [3, [4, null]]]) ? (x => x)(null) : $accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail([2, [3, [4, null]]]), x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] is_null runs

equal(false ? (x => x)(null) : $accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail([2, [3, [4, null]]]), x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x))), list(2, 3, 3, 4, 4, 5));
[afterMarker] is_null runs

equal(false ? (x => x)(null) : $accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail([2, [3, [4, null]]]), x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal($accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail([2, [3, [4, null]]]), x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x))), list(2, 3, 3, 4, 4, 5));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal($accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail([2, [3, [4, null]]]), x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] tail runs

equal($accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, [3, [4, null]], x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x))), list(2, 3, 3, 4, 4, 5));
[afterMarker] tail runs

equal($accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, [3, [4, null]], x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] $accumulate runs

equal(((f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x))))((acc, init) => append((x => list(x, x + 1))(acc), init), null, [3, [4, null]], x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x))), list(2, 3, 3, 4, 4, 5));
[afterMarker] $accumulate runs

equal(((f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x))))((acc, init) => append((x => list(x, x + 1))(acc), init), null, [3, [4, null]], x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] (acc, init) => append((x => list(x, x + 1))(acc), init), null, [3, [4, null]], x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)) substituted into f, initial, xs, cont of (f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x)))

equal(is_null([3, [4, null]]) ? (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(null) : $accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail([3, [4, null]]), x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x))), list(2, 3, 3, 4, 4, 5));
[afterMarker] (acc, init) => append((x => list(x, x + 1))(acc), init), null, [3, [4, null]], x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)) substituted into f, initial, xs, cont of (f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x)))

equal(is_null([3, [4, null]]) ? (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(null) : $accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail([3, [4, null]]), x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] is_null runs

equal(false ? (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(null) : $accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail([3, [4, null]]), x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x))), list(2, 3, 3, 4, 4, 5));
[afterMarker] is_null runs

equal(false ? (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(null) : $accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail([3, [4, null]]), x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal($accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail([3, [4, null]]), x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x))), list(2, 3, 3, 4, 4, 5));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal($accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail([3, [4, null]]), x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] tail runs

equal($accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, [4, null], x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x))), list(2, 3, 3, 4, 4, 5));
[afterMarker] tail runs

equal($accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, [4, null], x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] $accumulate runs

equal(((f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x))))((acc, init) => append((x => list(x, x + 1))(acc), init), null, [4, null], x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x))), list(2, 3, 3, 4, 4, 5));
[afterMarker] $accumulate runs

equal(((f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x))))((acc, init) => append((x => list(x, x + 1))(acc), init), null, [4, null], x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] (acc, init) => append((x => list(x, x + 1))(acc), init), null, [4, null], x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)) substituted into f, initial, xs, cont of (f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x)))

equal(is_null([4, null]) ? (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(null) : $accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail([4, null]), x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x))), list(2, 3, 3, 4, 4, 5));
[afterMarker] (acc, init) => append((x => list(x, x + 1))(acc), init), null, [4, null], x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)) substituted into f, initial, xs, cont of (f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x)))

equal(is_null([4, null]) ? (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(null) : $accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail([4, null]), x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] is_null runs

equal(false ? (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(null) : $accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail([4, null]), x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x))), list(2, 3, 3, 4, 4, 5));
[afterMarker] is_null runs

equal(false ? (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(null) : $accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail([4, null]), x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal($accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail([4, null]), x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x))), list(2, 3, 3, 4, 4, 5));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal($accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail([4, null]), x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] tail runs

equal($accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, null, x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x))), list(2, 3, 3, 4, 4, 5));
[afterMarker] tail runs

equal($accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, null, x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] $accumulate runs

equal(((f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x))))((acc, init) => append((x => list(x, x + 1))(acc), init), null, null, x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x))), list(2, 3, 3, 4, 4, 5));
[afterMarker] $accumulate runs

equal(((f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x))))((acc, init) => append((x => list(x, x + 1))(acc), init), null, null, x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] (acc, init) => append((x => list(x, x + 1))(acc), init), null, null, x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x)) substituted into f, initial, xs, cont of (f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x)))

equal(is_null(null) ? (x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x)))(null) : $accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail(null), x => (x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head(null), x))), list(2, 3, 3, 4, 4, 5));
[afterMarker] (acc, init) => append((x => list(x, x + 1))(acc), init), null, null, x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x)) substituted into f, initial, xs, cont of (f, initial, xs, cont) => is_null(xs) ? cont(initial) : $accumulate(f, initial, tail(xs), x => cont(f(head(xs), x)))

equal(is_null(null) ? (x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x)))(null) : $accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail(null), x => (x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head(null), x))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] is_null runs

equal(true ? (x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x)))(null) : $accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail(null), x => (x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head(null), x))), list(2, 3, 3, 4, 4, 5));
[afterMarker] is_null runs

equal(true ? (x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x)))(null) : $accumulate((acc, init) => append((x => list(x, x + 1))(acc), init), null, tail(null), x => (x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head(null), x))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

equal((x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x)))(null), list(2, 3, 3, 4, 4, 5));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

equal((x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x)))(null), list(2, 3, 3, 4, 4, 5));
[beforeMarker] null substituted into x of x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x))

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), null)), list(2, 3, 3, 4, 4, 5));
[afterMarker] null substituted into x of x => (x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), x))

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([4, null]), null)), list(2, 3, 3, 4, 4, 5));
[beforeMarker] head runs

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(4, null)), list(2, 3, 3, 4, 4, 5));
[afterMarker] head runs

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(4, null)), list(2, 3, 3, 4, 4, 5));
[beforeMarker] 4, null substituted into acc, init of (acc, init) => append((x => list(x, x + 1))(acc), init)

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(append((x => list(x, x + 1))(4), null)), list(2, 3, 3, 4, 4, 5));
[afterMarker] 4, null substituted into acc, init of (acc, init) => append((x => list(x, x + 1))(acc), init)

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(append((x => list(x, x + 1))(4), null)), list(2, 3, 3, 4, 4, 5));
[beforeMarker] 4 substituted into x of x => list(x, x + 1)

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(append(list(4, 4 + 1), null)), list(2, 3, 3, 4, 4, 5));
[afterMarker] 4 substituted into x of x => list(x, x + 1)

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(append(list(4, 4 + 1), null)), list(2, 3, 3, 4, 4, 5));
[beforeMarker] Binary expression 4 + 1 evaluated

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(append(list(4, 5), null)), list(2, 3, 3, 4, 4, 5));
[afterMarker] Binary expression 4 + 1 evaluated

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(append(list(4, 5), null)), list(2, 3, 3, 4, 4, 5));
[beforeMarker] list runs

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(append([4, [5, null]], null)), list(2, 3, 3, 4, 4, 5));
[afterMarker] list runs

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(append([4, [5, null]], null)), list(2, 3, 3, 4, 4, 5));
[beforeMarker] append runs

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))($append([4, [5, null]], null, xs => xs)), list(2, 3, 3, 4, 4, 5));
[afterMarker] append runs

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))($append([4, [5, null]], null, xs => xs)), list(2, 3, 3, 4, 4, 5));
[beforeMarker] $append runs

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([4, [5, null]], null, xs => xs)), list(2, 3, 3, 4, 4, 5));
[afterMarker] $append runs

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([4, [5, null]], null, xs => xs)), list(2, 3, 3, 4, 4, 5));
[beforeMarker] [4, [5, null]], null, xs => xs substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(is_null([4, [5, null]]) ? (xs => xs)(null) : $append(tail([4, [5, null]]), null, zs => (xs => xs)(pair(head([4, [5, null]]), zs)))), list(2, 3, 3, 4, 4, 5));
[afterMarker] [4, [5, null]], null, xs => xs substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(is_null([4, [5, null]]) ? (xs => xs)(null) : $append(tail([4, [5, null]]), null, zs => (xs => xs)(pair(head([4, [5, null]]), zs)))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] is_null runs

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(false ? (xs => xs)(null) : $append(tail([4, [5, null]]), null, zs => (xs => xs)(pair(head([4, [5, null]]), zs)))), list(2, 3, 3, 4, 4, 5));
[afterMarker] is_null runs

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(false ? (xs => xs)(null) : $append(tail([4, [5, null]]), null, zs => (xs => xs)(pair(head([4, [5, null]]), zs)))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))($append(tail([4, [5, null]]), null, zs => (xs => xs)(pair(head([4, [5, null]]), zs)))), list(2, 3, 3, 4, 4, 5));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))($append(tail([4, [5, null]]), null, zs => (xs => xs)(pair(head([4, [5, null]]), zs)))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] tail runs

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))($append([5, null], null, zs => (xs => xs)(pair(head([4, [5, null]]), zs)))), list(2, 3, 3, 4, 4, 5));
[afterMarker] tail runs

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))($append([5, null], null, zs => (xs => xs)(pair(head([4, [5, null]]), zs)))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] $append runs

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([5, null], null, zs => (xs => xs)(pair(head([4, [5, null]]), zs)))), list(2, 3, 3, 4, 4, 5));
[afterMarker] $append runs

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([5, null], null, zs => (xs => xs)(pair(head([4, [5, null]]), zs)))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] [5, null], null, zs => (xs => xs)(pair(head([4, [5, null]]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(is_null([5, null]) ? (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(null) : $append(tail([5, null]), null, zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs)))), list(2, 3, 3, 4, 4, 5));
[afterMarker] [5, null], null, zs => (xs => xs)(pair(head([4, [5, null]]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(is_null([5, null]) ? (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(null) : $append(tail([5, null]), null, zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs)))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] is_null runs

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(false ? (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(null) : $append(tail([5, null]), null, zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs)))), list(2, 3, 3, 4, 4, 5));
[afterMarker] is_null runs

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(false ? (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(null) : $append(tail([5, null]), null, zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs)))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))($append(tail([5, null]), null, zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs)))), list(2, 3, 3, 4, 4, 5));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))($append(tail([5, null]), null, zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs)))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] tail runs

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))($append(null, null, zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs)))), list(2, 3, 3, 4, 4, 5));
[afterMarker] tail runs

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))($append(null, null, zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs)))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] $append runs

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))(null, null, zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs)))), list(2, 3, 3, 4, 4, 5));
[afterMarker] $append runs

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))(null, null, zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs)))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] null, null, zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(is_null(null) ? (zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs)))(null) : $append(tail(null), null, zs => (zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs)))(pair(head(null), zs)))), list(2, 3, 3, 4, 4, 5));
[afterMarker] null, null, zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(is_null(null) ? (zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs)))(null) : $append(tail(null), null, zs => (zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs)))(pair(head(null), zs)))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] is_null runs

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(true ? (zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs)))(null) : $append(tail(null), null, zs => (zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs)))(pair(head(null), zs)))), list(2, 3, 3, 4, 4, 5));
[afterMarker] is_null runs

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))(true ? (zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs)))(null) : $append(tail(null), null, zs => (zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs)))(pair(head(null), zs)))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))((zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs)))(null)), list(2, 3, 3, 4, 4, 5));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))((zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs)))(null)), list(2, 3, 3, 4, 4, 5));
[beforeMarker] null substituted into zs of zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs))

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))((zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), null))), list(2, 3, 3, 4, 4, 5));
[afterMarker] null substituted into zs of zs => (zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), zs))

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))((zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(head([5, null]), null))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] head runs

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))((zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(5, null))), list(2, 3, 3, 4, 4, 5));
[afterMarker] head runs

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))((zs => (xs => xs)(pair(head([4, [5, null]]), zs)))(pair(5, null))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] pair runs

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))((zs => (xs => xs)(pair(head([4, [5, null]]), zs)))([5, null])), list(2, 3, 3, 4, 4, 5));
[afterMarker] pair runs

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))((zs => (xs => xs)(pair(head([4, [5, null]]), zs)))([5, null])), list(2, 3, 3, 4, 4, 5));
[beforeMarker] [5, null] substituted into zs of zs => (xs => xs)(pair(head([4, [5, null]]), zs))

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))((xs => xs)(pair(head([4, [5, null]]), [5, null]))), list(2, 3, 3, 4, 4, 5));
[afterMarker] [5, null] substituted into zs of zs => (xs => xs)(pair(head([4, [5, null]]), zs))

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))((xs => xs)(pair(head([4, [5, null]]), [5, null]))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] head runs

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))((xs => xs)(pair(4, [5, null]))), list(2, 3, 3, 4, 4, 5));
[afterMarker] head runs

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))((xs => xs)(pair(4, [5, null]))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] pair runs

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))((xs => xs)([4, [5, null]])), list(2, 3, 3, 4, 4, 5));
[afterMarker] pair runs

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))((xs => xs)([4, [5, null]])), list(2, 3, 3, 4, 4, 5));
[beforeMarker] [4, [5, null]] substituted into xs of xs => xs

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))([4, [5, null]]), list(2, 3, 3, 4, 4, 5));
[afterMarker] [4, [5, null]] substituted into xs of xs => xs

equal((x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x)))([4, [5, null]]), list(2, 3, 3, 4, 4, 5));
[beforeMarker] [4, [5, null]] substituted into x of x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x))

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), [4, [5, null]])), list(2, 3, 3, 4, 4, 5));
[afterMarker] [4, [5, null]] substituted into x of x => (x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), x))

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([3, [4, null]]), [4, [5, null]])), list(2, 3, 3, 4, 4, 5));
[beforeMarker] head runs

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(3, [4, [5, null]])), list(2, 3, 3, 4, 4, 5));
[afterMarker] head runs

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((acc, init) => append((x => list(x, x + 1))(acc), init))(3, [4, [5, null]])), list(2, 3, 3, 4, 4, 5));
[beforeMarker] 3, [4, [5, null]] substituted into acc, init of (acc, init) => append((x => list(x, x + 1))(acc), init)

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(append((x => list(x, x + 1))(3), [4, [5, null]])), list(2, 3, 3, 4, 4, 5));
[afterMarker] 3, [4, [5, null]] substituted into acc, init of (acc, init) => append((x => list(x, x + 1))(acc), init)

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(append((x => list(x, x + 1))(3), [4, [5, null]])), list(2, 3, 3, 4, 4, 5));
[beforeMarker] 3 substituted into x of x => list(x, x + 1)

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(append(list(3, 3 + 1), [4, [5, null]])), list(2, 3, 3, 4, 4, 5));
[afterMarker] 3 substituted into x of x => list(x, x + 1)

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(append(list(3, 3 + 1), [4, [5, null]])), list(2, 3, 3, 4, 4, 5));
[beforeMarker] Binary expression 3 + 1 evaluated

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(append(list(3, 4), [4, [5, null]])), list(2, 3, 3, 4, 4, 5));
[afterMarker] Binary expression 3 + 1 evaluated

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(append(list(3, 4), [4, [5, null]])), list(2, 3, 3, 4, 4, 5));
[beforeMarker] list runs

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(append([3, [4, null]], [4, [5, null]])), list(2, 3, 3, 4, 4, 5));
[afterMarker] list runs

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(append([3, [4, null]], [4, [5, null]])), list(2, 3, 3, 4, 4, 5));
[beforeMarker] append runs

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))($append([3, [4, null]], [4, [5, null]], xs => xs)), list(2, 3, 3, 4, 4, 5));
[afterMarker] append runs

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))($append([3, [4, null]], [4, [5, null]], xs => xs)), list(2, 3, 3, 4, 4, 5));
[beforeMarker] $append runs

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([3, [4, null]], [4, [5, null]], xs => xs)), list(2, 3, 3, 4, 4, 5));
[afterMarker] $append runs

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([3, [4, null]], [4, [5, null]], xs => xs)), list(2, 3, 3, 4, 4, 5));
[beforeMarker] [3, [4, null]], [4, [5, null]], xs => xs substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(is_null([3, [4, null]]) ? (xs => xs)([4, [5, null]]) : $append(tail([3, [4, null]]), [4, [5, null]], zs => (xs => xs)(pair(head([3, [4, null]]), zs)))), list(2, 3, 3, 4, 4, 5));
[afterMarker] [3, [4, null]], [4, [5, null]], xs => xs substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(is_null([3, [4, null]]) ? (xs => xs)([4, [5, null]]) : $append(tail([3, [4, null]]), [4, [5, null]], zs => (xs => xs)(pair(head([3, [4, null]]), zs)))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] is_null runs

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(false ? (xs => xs)([4, [5, null]]) : $append(tail([3, [4, null]]), [4, [5, null]], zs => (xs => xs)(pair(head([3, [4, null]]), zs)))), list(2, 3, 3, 4, 4, 5));
[afterMarker] is_null runs

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(false ? (xs => xs)([4, [5, null]]) : $append(tail([3, [4, null]]), [4, [5, null]], zs => (xs => xs)(pair(head([3, [4, null]]), zs)))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))($append(tail([3, [4, null]]), [4, [5, null]], zs => (xs => xs)(pair(head([3, [4, null]]), zs)))), list(2, 3, 3, 4, 4, 5));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))($append(tail([3, [4, null]]), [4, [5, null]], zs => (xs => xs)(pair(head([3, [4, null]]), zs)))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] tail runs

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))($append([4, null], [4, [5, null]], zs => (xs => xs)(pair(head([3, [4, null]]), zs)))), list(2, 3, 3, 4, 4, 5));
[afterMarker] tail runs

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))($append([4, null], [4, [5, null]], zs => (xs => xs)(pair(head([3, [4, null]]), zs)))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] $append runs

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([4, null], [4, [5, null]], zs => (xs => xs)(pair(head([3, [4, null]]), zs)))), list(2, 3, 3, 4, 4, 5));
[afterMarker] $append runs

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([4, null], [4, [5, null]], zs => (xs => xs)(pair(head([3, [4, null]]), zs)))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] [4, null], [4, [5, null]], zs => (xs => xs)(pair(head([3, [4, null]]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(is_null([4, null]) ? (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))([4, [5, null]]) : $append(tail([4, null]), [4, [5, null]], zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs)))), list(2, 3, 3, 4, 4, 5));
[afterMarker] [4, null], [4, [5, null]], zs => (xs => xs)(pair(head([3, [4, null]]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(is_null([4, null]) ? (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))([4, [5, null]]) : $append(tail([4, null]), [4, [5, null]], zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs)))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] is_null runs

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(false ? (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))([4, [5, null]]) : $append(tail([4, null]), [4, [5, null]], zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs)))), list(2, 3, 3, 4, 4, 5));
[afterMarker] is_null runs

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(false ? (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))([4, [5, null]]) : $append(tail([4, null]), [4, [5, null]], zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs)))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))($append(tail([4, null]), [4, [5, null]], zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs)))), list(2, 3, 3, 4, 4, 5));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))($append(tail([4, null]), [4, [5, null]], zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs)))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] tail runs

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))($append(null, [4, [5, null]], zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs)))), list(2, 3, 3, 4, 4, 5));
[afterMarker] tail runs

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))($append(null, [4, [5, null]], zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs)))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] $append runs

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))(null, [4, [5, null]], zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs)))), list(2, 3, 3, 4, 4, 5));
[afterMarker] $append runs

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))(null, [4, [5, null]], zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs)))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] null, [4, [5, null]], zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(is_null(null) ? (zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs)))([4, [5, null]]) : $append(tail(null), [4, [5, null]], zs => (zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs)))(pair(head(null), zs)))), list(2, 3, 3, 4, 4, 5));
[afterMarker] null, [4, [5, null]], zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(is_null(null) ? (zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs)))([4, [5, null]]) : $append(tail(null), [4, [5, null]], zs => (zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs)))(pair(head(null), zs)))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] is_null runs

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(true ? (zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs)))([4, [5, null]]) : $append(tail(null), [4, [5, null]], zs => (zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs)))(pair(head(null), zs)))), list(2, 3, 3, 4, 4, 5));
[afterMarker] is_null runs

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))(true ? (zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs)))([4, [5, null]]) : $append(tail(null), [4, [5, null]], zs => (zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs)))(pair(head(null), zs)))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))((zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs)))([4, [5, null]])), list(2, 3, 3, 4, 4, 5));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))((zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs)))([4, [5, null]])), list(2, 3, 3, 4, 4, 5));
[beforeMarker] [4, [5, null]] substituted into zs of zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs))

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))((zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), [4, [5, null]]))), list(2, 3, 3, 4, 4, 5));
[afterMarker] [4, [5, null]] substituted into zs of zs => (zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), zs))

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))((zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(head([4, null]), [4, [5, null]]))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] head runs

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))((zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(4, [4, [5, null]]))), list(2, 3, 3, 4, 4, 5));
[afterMarker] head runs

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))((zs => (xs => xs)(pair(head([3, [4, null]]), zs)))(pair(4, [4, [5, null]]))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] pair runs

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))((zs => (xs => xs)(pair(head([3, [4, null]]), zs)))([4, [4, [5, null]]])), list(2, 3, 3, 4, 4, 5));
[afterMarker] pair runs

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))((zs => (xs => xs)(pair(head([3, [4, null]]), zs)))([4, [4, [5, null]]])), list(2, 3, 3, 4, 4, 5));
[beforeMarker] [4, [4, [5, null]]] substituted into zs of zs => (xs => xs)(pair(head([3, [4, null]]), zs))

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))((xs => xs)(pair(head([3, [4, null]]), [4, [4, [5, null]]]))), list(2, 3, 3, 4, 4, 5));
[afterMarker] [4, [4, [5, null]]] substituted into zs of zs => (xs => xs)(pair(head([3, [4, null]]), zs))

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))((xs => xs)(pair(head([3, [4, null]]), [4, [4, [5, null]]]))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] head runs

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))((xs => xs)(pair(3, [4, [4, [5, null]]]))), list(2, 3, 3, 4, 4, 5));
[afterMarker] head runs

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))((xs => xs)(pair(3, [4, [4, [5, null]]]))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] pair runs

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))((xs => xs)([3, [4, [4, [5, null]]]])), list(2, 3, 3, 4, 4, 5));
[afterMarker] pair runs

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))((xs => xs)([3, [4, [4, [5, null]]]])), list(2, 3, 3, 4, 4, 5));
[beforeMarker] [3, [4, [4, [5, null]]]] substituted into xs of xs => xs

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))([3, [4, [4, [5, null]]]]), list(2, 3, 3, 4, 4, 5));
[afterMarker] [3, [4, [4, [5, null]]]] substituted into xs of xs => xs

equal((x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x)))([3, [4, [4, [5, null]]]]), list(2, 3, 3, 4, 4, 5));
[beforeMarker] [3, [4, [4, [5, null]]]] substituted into x of x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x))

equal((x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), [3, [4, [4, [5, null]]]])), list(2, 3, 3, 4, 4, 5));
[afterMarker] [3, [4, [4, [5, null]]]] substituted into x of x => (x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), x))

equal((x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(head([2, [3, [4, null]]]), [3, [4, [4, [5, null]]]])), list(2, 3, 3, 4, 4, 5));
[beforeMarker] head runs

equal((x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(2, [3, [4, [4, [5, null]]]])), list(2, 3, 3, 4, 4, 5));
[afterMarker] head runs

equal((x => x)(((acc, init) => append((x => list(x, x + 1))(acc), init))(2, [3, [4, [4, [5, null]]]])), list(2, 3, 3, 4, 4, 5));
[beforeMarker] 2, [3, [4, [4, [5, null]]]] substituted into acc, init of (acc, init) => append((x => list(x, x + 1))(acc), init)

equal((x => x)(append((x => list(x, x + 1))(2), [3, [4, [4, [5, null]]]])), list(2, 3, 3, 4, 4, 5));
[afterMarker] 2, [3, [4, [4, [5, null]]]] substituted into acc, init of (acc, init) => append((x => list(x, x + 1))(acc), init)

equal((x => x)(append((x => list(x, x + 1))(2), [3, [4, [4, [5, null]]]])), list(2, 3, 3, 4, 4, 5));
[beforeMarker] 2 substituted into x of x => list(x, x + 1)

equal((x => x)(append(list(2, 2 + 1), [3, [4, [4, [5, null]]]])), list(2, 3, 3, 4, 4, 5));
[afterMarker] 2 substituted into x of x => list(x, x + 1)

equal((x => x)(append(list(2, 2 + 1), [3, [4, [4, [5, null]]]])), list(2, 3, 3, 4, 4, 5));
[beforeMarker] Binary expression 2 + 1 evaluated

equal((x => x)(append(list(2, 3), [3, [4, [4, [5, null]]]])), list(2, 3, 3, 4, 4, 5));
[afterMarker] Binary expression 2 + 1 evaluated

equal((x => x)(append(list(2, 3), [3, [4, [4, [5, null]]]])), list(2, 3, 3, 4, 4, 5));
[beforeMarker] list runs

equal((x => x)(append([2, [3, null]], [3, [4, [4, [5, null]]]])), list(2, 3, 3, 4, 4, 5));
[afterMarker] list runs

equal((x => x)(append([2, [3, null]], [3, [4, [4, [5, null]]]])), list(2, 3, 3, 4, 4, 5));
[beforeMarker] append runs

equal((x => x)($append([2, [3, null]], [3, [4, [4, [5, null]]]], xs => xs)), list(2, 3, 3, 4, 4, 5));
[afterMarker] append runs

equal((x => x)($append([2, [3, null]], [3, [4, [4, [5, null]]]], xs => xs)), list(2, 3, 3, 4, 4, 5));
[beforeMarker] $append runs

equal((x => x)(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([2, [3, null]], [3, [4, [4, [5, null]]]], xs => xs)), list(2, 3, 3, 4, 4, 5));
[afterMarker] $append runs

equal((x => x)(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([2, [3, null]], [3, [4, [4, [5, null]]]], xs => xs)), list(2, 3, 3, 4, 4, 5));
[beforeMarker] [2, [3, null]], [3, [4, [4, [5, null]]]], xs => xs substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

equal((x => x)(is_null([2, [3, null]]) ? (xs => xs)([3, [4, [4, [5, null]]]]) : $append(tail([2, [3, null]]), [3, [4, [4, [5, null]]]], zs => (xs => xs)(pair(head([2, [3, null]]), zs)))), list(2, 3, 3, 4, 4, 5));
[afterMarker] [2, [3, null]], [3, [4, [4, [5, null]]]], xs => xs substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

equal((x => x)(is_null([2, [3, null]]) ? (xs => xs)([3, [4, [4, [5, null]]]]) : $append(tail([2, [3, null]]), [3, [4, [4, [5, null]]]], zs => (xs => xs)(pair(head([2, [3, null]]), zs)))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] is_null runs

equal((x => x)(false ? (xs => xs)([3, [4, [4, [5, null]]]]) : $append(tail([2, [3, null]]), [3, [4, [4, [5, null]]]], zs => (xs => xs)(pair(head([2, [3, null]]), zs)))), list(2, 3, 3, 4, 4, 5));
[afterMarker] is_null runs

equal((x => x)(false ? (xs => xs)([3, [4, [4, [5, null]]]]) : $append(tail([2, [3, null]]), [3, [4, [4, [5, null]]]], zs => (xs => xs)(pair(head([2, [3, null]]), zs)))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal((x => x)($append(tail([2, [3, null]]), [3, [4, [4, [5, null]]]], zs => (xs => xs)(pair(head([2, [3, null]]), zs)))), list(2, 3, 3, 4, 4, 5));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal((x => x)($append(tail([2, [3, null]]), [3, [4, [4, [5, null]]]], zs => (xs => xs)(pair(head([2, [3, null]]), zs)))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] tail runs

equal((x => x)($append([3, null], [3, [4, [4, [5, null]]]], zs => (xs => xs)(pair(head([2, [3, null]]), zs)))), list(2, 3, 3, 4, 4, 5));
[afterMarker] tail runs

equal((x => x)($append([3, null], [3, [4, [4, [5, null]]]], zs => (xs => xs)(pair(head([2, [3, null]]), zs)))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] $append runs

equal((x => x)(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([3, null], [3, [4, [4, [5, null]]]], zs => (xs => xs)(pair(head([2, [3, null]]), zs)))), list(2, 3, 3, 4, 4, 5));
[afterMarker] $append runs

equal((x => x)(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([3, null], [3, [4, [4, [5, null]]]], zs => (xs => xs)(pair(head([2, [3, null]]), zs)))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] [3, null], [3, [4, [4, [5, null]]]], zs => (xs => xs)(pair(head([2, [3, null]]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

equal((x => x)(is_null([3, null]) ? (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))([3, [4, [4, [5, null]]]]) : $append(tail([3, null]), [3, [4, [4, [5, null]]]], zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs)))), list(2, 3, 3, 4, 4, 5));
[afterMarker] [3, null], [3, [4, [4, [5, null]]]], zs => (xs => xs)(pair(head([2, [3, null]]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

equal((x => x)(is_null([3, null]) ? (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))([3, [4, [4, [5, null]]]]) : $append(tail([3, null]), [3, [4, [4, [5, null]]]], zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs)))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] is_null runs

equal((x => x)(false ? (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))([3, [4, [4, [5, null]]]]) : $append(tail([3, null]), [3, [4, [4, [5, null]]]], zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs)))), list(2, 3, 3, 4, 4, 5));
[afterMarker] is_null runs

equal((x => x)(false ? (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))([3, [4, [4, [5, null]]]]) : $append(tail([3, null]), [3, [4, [4, [5, null]]]], zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs)))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal((x => x)($append(tail([3, null]), [3, [4, [4, [5, null]]]], zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs)))), list(2, 3, 3, 4, 4, 5));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal((x => x)($append(tail([3, null]), [3, [4, [4, [5, null]]]], zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs)))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] tail runs

equal((x => x)($append(null, [3, [4, [4, [5, null]]]], zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs)))), list(2, 3, 3, 4, 4, 5));
[afterMarker] tail runs

equal((x => x)($append(null, [3, [4, [4, [5, null]]]], zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs)))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] $append runs

equal((x => x)(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))(null, [3, [4, [4, [5, null]]]], zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs)))), list(2, 3, 3, 4, 4, 5));
[afterMarker] $append runs

equal((x => x)(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))(null, [3, [4, [4, [5, null]]]], zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs)))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] null, [3, [4, [4, [5, null]]]], zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

equal((x => x)(is_null(null) ? (zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs)))([3, [4, [4, [5, null]]]]) : $append(tail(null), [3, [4, [4, [5, null]]]], zs => (zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs)))(pair(head(null), zs)))), list(2, 3, 3, 4, 4, 5));
[afterMarker] null, [3, [4, [4, [5, null]]]], zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

equal((x => x)(is_null(null) ? (zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs)))([3, [4, [4, [5, null]]]]) : $append(tail(null), [3, [4, [4, [5, null]]]], zs => (zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs)))(pair(head(null), zs)))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] is_null runs

equal((x => x)(true ? (zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs)))([3, [4, [4, [5, null]]]]) : $append(tail(null), [3, [4, [4, [5, null]]]], zs => (zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs)))(pair(head(null), zs)))), list(2, 3, 3, 4, 4, 5));
[afterMarker] is_null runs

equal((x => x)(true ? (zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs)))([3, [4, [4, [5, null]]]]) : $append(tail(null), [3, [4, [4, [5, null]]]], zs => (zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs)))(pair(head(null), zs)))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

equal((x => x)((zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs)))([3, [4, [4, [5, null]]]])), list(2, 3, 3, 4, 4, 5));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

equal((x => x)((zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs)))([3, [4, [4, [5, null]]]])), list(2, 3, 3, 4, 4, 5));
[beforeMarker] [3, [4, [4, [5, null]]]] substituted into zs of zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs))

equal((x => x)((zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), [3, [4, [4, [5, null]]]]))), list(2, 3, 3, 4, 4, 5));
[afterMarker] [3, [4, [4, [5, null]]]] substituted into zs of zs => (zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), zs))

equal((x => x)((zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(head([3, null]), [3, [4, [4, [5, null]]]]))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] head runs

equal((x => x)((zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(3, [3, [4, [4, [5, null]]]]))), list(2, 3, 3, 4, 4, 5));
[afterMarker] head runs

equal((x => x)((zs => (xs => xs)(pair(head([2, [3, null]]), zs)))(pair(3, [3, [4, [4, [5, null]]]]))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] pair runs

equal((x => x)((zs => (xs => xs)(pair(head([2, [3, null]]), zs)))([3, [3, [4, [4, [5, null]]]]])), list(2, 3, 3, 4, 4, 5));
[afterMarker] pair runs

equal((x => x)((zs => (xs => xs)(pair(head([2, [3, null]]), zs)))([3, [3, [4, [4, [5, null]]]]])), list(2, 3, 3, 4, 4, 5));
[beforeMarker] [3, [3, [4, [4, [5, null]]]]] substituted into zs of zs => (xs => xs)(pair(head([2, [3, null]]), zs))

equal((x => x)((xs => xs)(pair(head([2, [3, null]]), [3, [3, [4, [4, [5, null]]]]]))), list(2, 3, 3, 4, 4, 5));
[afterMarker] [3, [3, [4, [4, [5, null]]]]] substituted into zs of zs => (xs => xs)(pair(head([2, [3, null]]), zs))

equal((x => x)((xs => xs)(pair(head([2, [3, null]]), [3, [3, [4, [4, [5, null]]]]]))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] head runs

equal((x => x)((xs => xs)(pair(2, [3, [3, [4, [4, [5, null]]]]]))), list(2, 3, 3, 4, 4, 5));
[afterMarker] head runs

equal((x => x)((xs => xs)(pair(2, [3, [3, [4, [4, [5, null]]]]]))), list(2, 3, 3, 4, 4, 5));
[beforeMarker] pair runs

equal((x => x)((xs => xs)([2, [3, [3, [4, [4, [5, null]]]]]])), list(2, 3, 3, 4, 4, 5));
[afterMarker] pair runs

equal((x => x)((xs => xs)([2, [3, [3, [4, [4, [5, null]]]]]])), list(2, 3, 3, 4, 4, 5));
[beforeMarker] [2, [3, [3, [4, [4, [5, null]]]]]] substituted into xs of xs => xs

equal((x => x)([2, [3, [3, [4, [4, [5, null]]]]]]), list(2, 3, 3, 4, 4, 5));
[afterMarker] [2, [3, [3, [4, [4, [5, null]]]]]] substituted into xs of xs => xs

equal((x => x)([2, [3, [3, [4, [4, [5, null]]]]]]), list(2, 3, 3, 4, 4, 5));
[beforeMarker] [2, [3, [3, [4, [4, [5, null]]]]]] substituted into x of x => x

equal([2, [3, [3, [4, [4, [5, null]]]]]], list(2, 3, 3, 4, 4, 5));
[afterMarker] [2, [3, [3, [4, [4, [5, null]]]]]] substituted into x of x => x

equal([2, [3, [3, [4, [4, [5, null]]]]]], list(2, 3, 3, 4, 4, 5));
[beforeMarker] list runs

equal([2, [3, [3, [4, [4, [5, null]]]]]], [2, [3, [3, [4, [4, [5, null]]]]]]);
[afterMarker] list runs

equal([2, [3, [3, [4, [4, [5, null]]]]]], [2, [3, [3, [4, [4, [5, null]]]]]]);
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)([2, [3, [3, [4, [4, [5, null]]]]]], [2, [3, [3, [4, [4, [5, null]]]]]]);
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)([2, [3, [3, [4, [4, [5, null]]]]]], [2, [3, [3, [4, [4, [5, null]]]]]]);
[beforeMarker] [2, [3, [3, [4, [4, [5, null]]]]]], [2, [3, [3, [4, [4, [5, null]]]]]] substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

is_pair([2, [3, [3, [4, [4, [5, null]]]]]]) ? is_pair([2, [3, [3, [4, [4, [5, null]]]]]]) && equal(head([2, [3, [3, [4, [4, [5, null]]]]]]), head([2, [3, [3, [4, [4, [5, null]]]]]])) && equal(tail([2, [3, [3, [4, [4, [5, null]]]]]]), tail([2, [3, [3, [4, [4, [5, null]]]]]])) : is_null([2, [3, [3, [4, [4, [5, null]]]]]]) ? is_null([2, [3, [3, [4, [4, [5, null]]]]]]) : is_number([2, [3, [3, [4, [4, [5, null]]]]]]) ? is_number([2, [3, [3, [4, [4, [5, null]]]]]]) && [2, [3, [3, [4, [4, [5, null]]]]]] === [2, [3, [3, [4, [4, [5, null]]]]]] : is_boolean([2, [3, [3, [4, [4, [5, null]]]]]]) ? is_boolean([2, [3, [3, [4, [4, [5, null]]]]]]) && ([2, [3, [3, [4, [4, [5, null]]]]]] && [2, [3, [3, [4, [4, [5, null]]]]]] || ![2, [3, [3, [4, [4, [5, null]]]]]] && ![2, [3, [3, [4, [4, [5, null]]]]]]) : is_string([2, [3, [3, [4, [4, [5, null]]]]]]) ? is_string([2, [3, [3, [4, [4, [5, null]]]]]]) && [2, [3, [3, [4, [4, [5, null]]]]]] === [2, [3, [3, [4, [4, [5, null]]]]]] : is_undefined([2, [3, [3, [4, [4, [5, null]]]]]]) ? is_undefined([2, [3, [3, [4, [4, [5, null]]]]]]) : is_function([2, [3, [3, [4, [4, [5, null]]]]]]) ? is_function([2, [3, [3, [4, [4, [5, null]]]]]]) && [2, [3, [3, [4, [4, [5, null]]]]]] === [2, [3, [3, [4, [4, [5, null]]]]]] : fals;
[afterMarker] [2, [3, [3, [4, [4, [5, null]]]]]], [2, [3, [3, [4, [4, [5, null]]]]]] substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

is_pair([2, [3, [3, [4, [4, [5, null]]]]]]) ? is_pair([2, [3, [3, [4, [4, [5, null]]]]]]) && equal(head([2, [3, [3, [4, [4, [5, null]]]]]]), head([2, [3, [3, [4, [4, [5, null]]]]]])) && equal(tail([2, [3, [3, [4, [4, [5, null]]]]]]), tail([2, [3, [3, [4, [4, [5, null]]]]]])) : is_null([2, [3, [3, [4, [4, [5, null]]]]]]) ? is_null([2, [3, [3, [4, [4, [5, null]]]]]]) : is_number([2, [3, [3, [4, [4, [5, null]]]]]]) ? is_number([2, [3, [3, [4, [4, [5, null]]]]]]) && [2, [3, [3, [4, [4, [5, null]]]]]] === [2, [3, [3, [4, [4, [5, null]]]]]] : is_boolean([2, [3, [3, [4, [4, [5, null]]]]]]) ? is_boolean([2, [3, [3, [4, [4, [5, null]]]]]]) && ([2, [3, [3, [4, [4, [5, null]]]]]] && [2, [3, [3, [4, [4, [5, null]]]]]] || ![2, [3, [3, [4, [4, [5, null]]]]]] && ![2, [3, [3, [4, [4, [5, null]]]]]]) : is_string([2, [3, [3, [4, [4, [5, null]]]]]]) ? is_string([2, [3, [3, [4, [4, [5, null]]]]]]) && [2, [3, [3, [4, [4, [5, null]]]]]] === [2, [3, [3, [4, [4, [5, null]]]]]] : is_undefined([2, [3, [3, [4, [4, [5, null]]]]]]) ? is_undefined([2, [3, [3, [4, [4, [5, null]]]]]]) : is_function([2, [3, [3, [4, [4, [5, null]]]]]]) ? is_function([2, [3, [3, [4, [4, [5, null]]]]]]) && [2, [3, [3, [4, [4, [5, null]]]]]] === [2, [3, [3, [4, [4, [5, null]]]]]] : fals;
[beforeMarker] is_pair runs

true ? is_pair([2, [3, [3, [4, [4, [5, null]]]]]]) && equal(head([2, [3, [3, [4, [4, [5, null]]]]]]), head([2, [3, [3, [4, [4, [5, null]]]]]])) && equal(tail([2, [3, [3, [4, [4, [5, null]]]]]]), tail([2, [3, [3, [4, [4, [5, null]]]]]])) : is_null([2, [3, [3, [4, [4, [5, null]]]]]]) ? is_null([2, [3, [3, [4, [4, [5, null]]]]]]) : is_number([2, [3, [3, [4, [4, [5, null]]]]]]) ? is_number([2, [3, [3, [4, [4, [5, null]]]]]]) && [2, [3, [3, [4, [4, [5, null]]]]]] === [2, [3, [3, [4, [4, [5, null]]]]]] : is_boolean([2, [3, [3, [4, [4, [5, null]]]]]]) ? is_boolean([2, [3, [3, [4, [4, [5, null]]]]]]) && ([2, [3, [3, [4, [4, [5, null]]]]]] && [2, [3, [3, [4, [4, [5, null]]]]]] || ![2, [3, [3, [4, [4, [5, null]]]]]] && ![2, [3, [3, [4, [4, [5, null]]]]]]) : is_string([2, [3, [3, [4, [4, [5, null]]]]]]) ? is_string([2, [3, [3, [4, [4, [5, null]]]]]]) && [2, [3, [3, [4, [4, [5, null]]]]]] === [2, [3, [3, [4, [4, [5, null]]]]]] : is_undefined([2, [3, [3, [4, [4, [5, null]]]]]]) ? is_undefined([2, [3, [3, [4, [4, [5, null]]]]]]) : is_function([2, [3, [3, [4, [4, [5, null]]]]]]) ? is_function([2, [3, [3, [4, [4, [5, null]]]]]]) && [2, [3, [3, [4, [4, [5, null]]]]]] === [2, [3, [3, [4, [4, [5, null]]]]]] : fals;
[afterMarker] is_pair runs

true ? is_pair([2, [3, [3, [4, [4, [5, null]]]]]]) && equal(head([2, [3, [3, [4, [4, [5, null]]]]]]), head([2, [3, [3, [4, [4, [5, null]]]]]])) && equal(tail([2, [3, [3, [4, [4, [5, null]]]]]]), tail([2, [3, [3, [4, [4, [5, null]]]]]])) : is_null([2, [3, [3, [4, [4, [5, null]]]]]]) ? is_null([2, [3, [3, [4, [4, [5, null]]]]]]) : is_number([2, [3, [3, [4, [4, [5, null]]]]]]) ? is_number([2, [3, [3, [4, [4, [5, null]]]]]]) && [2, [3, [3, [4, [4, [5, null]]]]]] === [2, [3, [3, [4, [4, [5, null]]]]]] : is_boolean([2, [3, [3, [4, [4, [5, null]]]]]]) ? is_boolean([2, [3, [3, [4, [4, [5, null]]]]]]) && ([2, [3, [3, [4, [4, [5, null]]]]]] && [2, [3, [3, [4, [4, [5, null]]]]]] || ![2, [3, [3, [4, [4, [5, null]]]]]] && ![2, [3, [3, [4, [4, [5, null]]]]]]) : is_string([2, [3, [3, [4, [4, [5, null]]]]]]) ? is_string([2, [3, [3, [4, [4, [5, null]]]]]]) && [2, [3, [3, [4, [4, [5, null]]]]]] === [2, [3, [3, [4, [4, [5, null]]]]]] : is_undefined([2, [3, [3, [4, [4, [5, null]]]]]]) ? is_undefined([2, [3, [3, [4, [4, [5, null]]]]]]) : is_function([2, [3, [3, [4, [4, [5, null]]]]]]) ? is_function([2, [3, [3, [4, [4, [5, null]]]]]]) && [2, [3, [3, [4, [4, [5, null]]]]]] === [2, [3, [3, [4, [4, [5, null]]]]]] : fals;
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_pair([2, [3, [3, [4, [4, [5, null]]]]]]) && equal(head([2, [3, [3, [4, [4, [5, null]]]]]]), head([2, [3, [3, [4, [4, [5, null]]]]]])) && equal(tail([2, [3, [3, [4, [4, [5, null]]]]]]), tail([2, [3, [3, [4, [4, [5, null]]]]]]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_pair([2, [3, [3, [4, [4, [5, null]]]]]]) && equal(head([2, [3, [3, [4, [4, [5, null]]]]]]), head([2, [3, [3, [4, [4, [5, null]]]]]])) && equal(tail([2, [3, [3, [4, [4, [5, null]]]]]]), tail([2, [3, [3, [4, [4, [5, null]]]]]]));
[beforeMarker] is_pair runs

true && equal(head([2, [3, [3, [4, [4, [5, null]]]]]]), head([2, [3, [3, [4, [4, [5, null]]]]]])) && equal(tail([2, [3, [3, [4, [4, [5, null]]]]]]), tail([2, [3, [3, [4, [4, [5, null]]]]]]));
[afterMarker] is_pair runs

true && equal(head([2, [3, [3, [4, [4, [5, null]]]]]]), head([2, [3, [3, [4, [4, [5, null]]]]]])) && equal(tail([2, [3, [3, [4, [4, [5, null]]]]]]), tail([2, [3, [3, [4, [4, [5, null]]]]]]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(head([2, [3, [3, [4, [4, [5, null]]]]]]), head([2, [3, [3, [4, [4, [5, null]]]]]])) && equal(tail([2, [3, [3, [4, [4, [5, null]]]]]]), tail([2, [3, [3, [4, [4, [5, null]]]]]]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(head([2, [3, [3, [4, [4, [5, null]]]]]]), head([2, [3, [3, [4, [4, [5, null]]]]]])) && equal(tail([2, [3, [3, [4, [4, [5, null]]]]]]), tail([2, [3, [3, [4, [4, [5, null]]]]]]));
[beforeMarker] head runs

equal(2, head([2, [3, [3, [4, [4, [5, null]]]]]])) && equal(tail([2, [3, [3, [4, [4, [5, null]]]]]]), tail([2, [3, [3, [4, [4, [5, null]]]]]]));
[afterMarker] head runs

equal(2, head([2, [3, [3, [4, [4, [5, null]]]]]])) && equal(tail([2, [3, [3, [4, [4, [5, null]]]]]]), tail([2, [3, [3, [4, [4, [5, null]]]]]]));
[beforeMarker] head runs

equal(2, 2) && equal(tail([2, [3, [3, [4, [4, [5, null]]]]]]), tail([2, [3, [3, [4, [4, [5, null]]]]]]));
[afterMarker] head runs

equal(2, 2) && equal(tail([2, [3, [3, [4, [4, [5, null]]]]]]), tail([2, [3, [3, [4, [4, [5, null]]]]]]));
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(2, 2) && equal(tail([2, [3, [3, [4, [4, [5, null]]]]]]), tail([2, [3, [3, [4, [4, [5, null]]]]]]));
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(2, 2) && equal(tail([2, [3, [3, [4, [4, [5, null]]]]]]), tail([2, [3, [3, [4, [4, [5, null]]]]]]));
[beforeMarker] 2, 2 substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair(2) ? is_pair(2) && equal(head(2), head(2)) && equal(tail(2), tail(2)) : is_null(2) ? is_null(2) : is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, [3, [3, [4, [4, [5, null]]]]]]), tail([2, [3, [3, [4, [4, [5, null]]]]]]));
[afterMarker] 2, 2 substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair(2) ? is_pair(2) && equal(head(2), head(2)) && equal(tail(2), tail(2)) : is_null(2) ? is_null(2) : is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, [3, [3, [4, [4, [5, null]]]]]]), tail([2, [3, [3, [4, [4, [5, null]]]]]]));
[beforeMarker] is_pair runs

(false ? is_pair(2) && equal(head(2), head(2)) && equal(tail(2), tail(2)) : is_null(2) ? is_null(2) : is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, [3, [3, [4, [4, [5, null]]]]]]), tail([2, [3, [3, [4, [4, [5, null]]]]]]));
[afterMarker] is_pair runs

(false ? is_pair(2) && equal(head(2), head(2)) && equal(tail(2), tail(2)) : is_null(2) ? is_null(2) : is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, [3, [3, [4, [4, [5, null]]]]]]), tail([2, [3, [3, [4, [4, [5, null]]]]]]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_null(2) ? is_null(2) : is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, [3, [3, [4, [4, [5, null]]]]]]), tail([2, [3, [3, [4, [4, [5, null]]]]]]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_null(2) ? is_null(2) : is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, [3, [3, [4, [4, [5, null]]]]]]), tail([2, [3, [3, [4, [4, [5, null]]]]]]));
[beforeMarker] is_null runs

(false ? is_null(2) : is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, [3, [3, [4, [4, [5, null]]]]]]), tail([2, [3, [3, [4, [4, [5, null]]]]]]));
[afterMarker] is_null runs

(false ? is_null(2) : is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, [3, [3, [4, [4, [5, null]]]]]]), tail([2, [3, [3, [4, [4, [5, null]]]]]]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, [3, [3, [4, [4, [5, null]]]]]]), tail([2, [3, [3, [4, [4, [5, null]]]]]]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, [3, [3, [4, [4, [5, null]]]]]]), tail([2, [3, [3, [4, [4, [5, null]]]]]]));
[beforeMarker] is_number runs

(true ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, [3, [3, [4, [4, [5, null]]]]]]), tail([2, [3, [3, [4, [4, [5, null]]]]]]));
[afterMarker] is_number runs

(true ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, [3, [3, [4, [4, [5, null]]]]]]), tail([2, [3, [3, [4, [4, [5, null]]]]]]));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_number(2) && 2 === 2 && equal(tail([2, [3, [3, [4, [4, [5, null]]]]]]), tail([2, [3, [3, [4, [4, [5, null]]]]]]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_number(2) && 2 === 2 && equal(tail([2, [3, [3, [4, [4, [5, null]]]]]]), tail([2, [3, [3, [4, [4, [5, null]]]]]]));
[beforeMarker] is_number runs

true && 2 === 2 && equal(tail([2, [3, [3, [4, [4, [5, null]]]]]]), tail([2, [3, [3, [4, [4, [5, null]]]]]]));
[afterMarker] is_number runs

true && 2 === 2 && equal(tail([2, [3, [3, [4, [4, [5, null]]]]]]), tail([2, [3, [3, [4, [4, [5, null]]]]]]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

2 === 2 && equal(tail([2, [3, [3, [4, [4, [5, null]]]]]]), tail([2, [3, [3, [4, [4, [5, null]]]]]]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

2 === 2 && equal(tail([2, [3, [3, [4, [4, [5, null]]]]]]), tail([2, [3, [3, [4, [4, [5, null]]]]]]));
[beforeMarker] Binary expression 2 === 2 evaluated

true && equal(tail([2, [3, [3, [4, [4, [5, null]]]]]]), tail([2, [3, [3, [4, [4, [5, null]]]]]]));
[afterMarker] Binary expression 2 === 2 evaluated

true && equal(tail([2, [3, [3, [4, [4, [5, null]]]]]]), tail([2, [3, [3, [4, [4, [5, null]]]]]]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(tail([2, [3, [3, [4, [4, [5, null]]]]]]), tail([2, [3, [3, [4, [4, [5, null]]]]]]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(tail([2, [3, [3, [4, [4, [5, null]]]]]]), tail([2, [3, [3, [4, [4, [5, null]]]]]]));
[beforeMarker] tail runs

equal([3, [3, [4, [4, [5, null]]]]], tail([2, [3, [3, [4, [4, [5, null]]]]]]));
[afterMarker] tail runs

equal([3, [3, [4, [4, [5, null]]]]], tail([2, [3, [3, [4, [4, [5, null]]]]]]));
[beforeMarker] tail runs

equal([3, [3, [4, [4, [5, null]]]]], [3, [3, [4, [4, [5, null]]]]]);
[afterMarker] tail runs

equal([3, [3, [4, [4, [5, null]]]]], [3, [3, [4, [4, [5, null]]]]]);
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)([3, [3, [4, [4, [5, null]]]]], [3, [3, [4, [4, [5, null]]]]]);
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)([3, [3, [4, [4, [5, null]]]]], [3, [3, [4, [4, [5, null]]]]]);
[beforeMarker] [3, [3, [4, [4, [5, null]]]]], [3, [3, [4, [4, [5, null]]]]] substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

is_pair([3, [3, [4, [4, [5, null]]]]]) ? is_pair([3, [3, [4, [4, [5, null]]]]]) && equal(head([3, [3, [4, [4, [5, null]]]]]), head([3, [3, [4, [4, [5, null]]]]])) && equal(tail([3, [3, [4, [4, [5, null]]]]]), tail([3, [3, [4, [4, [5, null]]]]])) : is_null([3, [3, [4, [4, [5, null]]]]]) ? is_null([3, [3, [4, [4, [5, null]]]]]) : is_number([3, [3, [4, [4, [5, null]]]]]) ? is_number([3, [3, [4, [4, [5, null]]]]]) && [3, [3, [4, [4, [5, null]]]]] === [3, [3, [4, [4, [5, null]]]]] : is_boolean([3, [3, [4, [4, [5, null]]]]]) ? is_boolean([3, [3, [4, [4, [5, null]]]]]) && ([3, [3, [4, [4, [5, null]]]]] && [3, [3, [4, [4, [5, null]]]]] || ![3, [3, [4, [4, [5, null]]]]] && ![3, [3, [4, [4, [5, null]]]]]) : is_string([3, [3, [4, [4, [5, null]]]]]) ? is_string([3, [3, [4, [4, [5, null]]]]]) && [3, [3, [4, [4, [5, null]]]]] === [3, [3, [4, [4, [5, null]]]]] : is_undefined([3, [3, [4, [4, [5, null]]]]]) ? is_undefined([3, [3, [4, [4, [5, null]]]]]) : is_function([3, [3, [4, [4, [5, null]]]]]) ? is_function([3, [3, [4, [4, [5, null]]]]]) && [3, [3, [4, [4, [5, null]]]]] === [3, [3, [4, [4, [5, null]]]]] : fals;
[afterMarker] [3, [3, [4, [4, [5, null]]]]], [3, [3, [4, [4, [5, null]]]]] substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

is_pair([3, [3, [4, [4, [5, null]]]]]) ? is_pair([3, [3, [4, [4, [5, null]]]]]) && equal(head([3, [3, [4, [4, [5, null]]]]]), head([3, [3, [4, [4, [5, null]]]]])) && equal(tail([3, [3, [4, [4, [5, null]]]]]), tail([3, [3, [4, [4, [5, null]]]]])) : is_null([3, [3, [4, [4, [5, null]]]]]) ? is_null([3, [3, [4, [4, [5, null]]]]]) : is_number([3, [3, [4, [4, [5, null]]]]]) ? is_number([3, [3, [4, [4, [5, null]]]]]) && [3, [3, [4, [4, [5, null]]]]] === [3, [3, [4, [4, [5, null]]]]] : is_boolean([3, [3, [4, [4, [5, null]]]]]) ? is_boolean([3, [3, [4, [4, [5, null]]]]]) && ([3, [3, [4, [4, [5, null]]]]] && [3, [3, [4, [4, [5, null]]]]] || ![3, [3, [4, [4, [5, null]]]]] && ![3, [3, [4, [4, [5, null]]]]]) : is_string([3, [3, [4, [4, [5, null]]]]]) ? is_string([3, [3, [4, [4, [5, null]]]]]) && [3, [3, [4, [4, [5, null]]]]] === [3, [3, [4, [4, [5, null]]]]] : is_undefined([3, [3, [4, [4, [5, null]]]]]) ? is_undefined([3, [3, [4, [4, [5, null]]]]]) : is_function([3, [3, [4, [4, [5, null]]]]]) ? is_function([3, [3, [4, [4, [5, null]]]]]) && [3, [3, [4, [4, [5, null]]]]] === [3, [3, [4, [4, [5, null]]]]] : fals;
[beforeMarker] is_pair runs

true ? is_pair([3, [3, [4, [4, [5, null]]]]]) && equal(head([3, [3, [4, [4, [5, null]]]]]), head([3, [3, [4, [4, [5, null]]]]])) && equal(tail([3, [3, [4, [4, [5, null]]]]]), tail([3, [3, [4, [4, [5, null]]]]])) : is_null([3, [3, [4, [4, [5, null]]]]]) ? is_null([3, [3, [4, [4, [5, null]]]]]) : is_number([3, [3, [4, [4, [5, null]]]]]) ? is_number([3, [3, [4, [4, [5, null]]]]]) && [3, [3, [4, [4, [5, null]]]]] === [3, [3, [4, [4, [5, null]]]]] : is_boolean([3, [3, [4, [4, [5, null]]]]]) ? is_boolean([3, [3, [4, [4, [5, null]]]]]) && ([3, [3, [4, [4, [5, null]]]]] && [3, [3, [4, [4, [5, null]]]]] || ![3, [3, [4, [4, [5, null]]]]] && ![3, [3, [4, [4, [5, null]]]]]) : is_string([3, [3, [4, [4, [5, null]]]]]) ? is_string([3, [3, [4, [4, [5, null]]]]]) && [3, [3, [4, [4, [5, null]]]]] === [3, [3, [4, [4, [5, null]]]]] : is_undefined([3, [3, [4, [4, [5, null]]]]]) ? is_undefined([3, [3, [4, [4, [5, null]]]]]) : is_function([3, [3, [4, [4, [5, null]]]]]) ? is_function([3, [3, [4, [4, [5, null]]]]]) && [3, [3, [4, [4, [5, null]]]]] === [3, [3, [4, [4, [5, null]]]]] : fals;
[afterMarker] is_pair runs

true ? is_pair([3, [3, [4, [4, [5, null]]]]]) && equal(head([3, [3, [4, [4, [5, null]]]]]), head([3, [3, [4, [4, [5, null]]]]])) && equal(tail([3, [3, [4, [4, [5, null]]]]]), tail([3, [3, [4, [4, [5, null]]]]])) : is_null([3, [3, [4, [4, [5, null]]]]]) ? is_null([3, [3, [4, [4, [5, null]]]]]) : is_number([3, [3, [4, [4, [5, null]]]]]) ? is_number([3, [3, [4, [4, [5, null]]]]]) && [3, [3, [4, [4, [5, null]]]]] === [3, [3, [4, [4, [5, null]]]]] : is_boolean([3, [3, [4, [4, [5, null]]]]]) ? is_boolean([3, [3, [4, [4, [5, null]]]]]) && ([3, [3, [4, [4, [5, null]]]]] && [3, [3, [4, [4, [5, null]]]]] || ![3, [3, [4, [4, [5, null]]]]] && ![3, [3, [4, [4, [5, null]]]]]) : is_string([3, [3, [4, [4, [5, null]]]]]) ? is_string([3, [3, [4, [4, [5, null]]]]]) && [3, [3, [4, [4, [5, null]]]]] === [3, [3, [4, [4, [5, null]]]]] : is_undefined([3, [3, [4, [4, [5, null]]]]]) ? is_undefined([3, [3, [4, [4, [5, null]]]]]) : is_function([3, [3, [4, [4, [5, null]]]]]) ? is_function([3, [3, [4, [4, [5, null]]]]]) && [3, [3, [4, [4, [5, null]]]]] === [3, [3, [4, [4, [5, null]]]]] : fals;
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_pair([3, [3, [4, [4, [5, null]]]]]) && equal(head([3, [3, [4, [4, [5, null]]]]]), head([3, [3, [4, [4, [5, null]]]]])) && equal(tail([3, [3, [4, [4, [5, null]]]]]), tail([3, [3, [4, [4, [5, null]]]]]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_pair([3, [3, [4, [4, [5, null]]]]]) && equal(head([3, [3, [4, [4, [5, null]]]]]), head([3, [3, [4, [4, [5, null]]]]])) && equal(tail([3, [3, [4, [4, [5, null]]]]]), tail([3, [3, [4, [4, [5, null]]]]]));
[beforeMarker] is_pair runs

true && equal(head([3, [3, [4, [4, [5, null]]]]]), head([3, [3, [4, [4, [5, null]]]]])) && equal(tail([3, [3, [4, [4, [5, null]]]]]), tail([3, [3, [4, [4, [5, null]]]]]));
[afterMarker] is_pair runs

true && equal(head([3, [3, [4, [4, [5, null]]]]]), head([3, [3, [4, [4, [5, null]]]]])) && equal(tail([3, [3, [4, [4, [5, null]]]]]), tail([3, [3, [4, [4, [5, null]]]]]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(head([3, [3, [4, [4, [5, null]]]]]), head([3, [3, [4, [4, [5, null]]]]])) && equal(tail([3, [3, [4, [4, [5, null]]]]]), tail([3, [3, [4, [4, [5, null]]]]]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(head([3, [3, [4, [4, [5, null]]]]]), head([3, [3, [4, [4, [5, null]]]]])) && equal(tail([3, [3, [4, [4, [5, null]]]]]), tail([3, [3, [4, [4, [5, null]]]]]));
[beforeMarker] head runs

equal(3, head([3, [3, [4, [4, [5, null]]]]])) && equal(tail([3, [3, [4, [4, [5, null]]]]]), tail([3, [3, [4, [4, [5, null]]]]]));
[afterMarker] head runs

equal(3, head([3, [3, [4, [4, [5, null]]]]])) && equal(tail([3, [3, [4, [4, [5, null]]]]]), tail([3, [3, [4, [4, [5, null]]]]]));
[beforeMarker] head runs

equal(3, 3) && equal(tail([3, [3, [4, [4, [5, null]]]]]), tail([3, [3, [4, [4, [5, null]]]]]));
[afterMarker] head runs

equal(3, 3) && equal(tail([3, [3, [4, [4, [5, null]]]]]), tail([3, [3, [4, [4, [5, null]]]]]));
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(3, 3) && equal(tail([3, [3, [4, [4, [5, null]]]]]), tail([3, [3, [4, [4, [5, null]]]]]));
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(3, 3) && equal(tail([3, [3, [4, [4, [5, null]]]]]), tail([3, [3, [4, [4, [5, null]]]]]));
[beforeMarker] 3, 3 substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair(3) ? is_pair(3) && equal(head(3), head(3)) && equal(tail(3), tail(3)) : is_null(3) ? is_null(3) : is_number(3) ? is_number(3) && 3 === 3 : is_boolean(3) ? is_boolean(3) && (3 && 3 || !3 && !3) : is_string(3) ? is_string(3) && 3 === 3 : is_undefined(3) ? is_undefined(3) : is_function(3) ? is_function(3) && 3 === 3 : fals) && equal(tail([3, [3, [4, [4, [5, null]]]]]), tail([3, [3, [4, [4, [5, null]]]]]));
[afterMarker] 3, 3 substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair(3) ? is_pair(3) && equal(head(3), head(3)) && equal(tail(3), tail(3)) : is_null(3) ? is_null(3) : is_number(3) ? is_number(3) && 3 === 3 : is_boolean(3) ? is_boolean(3) && (3 && 3 || !3 && !3) : is_string(3) ? is_string(3) && 3 === 3 : is_undefined(3) ? is_undefined(3) : is_function(3) ? is_function(3) && 3 === 3 : fals) && equal(tail([3, [3, [4, [4, [5, null]]]]]), tail([3, [3, [4, [4, [5, null]]]]]));
[beforeMarker] is_pair runs

(false ? is_pair(3) && equal(head(3), head(3)) && equal(tail(3), tail(3)) : is_null(3) ? is_null(3) : is_number(3) ? is_number(3) && 3 === 3 : is_boolean(3) ? is_boolean(3) && (3 && 3 || !3 && !3) : is_string(3) ? is_string(3) && 3 === 3 : is_undefined(3) ? is_undefined(3) : is_function(3) ? is_function(3) && 3 === 3 : fals) && equal(tail([3, [3, [4, [4, [5, null]]]]]), tail([3, [3, [4, [4, [5, null]]]]]));
[afterMarker] is_pair runs

(false ? is_pair(3) && equal(head(3), head(3)) && equal(tail(3), tail(3)) : is_null(3) ? is_null(3) : is_number(3) ? is_number(3) && 3 === 3 : is_boolean(3) ? is_boolean(3) && (3 && 3 || !3 && !3) : is_string(3) ? is_string(3) && 3 === 3 : is_undefined(3) ? is_undefined(3) : is_function(3) ? is_function(3) && 3 === 3 : fals) && equal(tail([3, [3, [4, [4, [5, null]]]]]), tail([3, [3, [4, [4, [5, null]]]]]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_null(3) ? is_null(3) : is_number(3) ? is_number(3) && 3 === 3 : is_boolean(3) ? is_boolean(3) && (3 && 3 || !3 && !3) : is_string(3) ? is_string(3) && 3 === 3 : is_undefined(3) ? is_undefined(3) : is_function(3) ? is_function(3) && 3 === 3 : fals) && equal(tail([3, [3, [4, [4, [5, null]]]]]), tail([3, [3, [4, [4, [5, null]]]]]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_null(3) ? is_null(3) : is_number(3) ? is_number(3) && 3 === 3 : is_boolean(3) ? is_boolean(3) && (3 && 3 || !3 && !3) : is_string(3) ? is_string(3) && 3 === 3 : is_undefined(3) ? is_undefined(3) : is_function(3) ? is_function(3) && 3 === 3 : fals) && equal(tail([3, [3, [4, [4, [5, null]]]]]), tail([3, [3, [4, [4, [5, null]]]]]));
[beforeMarker] is_null runs

(false ? is_null(3) : is_number(3) ? is_number(3) && 3 === 3 : is_boolean(3) ? is_boolean(3) && (3 && 3 || !3 && !3) : is_string(3) ? is_string(3) && 3 === 3 : is_undefined(3) ? is_undefined(3) : is_function(3) ? is_function(3) && 3 === 3 : fals) && equal(tail([3, [3, [4, [4, [5, null]]]]]), tail([3, [3, [4, [4, [5, null]]]]]));
[afterMarker] is_null runs

(false ? is_null(3) : is_number(3) ? is_number(3) && 3 === 3 : is_boolean(3) ? is_boolean(3) && (3 && 3 || !3 && !3) : is_string(3) ? is_string(3) && 3 === 3 : is_undefined(3) ? is_undefined(3) : is_function(3) ? is_function(3) && 3 === 3 : fals) && equal(tail([3, [3, [4, [4, [5, null]]]]]), tail([3, [3, [4, [4, [5, null]]]]]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_number(3) ? is_number(3) && 3 === 3 : is_boolean(3) ? is_boolean(3) && (3 && 3 || !3 && !3) : is_string(3) ? is_string(3) && 3 === 3 : is_undefined(3) ? is_undefined(3) : is_function(3) ? is_function(3) && 3 === 3 : fals) && equal(tail([3, [3, [4, [4, [5, null]]]]]), tail([3, [3, [4, [4, [5, null]]]]]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_number(3) ? is_number(3) && 3 === 3 : is_boolean(3) ? is_boolean(3) && (3 && 3 || !3 && !3) : is_string(3) ? is_string(3) && 3 === 3 : is_undefined(3) ? is_undefined(3) : is_function(3) ? is_function(3) && 3 === 3 : fals) && equal(tail([3, [3, [4, [4, [5, null]]]]]), tail([3, [3, [4, [4, [5, null]]]]]));
[beforeMarker] is_number runs

(true ? is_number(3) && 3 === 3 : is_boolean(3) ? is_boolean(3) && (3 && 3 || !3 && !3) : is_string(3) ? is_string(3) && 3 === 3 : is_undefined(3) ? is_undefined(3) : is_function(3) ? is_function(3) && 3 === 3 : fals) && equal(tail([3, [3, [4, [4, [5, null]]]]]), tail([3, [3, [4, [4, [5, null]]]]]));
[afterMarker] is_number runs

(true ? is_number(3) && 3 === 3 : is_boolean(3) ? is_boolean(3) && (3 && 3 || !3 && !3) : is_string(3) ? is_string(3) && 3 === 3 : is_undefined(3) ? is_undefined(3) : is_function(3) ? is_function(3) && 3 === 3 : fals) && equal(tail([3, [3, [4, [4, [5, null]]]]]), tail([3, [3, [4, [4, [5, null]]]]]));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_number(3) && 3 === 3 && equal(tail([3, [3, [4, [4, [5, null]]]]]), tail([3, [3, [4, [4, [5, null]]]]]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_number(3) && 3 === 3 && equal(tail([3, [3, [4, [4, [5, null]]]]]), tail([3, [3, [4, [4, [5, null]]]]]));
[beforeMarker] is_number runs

true && 3 === 3 && equal(tail([3, [3, [4, [4, [5, null]]]]]), tail([3, [3, [4, [4, [5, null]]]]]));
[afterMarker] is_number runs

true && 3 === 3 && equal(tail([3, [3, [4, [4, [5, null]]]]]), tail([3, [3, [4, [4, [5, null]]]]]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

3 === 3 && equal(tail([3, [3, [4, [4, [5, null]]]]]), tail([3, [3, [4, [4, [5, null]]]]]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

3 === 3 && equal(tail([3, [3, [4, [4, [5, null]]]]]), tail([3, [3, [4, [4, [5, null]]]]]));
[beforeMarker] Binary expression 3 === 3 evaluated

true && equal(tail([3, [3, [4, [4, [5, null]]]]]), tail([3, [3, [4, [4, [5, null]]]]]));
[afterMarker] Binary expression 3 === 3 evaluated

true && equal(tail([3, [3, [4, [4, [5, null]]]]]), tail([3, [3, [4, [4, [5, null]]]]]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(tail([3, [3, [4, [4, [5, null]]]]]), tail([3, [3, [4, [4, [5, null]]]]]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(tail([3, [3, [4, [4, [5, null]]]]]), tail([3, [3, [4, [4, [5, null]]]]]));
[beforeMarker] tail runs

equal([3, [4, [4, [5, null]]]], tail([3, [3, [4, [4, [5, null]]]]]));
[afterMarker] tail runs

equal([3, [4, [4, [5, null]]]], tail([3, [3, [4, [4, [5, null]]]]]));
[beforeMarker] tail runs

equal([3, [4, [4, [5, null]]]], [3, [4, [4, [5, null]]]]);
[afterMarker] tail runs

equal([3, [4, [4, [5, null]]]], [3, [4, [4, [5, null]]]]);
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)([3, [4, [4, [5, null]]]], [3, [4, [4, [5, null]]]]);
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)([3, [4, [4, [5, null]]]], [3, [4, [4, [5, null]]]]);
[beforeMarker] [3, [4, [4, [5, null]]]], [3, [4, [4, [5, null]]]] substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

is_pair([3, [4, [4, [5, null]]]]) ? is_pair([3, [4, [4, [5, null]]]]) && equal(head([3, [4, [4, [5, null]]]]), head([3, [4, [4, [5, null]]]])) && equal(tail([3, [4, [4, [5, null]]]]), tail([3, [4, [4, [5, null]]]])) : is_null([3, [4, [4, [5, null]]]]) ? is_null([3, [4, [4, [5, null]]]]) : is_number([3, [4, [4, [5, null]]]]) ? is_number([3, [4, [4, [5, null]]]]) && [3, [4, [4, [5, null]]]] === [3, [4, [4, [5, null]]]] : is_boolean([3, [4, [4, [5, null]]]]) ? is_boolean([3, [4, [4, [5, null]]]]) && ([3, [4, [4, [5, null]]]] && [3, [4, [4, [5, null]]]] || ![3, [4, [4, [5, null]]]] && ![3, [4, [4, [5, null]]]]) : is_string([3, [4, [4, [5, null]]]]) ? is_string([3, [4, [4, [5, null]]]]) && [3, [4, [4, [5, null]]]] === [3, [4, [4, [5, null]]]] : is_undefined([3, [4, [4, [5, null]]]]) ? is_undefined([3, [4, [4, [5, null]]]]) : is_function([3, [4, [4, [5, null]]]]) ? is_function([3, [4, [4, [5, null]]]]) && [3, [4, [4, [5, null]]]] === [3, [4, [4, [5, null]]]] : fals;
[afterMarker] [3, [4, [4, [5, null]]]], [3, [4, [4, [5, null]]]] substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

is_pair([3, [4, [4, [5, null]]]]) ? is_pair([3, [4, [4, [5, null]]]]) && equal(head([3, [4, [4, [5, null]]]]), head([3, [4, [4, [5, null]]]])) && equal(tail([3, [4, [4, [5, null]]]]), tail([3, [4, [4, [5, null]]]])) : is_null([3, [4, [4, [5, null]]]]) ? is_null([3, [4, [4, [5, null]]]]) : is_number([3, [4, [4, [5, null]]]]) ? is_number([3, [4, [4, [5, null]]]]) && [3, [4, [4, [5, null]]]] === [3, [4, [4, [5, null]]]] : is_boolean([3, [4, [4, [5, null]]]]) ? is_boolean([3, [4, [4, [5, null]]]]) && ([3, [4, [4, [5, null]]]] && [3, [4, [4, [5, null]]]] || ![3, [4, [4, [5, null]]]] && ![3, [4, [4, [5, null]]]]) : is_string([3, [4, [4, [5, null]]]]) ? is_string([3, [4, [4, [5, null]]]]) && [3, [4, [4, [5, null]]]] === [3, [4, [4, [5, null]]]] : is_undefined([3, [4, [4, [5, null]]]]) ? is_undefined([3, [4, [4, [5, null]]]]) : is_function([3, [4, [4, [5, null]]]]) ? is_function([3, [4, [4, [5, null]]]]) && [3, [4, [4, [5, null]]]] === [3, [4, [4, [5, null]]]] : fals;
[beforeMarker] is_pair runs

true ? is_pair([3, [4, [4, [5, null]]]]) && equal(head([3, [4, [4, [5, null]]]]), head([3, [4, [4, [5, null]]]])) && equal(tail([3, [4, [4, [5, null]]]]), tail([3, [4, [4, [5, null]]]])) : is_null([3, [4, [4, [5, null]]]]) ? is_null([3, [4, [4, [5, null]]]]) : is_number([3, [4, [4, [5, null]]]]) ? is_number([3, [4, [4, [5, null]]]]) && [3, [4, [4, [5, null]]]] === [3, [4, [4, [5, null]]]] : is_boolean([3, [4, [4, [5, null]]]]) ? is_boolean([3, [4, [4, [5, null]]]]) && ([3, [4, [4, [5, null]]]] && [3, [4, [4, [5, null]]]] || ![3, [4, [4, [5, null]]]] && ![3, [4, [4, [5, null]]]]) : is_string([3, [4, [4, [5, null]]]]) ? is_string([3, [4, [4, [5, null]]]]) && [3, [4, [4, [5, null]]]] === [3, [4, [4, [5, null]]]] : is_undefined([3, [4, [4, [5, null]]]]) ? is_undefined([3, [4, [4, [5, null]]]]) : is_function([3, [4, [4, [5, null]]]]) ? is_function([3, [4, [4, [5, null]]]]) && [3, [4, [4, [5, null]]]] === [3, [4, [4, [5, null]]]] : fals;
[afterMarker] is_pair runs

true ? is_pair([3, [4, [4, [5, null]]]]) && equal(head([3, [4, [4, [5, null]]]]), head([3, [4, [4, [5, null]]]])) && equal(tail([3, [4, [4, [5, null]]]]), tail([3, [4, [4, [5, null]]]])) : is_null([3, [4, [4, [5, null]]]]) ? is_null([3, [4, [4, [5, null]]]]) : is_number([3, [4, [4, [5, null]]]]) ? is_number([3, [4, [4, [5, null]]]]) && [3, [4, [4, [5, null]]]] === [3, [4, [4, [5, null]]]] : is_boolean([3, [4, [4, [5, null]]]]) ? is_boolean([3, [4, [4, [5, null]]]]) && ([3, [4, [4, [5, null]]]] && [3, [4, [4, [5, null]]]] || ![3, [4, [4, [5, null]]]] && ![3, [4, [4, [5, null]]]]) : is_string([3, [4, [4, [5, null]]]]) ? is_string([3, [4, [4, [5, null]]]]) && [3, [4, [4, [5, null]]]] === [3, [4, [4, [5, null]]]] : is_undefined([3, [4, [4, [5, null]]]]) ? is_undefined([3, [4, [4, [5, null]]]]) : is_function([3, [4, [4, [5, null]]]]) ? is_function([3, [4, [4, [5, null]]]]) && [3, [4, [4, [5, null]]]] === [3, [4, [4, [5, null]]]] : fals;
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_pair([3, [4, [4, [5, null]]]]) && equal(head([3, [4, [4, [5, null]]]]), head([3, [4, [4, [5, null]]]])) && equal(tail([3, [4, [4, [5, null]]]]), tail([3, [4, [4, [5, null]]]]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_pair([3, [4, [4, [5, null]]]]) && equal(head([3, [4, [4, [5, null]]]]), head([3, [4, [4, [5, null]]]])) && equal(tail([3, [4, [4, [5, null]]]]), tail([3, [4, [4, [5, null]]]]));
[beforeMarker] is_pair runs

true && equal(head([3, [4, [4, [5, null]]]]), head([3, [4, [4, [5, null]]]])) && equal(tail([3, [4, [4, [5, null]]]]), tail([3, [4, [4, [5, null]]]]));
[afterMarker] is_pair runs

true && equal(head([3, [4, [4, [5, null]]]]), head([3, [4, [4, [5, null]]]])) && equal(tail([3, [4, [4, [5, null]]]]), tail([3, [4, [4, [5, null]]]]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(head([3, [4, [4, [5, null]]]]), head([3, [4, [4, [5, null]]]])) && equal(tail([3, [4, [4, [5, null]]]]), tail([3, [4, [4, [5, null]]]]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(head([3, [4, [4, [5, null]]]]), head([3, [4, [4, [5, null]]]])) && equal(tail([3, [4, [4, [5, null]]]]), tail([3, [4, [4, [5, null]]]]));
[beforeMarker] head runs

equal(3, head([3, [4, [4, [5, null]]]])) && equal(tail([3, [4, [4, [5, null]]]]), tail([3, [4, [4, [5, null]]]]));
[afterMarker] head runs

equal(3, head([3, [4, [4, [5, null]]]])) && equal(tail([3, [4, [4, [5, null]]]]), tail([3, [4, [4, [5, null]]]]));
[beforeMarker] head runs

equal(3, 3) && equal(tail([3, [4, [4, [5, null]]]]), tail([3, [4, [4, [5, null]]]]));
[afterMarker] head runs

equal(3, 3) && equal(tail([3, [4, [4, [5, null]]]]), tail([3, [4, [4, [5, null]]]]));
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(3, 3) && equal(tail([3, [4, [4, [5, null]]]]), tail([3, [4, [4, [5, null]]]]));
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(3, 3) && equal(tail([3, [4, [4, [5, null]]]]), tail([3, [4, [4, [5, null]]]]));
[beforeMarker] 3, 3 substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair(3) ? is_pair(3) && equal(head(3), head(3)) && equal(tail(3), tail(3)) : is_null(3) ? is_null(3) : is_number(3) ? is_number(3) && 3 === 3 : is_boolean(3) ? is_boolean(3) && (3 && 3 || !3 && !3) : is_string(3) ? is_string(3) && 3 === 3 : is_undefined(3) ? is_undefined(3) : is_function(3) ? is_function(3) && 3 === 3 : fals) && equal(tail([3, [4, [4, [5, null]]]]), tail([3, [4, [4, [5, null]]]]));
[afterMarker] 3, 3 substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair(3) ? is_pair(3) && equal(head(3), head(3)) && equal(tail(3), tail(3)) : is_null(3) ? is_null(3) : is_number(3) ? is_number(3) && 3 === 3 : is_boolean(3) ? is_boolean(3) && (3 && 3 || !3 && !3) : is_string(3) ? is_string(3) && 3 === 3 : is_undefined(3) ? is_undefined(3) : is_function(3) ? is_function(3) && 3 === 3 : fals) && equal(tail([3, [4, [4, [5, null]]]]), tail([3, [4, [4, [5, null]]]]));
[beforeMarker] is_pair runs

(false ? is_pair(3) && equal(head(3), head(3)) && equal(tail(3), tail(3)) : is_null(3) ? is_null(3) : is_number(3) ? is_number(3) && 3 === 3 : is_boolean(3) ? is_boolean(3) && (3 && 3 || !3 && !3) : is_string(3) ? is_string(3) && 3 === 3 : is_undefined(3) ? is_undefined(3) : is_function(3) ? is_function(3) && 3 === 3 : fals) && equal(tail([3, [4, [4, [5, null]]]]), tail([3, [4, [4, [5, null]]]]));
[afterMarker] is_pair runs

(false ? is_pair(3) && equal(head(3), head(3)) && equal(tail(3), tail(3)) : is_null(3) ? is_null(3) : is_number(3) ? is_number(3) && 3 === 3 : is_boolean(3) ? is_boolean(3) && (3 && 3 || !3 && !3) : is_string(3) ? is_string(3) && 3 === 3 : is_undefined(3) ? is_undefined(3) : is_function(3) ? is_function(3) && 3 === 3 : fals) && equal(tail([3, [4, [4, [5, null]]]]), tail([3, [4, [4, [5, null]]]]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_null(3) ? is_null(3) : is_number(3) ? is_number(3) && 3 === 3 : is_boolean(3) ? is_boolean(3) && (3 && 3 || !3 && !3) : is_string(3) ? is_string(3) && 3 === 3 : is_undefined(3) ? is_undefined(3) : is_function(3) ? is_function(3) && 3 === 3 : fals) && equal(tail([3, [4, [4, [5, null]]]]), tail([3, [4, [4, [5, null]]]]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_null(3) ? is_null(3) : is_number(3) ? is_number(3) && 3 === 3 : is_boolean(3) ? is_boolean(3) && (3 && 3 || !3 && !3) : is_string(3) ? is_string(3) && 3 === 3 : is_undefined(3) ? is_undefined(3) : is_function(3) ? is_function(3) && 3 === 3 : fals) && equal(tail([3, [4, [4, [5, null]]]]), tail([3, [4, [4, [5, null]]]]));
[beforeMarker] is_null runs

(false ? is_null(3) : is_number(3) ? is_number(3) && 3 === 3 : is_boolean(3) ? is_boolean(3) && (3 && 3 || !3 && !3) : is_string(3) ? is_string(3) && 3 === 3 : is_undefined(3) ? is_undefined(3) : is_function(3) ? is_function(3) && 3 === 3 : fals) && equal(tail([3, [4, [4, [5, null]]]]), tail([3, [4, [4, [5, null]]]]));
[afterMarker] is_null runs

(false ? is_null(3) : is_number(3) ? is_number(3) && 3 === 3 : is_boolean(3) ? is_boolean(3) && (3 && 3 || !3 && !3) : is_string(3) ? is_string(3) && 3 === 3 : is_undefined(3) ? is_undefined(3) : is_function(3) ? is_function(3) && 3 === 3 : fals) && equal(tail([3, [4, [4, [5, null]]]]), tail([3, [4, [4, [5, null]]]]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_number(3) ? is_number(3) && 3 === 3 : is_boolean(3) ? is_boolean(3) && (3 && 3 || !3 && !3) : is_string(3) ? is_string(3) && 3 === 3 : is_undefined(3) ? is_undefined(3) : is_function(3) ? is_function(3) && 3 === 3 : fals) && equal(tail([3, [4, [4, [5, null]]]]), tail([3, [4, [4, [5, null]]]]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_number(3) ? is_number(3) && 3 === 3 : is_boolean(3) ? is_boolean(3) && (3 && 3 || !3 && !3) : is_string(3) ? is_string(3) && 3 === 3 : is_undefined(3) ? is_undefined(3) : is_function(3) ? is_function(3) && 3 === 3 : fals) && equal(tail([3, [4, [4, [5, null]]]]), tail([3, [4, [4, [5, null]]]]));
[beforeMarker] is_number runs

(true ? is_number(3) && 3 === 3 : is_boolean(3) ? is_boolean(3) && (3 && 3 || !3 && !3) : is_string(3) ? is_string(3) && 3 === 3 : is_undefined(3) ? is_undefined(3) : is_function(3) ? is_function(3) && 3 === 3 : fals) && equal(tail([3, [4, [4, [5, null]]]]), tail([3, [4, [4, [5, null]]]]));
[afterMarker] is_number runs

(true ? is_number(3) && 3 === 3 : is_boolean(3) ? is_boolean(3) && (3 && 3 || !3 && !3) : is_string(3) ? is_string(3) && 3 === 3 : is_undefined(3) ? is_undefined(3) : is_function(3) ? is_function(3) && 3 === 3 : fals) && equal(tail([3, [4, [4, [5, null]]]]), tail([3, [4, [4, [5, null]]]]));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_number(3) && 3 === 3 && equal(tail([3, [4, [4, [5, null]]]]), tail([3, [4, [4, [5, null]]]]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_number(3) && 3 === 3 && equal(tail([3, [4, [4, [5, null]]]]), tail([3, [4, [4, [5, null]]]]));
[beforeMarker] is_number runs

true && 3 === 3 && equal(tail([3, [4, [4, [5, null]]]]), tail([3, [4, [4, [5, null]]]]));
[afterMarker] is_number runs

true && 3 === 3 && equal(tail([3, [4, [4, [5, null]]]]), tail([3, [4, [4, [5, null]]]]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

3 === 3 && equal(tail([3, [4, [4, [5, null]]]]), tail([3, [4, [4, [5, null]]]]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

3 === 3 && equal(tail([3, [4, [4, [5, null]]]]), tail([3, [4, [4, [5, null]]]]));
[beforeMarker] Binary expression 3 === 3 evaluated

true && equal(tail([3, [4, [4, [5, null]]]]), tail([3, [4, [4, [5, null]]]]));
[afterMarker] Binary expression 3 === 3 evaluated

true && equal(tail([3, [4, [4, [5, null]]]]), tail([3, [4, [4, [5, null]]]]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(tail([3, [4, [4, [5, null]]]]), tail([3, [4, [4, [5, null]]]]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(tail([3, [4, [4, [5, null]]]]), tail([3, [4, [4, [5, null]]]]));
[beforeMarker] tail runs

equal([4, [4, [5, null]]], tail([3, [4, [4, [5, null]]]]));
[afterMarker] tail runs

equal([4, [4, [5, null]]], tail([3, [4, [4, [5, null]]]]));
[beforeMarker] tail runs

equal([4, [4, [5, null]]], [4, [4, [5, null]]]);
[afterMarker] tail runs

equal([4, [4, [5, null]]], [4, [4, [5, null]]]);
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)([4, [4, [5, null]]], [4, [4, [5, null]]]);
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)([4, [4, [5, null]]], [4, [4, [5, null]]]);
[beforeMarker] [4, [4, [5, null]]], [4, [4, [5, null]]] substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

is_pair([4, [4, [5, null]]]) ? is_pair([4, [4, [5, null]]]) && equal(head([4, [4, [5, null]]]), head([4, [4, [5, null]]])) && equal(tail([4, [4, [5, null]]]), tail([4, [4, [5, null]]])) : is_null([4, [4, [5, null]]]) ? is_null([4, [4, [5, null]]]) : is_number([4, [4, [5, null]]]) ? is_number([4, [4, [5, null]]]) && [4, [4, [5, null]]] === [4, [4, [5, null]]] : is_boolean([4, [4, [5, null]]]) ? is_boolean([4, [4, [5, null]]]) && ([4, [4, [5, null]]] && [4, [4, [5, null]]] || ![4, [4, [5, null]]] && ![4, [4, [5, null]]]) : is_string([4, [4, [5, null]]]) ? is_string([4, [4, [5, null]]]) && [4, [4, [5, null]]] === [4, [4, [5, null]]] : is_undefined([4, [4, [5, null]]]) ? is_undefined([4, [4, [5, null]]]) : is_function([4, [4, [5, null]]]) ? is_function([4, [4, [5, null]]]) && [4, [4, [5, null]]] === [4, [4, [5, null]]] : fals;
[afterMarker] [4, [4, [5, null]]], [4, [4, [5, null]]] substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

is_pair([4, [4, [5, null]]]) ? is_pair([4, [4, [5, null]]]) && equal(head([4, [4, [5, null]]]), head([4, [4, [5, null]]])) && equal(tail([4, [4, [5, null]]]), tail([4, [4, [5, null]]])) : is_null([4, [4, [5, null]]]) ? is_null([4, [4, [5, null]]]) : is_number([4, [4, [5, null]]]) ? is_number([4, [4, [5, null]]]) && [4, [4, [5, null]]] === [4, [4, [5, null]]] : is_boolean([4, [4, [5, null]]]) ? is_boolean([4, [4, [5, null]]]) && ([4, [4, [5, null]]] && [4, [4, [5, null]]] || ![4, [4, [5, null]]] && ![4, [4, [5, null]]]) : is_string([4, [4, [5, null]]]) ? is_string([4, [4, [5, null]]]) && [4, [4, [5, null]]] === [4, [4, [5, null]]] : is_undefined([4, [4, [5, null]]]) ? is_undefined([4, [4, [5, null]]]) : is_function([4, [4, [5, null]]]) ? is_function([4, [4, [5, null]]]) && [4, [4, [5, null]]] === [4, [4, [5, null]]] : fals;
[beforeMarker] is_pair runs

true ? is_pair([4, [4, [5, null]]]) && equal(head([4, [4, [5, null]]]), head([4, [4, [5, null]]])) && equal(tail([4, [4, [5, null]]]), tail([4, [4, [5, null]]])) : is_null([4, [4, [5, null]]]) ? is_null([4, [4, [5, null]]]) : is_number([4, [4, [5, null]]]) ? is_number([4, [4, [5, null]]]) && [4, [4, [5, null]]] === [4, [4, [5, null]]] : is_boolean([4, [4, [5, null]]]) ? is_boolean([4, [4, [5, null]]]) && ([4, [4, [5, null]]] && [4, [4, [5, null]]] || ![4, [4, [5, null]]] && ![4, [4, [5, null]]]) : is_string([4, [4, [5, null]]]) ? is_string([4, [4, [5, null]]]) && [4, [4, [5, null]]] === [4, [4, [5, null]]] : is_undefined([4, [4, [5, null]]]) ? is_undefined([4, [4, [5, null]]]) : is_function([4, [4, [5, null]]]) ? is_function([4, [4, [5, null]]]) && [4, [4, [5, null]]] === [4, [4, [5, null]]] : fals;
[afterMarker] is_pair runs

true ? is_pair([4, [4, [5, null]]]) && equal(head([4, [4, [5, null]]]), head([4, [4, [5, null]]])) && equal(tail([4, [4, [5, null]]]), tail([4, [4, [5, null]]])) : is_null([4, [4, [5, null]]]) ? is_null([4, [4, [5, null]]]) : is_number([4, [4, [5, null]]]) ? is_number([4, [4, [5, null]]]) && [4, [4, [5, null]]] === [4, [4, [5, null]]] : is_boolean([4, [4, [5, null]]]) ? is_boolean([4, [4, [5, null]]]) && ([4, [4, [5, null]]] && [4, [4, [5, null]]] || ![4, [4, [5, null]]] && ![4, [4, [5, null]]]) : is_string([4, [4, [5, null]]]) ? is_string([4, [4, [5, null]]]) && [4, [4, [5, null]]] === [4, [4, [5, null]]] : is_undefined([4, [4, [5, null]]]) ? is_undefined([4, [4, [5, null]]]) : is_function([4, [4, [5, null]]]) ? is_function([4, [4, [5, null]]]) && [4, [4, [5, null]]] === [4, [4, [5, null]]] : fals;
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_pair([4, [4, [5, null]]]) && equal(head([4, [4, [5, null]]]), head([4, [4, [5, null]]])) && equal(tail([4, [4, [5, null]]]), tail([4, [4, [5, null]]]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_pair([4, [4, [5, null]]]) && equal(head([4, [4, [5, null]]]), head([4, [4, [5, null]]])) && equal(tail([4, [4, [5, null]]]), tail([4, [4, [5, null]]]));
[beforeMarker] is_pair runs

true && equal(head([4, [4, [5, null]]]), head([4, [4, [5, null]]])) && equal(tail([4, [4, [5, null]]]), tail([4, [4, [5, null]]]));
[afterMarker] is_pair runs

true && equal(head([4, [4, [5, null]]]), head([4, [4, [5, null]]])) && equal(tail([4, [4, [5, null]]]), tail([4, [4, [5, null]]]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(head([4, [4, [5, null]]]), head([4, [4, [5, null]]])) && equal(tail([4, [4, [5, null]]]), tail([4, [4, [5, null]]]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(head([4, [4, [5, null]]]), head([4, [4, [5, null]]])) && equal(tail([4, [4, [5, null]]]), tail([4, [4, [5, null]]]));
[beforeMarker] head runs

equal(4, head([4, [4, [5, null]]])) && equal(tail([4, [4, [5, null]]]), tail([4, [4, [5, null]]]));
[afterMarker] head runs

equal(4, head([4, [4, [5, null]]])) && equal(tail([4, [4, [5, null]]]), tail([4, [4, [5, null]]]));
[beforeMarker] head runs

equal(4, 4) && equal(tail([4, [4, [5, null]]]), tail([4, [4, [5, null]]]));
[afterMarker] head runs

equal(4, 4) && equal(tail([4, [4, [5, null]]]), tail([4, [4, [5, null]]]));
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(4, 4) && equal(tail([4, [4, [5, null]]]), tail([4, [4, [5, null]]]));
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(4, 4) && equal(tail([4, [4, [5, null]]]), tail([4, [4, [5, null]]]));
[beforeMarker] 4, 4 substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair(4) ? is_pair(4) && equal(head(4), head(4)) && equal(tail(4), tail(4)) : is_null(4) ? is_null(4) : is_number(4) ? is_number(4) && 4 === 4 : is_boolean(4) ? is_boolean(4) && (4 && 4 || !4 && !4) : is_string(4) ? is_string(4) && 4 === 4 : is_undefined(4) ? is_undefined(4) : is_function(4) ? is_function(4) && 4 === 4 : fals) && equal(tail([4, [4, [5, null]]]), tail([4, [4, [5, null]]]));
[afterMarker] 4, 4 substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair(4) ? is_pair(4) && equal(head(4), head(4)) && equal(tail(4), tail(4)) : is_null(4) ? is_null(4) : is_number(4) ? is_number(4) && 4 === 4 : is_boolean(4) ? is_boolean(4) && (4 && 4 || !4 && !4) : is_string(4) ? is_string(4) && 4 === 4 : is_undefined(4) ? is_undefined(4) : is_function(4) ? is_function(4) && 4 === 4 : fals) && equal(tail([4, [4, [5, null]]]), tail([4, [4, [5, null]]]));
[beforeMarker] is_pair runs

(false ? is_pair(4) && equal(head(4), head(4)) && equal(tail(4), tail(4)) : is_null(4) ? is_null(4) : is_number(4) ? is_number(4) && 4 === 4 : is_boolean(4) ? is_boolean(4) && (4 && 4 || !4 && !4) : is_string(4) ? is_string(4) && 4 === 4 : is_undefined(4) ? is_undefined(4) : is_function(4) ? is_function(4) && 4 === 4 : fals) && equal(tail([4, [4, [5, null]]]), tail([4, [4, [5, null]]]));
[afterMarker] is_pair runs

(false ? is_pair(4) && equal(head(4), head(4)) && equal(tail(4), tail(4)) : is_null(4) ? is_null(4) : is_number(4) ? is_number(4) && 4 === 4 : is_boolean(4) ? is_boolean(4) && (4 && 4 || !4 && !4) : is_string(4) ? is_string(4) && 4 === 4 : is_undefined(4) ? is_undefined(4) : is_function(4) ? is_function(4) && 4 === 4 : fals) && equal(tail([4, [4, [5, null]]]), tail([4, [4, [5, null]]]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_null(4) ? is_null(4) : is_number(4) ? is_number(4) && 4 === 4 : is_boolean(4) ? is_boolean(4) && (4 && 4 || !4 && !4) : is_string(4) ? is_string(4) && 4 === 4 : is_undefined(4) ? is_undefined(4) : is_function(4) ? is_function(4) && 4 === 4 : fals) && equal(tail([4, [4, [5, null]]]), tail([4, [4, [5, null]]]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_null(4) ? is_null(4) : is_number(4) ? is_number(4) && 4 === 4 : is_boolean(4) ? is_boolean(4) && (4 && 4 || !4 && !4) : is_string(4) ? is_string(4) && 4 === 4 : is_undefined(4) ? is_undefined(4) : is_function(4) ? is_function(4) && 4 === 4 : fals) && equal(tail([4, [4, [5, null]]]), tail([4, [4, [5, null]]]));
[beforeMarker] is_null runs

(false ? is_null(4) : is_number(4) ? is_number(4) && 4 === 4 : is_boolean(4) ? is_boolean(4) && (4 && 4 || !4 && !4) : is_string(4) ? is_string(4) && 4 === 4 : is_undefined(4) ? is_undefined(4) : is_function(4) ? is_function(4) && 4 === 4 : fals) && equal(tail([4, [4, [5, null]]]), tail([4, [4, [5, null]]]));
[afterMarker] is_null runs

(false ? is_null(4) : is_number(4) ? is_number(4) && 4 === 4 : is_boolean(4) ? is_boolean(4) && (4 && 4 || !4 && !4) : is_string(4) ? is_string(4) && 4 === 4 : is_undefined(4) ? is_undefined(4) : is_function(4) ? is_function(4) && 4 === 4 : fals) && equal(tail([4, [4, [5, null]]]), tail([4, [4, [5, null]]]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_number(4) ? is_number(4) && 4 === 4 : is_boolean(4) ? is_boolean(4) && (4 && 4 || !4 && !4) : is_string(4) ? is_string(4) && 4 === 4 : is_undefined(4) ? is_undefined(4) : is_function(4) ? is_function(4) && 4 === 4 : fals) && equal(tail([4, [4, [5, null]]]), tail([4, [4, [5, null]]]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_number(4) ? is_number(4) && 4 === 4 : is_boolean(4) ? is_boolean(4) && (4 && 4 || !4 && !4) : is_string(4) ? is_string(4) && 4 === 4 : is_undefined(4) ? is_undefined(4) : is_function(4) ? is_function(4) && 4 === 4 : fals) && equal(tail([4, [4, [5, null]]]), tail([4, [4, [5, null]]]));
[beforeMarker] is_number runs

(true ? is_number(4) && 4 === 4 : is_boolean(4) ? is_boolean(4) && (4 && 4 || !4 && !4) : is_string(4) ? is_string(4) && 4 === 4 : is_undefined(4) ? is_undefined(4) : is_function(4) ? is_function(4) && 4 === 4 : fals) && equal(tail([4, [4, [5, null]]]), tail([4, [4, [5, null]]]));
[afterMarker] is_number runs

(true ? is_number(4) && 4 === 4 : is_boolean(4) ? is_boolean(4) && (4 && 4 || !4 && !4) : is_string(4) ? is_string(4) && 4 === 4 : is_undefined(4) ? is_undefined(4) : is_function(4) ? is_function(4) && 4 === 4 : fals) && equal(tail([4, [4, [5, null]]]), tail([4, [4, [5, null]]]));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_number(4) && 4 === 4 && equal(tail([4, [4, [5, null]]]), tail([4, [4, [5, null]]]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_number(4) && 4 === 4 && equal(tail([4, [4, [5, null]]]), tail([4, [4, [5, null]]]));
[beforeMarker] is_number runs

true && 4 === 4 && equal(tail([4, [4, [5, null]]]), tail([4, [4, [5, null]]]));
[afterMarker] is_number runs

true && 4 === 4 && equal(tail([4, [4, [5, null]]]), tail([4, [4, [5, null]]]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

4 === 4 && equal(tail([4, [4, [5, null]]]), tail([4, [4, [5, null]]]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

4 === 4 && equal(tail([4, [4, [5, null]]]), tail([4, [4, [5, null]]]));
[beforeMarker] Binary expression 4 === 4 evaluated

true && equal(tail([4, [4, [5, null]]]), tail([4, [4, [5, null]]]));
[afterMarker] Binary expression 4 === 4 evaluated

true && equal(tail([4, [4, [5, null]]]), tail([4, [4, [5, null]]]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(tail([4, [4, [5, null]]]), tail([4, [4, [5, null]]]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(tail([4, [4, [5, null]]]), tail([4, [4, [5, null]]]));
[beforeMarker] tail runs

equal([4, [5, null]], tail([4, [4, [5, null]]]));
[afterMarker] tail runs

equal([4, [5, null]], tail([4, [4, [5, null]]]));
[beforeMarker] tail runs

equal([4, [5, null]], [4, [5, null]]);
[afterMarker] tail runs

equal([4, [5, null]], [4, [5, null]]);
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)([4, [5, null]], [4, [5, null]]);
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)([4, [5, null]], [4, [5, null]]);
[beforeMarker] [4, [5, null]], [4, [5, null]] substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

is_pair([4, [5, null]]) ? is_pair([4, [5, null]]) && equal(head([4, [5, null]]), head([4, [5, null]])) && equal(tail([4, [5, null]]), tail([4, [5, null]])) : is_null([4, [5, null]]) ? is_null([4, [5, null]]) : is_number([4, [5, null]]) ? is_number([4, [5, null]]) && [4, [5, null]] === [4, [5, null]] : is_boolean([4, [5, null]]) ? is_boolean([4, [5, null]]) && ([4, [5, null]] && [4, [5, null]] || ![4, [5, null]] && ![4, [5, null]]) : is_string([4, [5, null]]) ? is_string([4, [5, null]]) && [4, [5, null]] === [4, [5, null]] : is_undefined([4, [5, null]]) ? is_undefined([4, [5, null]]) : is_function([4, [5, null]]) ? is_function([4, [5, null]]) && [4, [5, null]] === [4, [5, null]] : fals;
[afterMarker] [4, [5, null]], [4, [5, null]] substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

is_pair([4, [5, null]]) ? is_pair([4, [5, null]]) && equal(head([4, [5, null]]), head([4, [5, null]])) && equal(tail([4, [5, null]]), tail([4, [5, null]])) : is_null([4, [5, null]]) ? is_null([4, [5, null]]) : is_number([4, [5, null]]) ? is_number([4, [5, null]]) && [4, [5, null]] === [4, [5, null]] : is_boolean([4, [5, null]]) ? is_boolean([4, [5, null]]) && ([4, [5, null]] && [4, [5, null]] || ![4, [5, null]] && ![4, [5, null]]) : is_string([4, [5, null]]) ? is_string([4, [5, null]]) && [4, [5, null]] === [4, [5, null]] : is_undefined([4, [5, null]]) ? is_undefined([4, [5, null]]) : is_function([4, [5, null]]) ? is_function([4, [5, null]]) && [4, [5, null]] === [4, [5, null]] : fals;
[beforeMarker] is_pair runs

true ? is_pair([4, [5, null]]) && equal(head([4, [5, null]]), head([4, [5, null]])) && equal(tail([4, [5, null]]), tail([4, [5, null]])) : is_null([4, [5, null]]) ? is_null([4, [5, null]]) : is_number([4, [5, null]]) ? is_number([4, [5, null]]) && [4, [5, null]] === [4, [5, null]] : is_boolean([4, [5, null]]) ? is_boolean([4, [5, null]]) && ([4, [5, null]] && [4, [5, null]] || ![4, [5, null]] && ![4, [5, null]]) : is_string([4, [5, null]]) ? is_string([4, [5, null]]) && [4, [5, null]] === [4, [5, null]] : is_undefined([4, [5, null]]) ? is_undefined([4, [5, null]]) : is_function([4, [5, null]]) ? is_function([4, [5, null]]) && [4, [5, null]] === [4, [5, null]] : fals;
[afterMarker] is_pair runs

true ? is_pair([4, [5, null]]) && equal(head([4, [5, null]]), head([4, [5, null]])) && equal(tail([4, [5, null]]), tail([4, [5, null]])) : is_null([4, [5, null]]) ? is_null([4, [5, null]]) : is_number([4, [5, null]]) ? is_number([4, [5, null]]) && [4, [5, null]] === [4, [5, null]] : is_boolean([4, [5, null]]) ? is_boolean([4, [5, null]]) && ([4, [5, null]] && [4, [5, null]] || ![4, [5, null]] && ![4, [5, null]]) : is_string([4, [5, null]]) ? is_string([4, [5, null]]) && [4, [5, null]] === [4, [5, null]] : is_undefined([4, [5, null]]) ? is_undefined([4, [5, null]]) : is_function([4, [5, null]]) ? is_function([4, [5, null]]) && [4, [5, null]] === [4, [5, null]] : fals;
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_pair([4, [5, null]]) && equal(head([4, [5, null]]), head([4, [5, null]])) && equal(tail([4, [5, null]]), tail([4, [5, null]]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_pair([4, [5, null]]) && equal(head([4, [5, null]]), head([4, [5, null]])) && equal(tail([4, [5, null]]), tail([4, [5, null]]));
[beforeMarker] is_pair runs

true && equal(head([4, [5, null]]), head([4, [5, null]])) && equal(tail([4, [5, null]]), tail([4, [5, null]]));
[afterMarker] is_pair runs

true && equal(head([4, [5, null]]), head([4, [5, null]])) && equal(tail([4, [5, null]]), tail([4, [5, null]]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(head([4, [5, null]]), head([4, [5, null]])) && equal(tail([4, [5, null]]), tail([4, [5, null]]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(head([4, [5, null]]), head([4, [5, null]])) && equal(tail([4, [5, null]]), tail([4, [5, null]]));
[beforeMarker] head runs

equal(4, head([4, [5, null]])) && equal(tail([4, [5, null]]), tail([4, [5, null]]));
[afterMarker] head runs

equal(4, head([4, [5, null]])) && equal(tail([4, [5, null]]), tail([4, [5, null]]));
[beforeMarker] head runs

equal(4, 4) && equal(tail([4, [5, null]]), tail([4, [5, null]]));
[afterMarker] head runs

equal(4, 4) && equal(tail([4, [5, null]]), tail([4, [5, null]]));
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(4, 4) && equal(tail([4, [5, null]]), tail([4, [5, null]]));
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(4, 4) && equal(tail([4, [5, null]]), tail([4, [5, null]]));
[beforeMarker] 4, 4 substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair(4) ? is_pair(4) && equal(head(4), head(4)) && equal(tail(4), tail(4)) : is_null(4) ? is_null(4) : is_number(4) ? is_number(4) && 4 === 4 : is_boolean(4) ? is_boolean(4) && (4 && 4 || !4 && !4) : is_string(4) ? is_string(4) && 4 === 4 : is_undefined(4) ? is_undefined(4) : is_function(4) ? is_function(4) && 4 === 4 : fals) && equal(tail([4, [5, null]]), tail([4, [5, null]]));
[afterMarker] 4, 4 substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair(4) ? is_pair(4) && equal(head(4), head(4)) && equal(tail(4), tail(4)) : is_null(4) ? is_null(4) : is_number(4) ? is_number(4) && 4 === 4 : is_boolean(4) ? is_boolean(4) && (4 && 4 || !4 && !4) : is_string(4) ? is_string(4) && 4 === 4 : is_undefined(4) ? is_undefined(4) : is_function(4) ? is_function(4) && 4 === 4 : fals) && equal(tail([4, [5, null]]), tail([4, [5, null]]));
[beforeMarker] is_pair runs

(false ? is_pair(4) && equal(head(4), head(4)) && equal(tail(4), tail(4)) : is_null(4) ? is_null(4) : is_number(4) ? is_number(4) && 4 === 4 : is_boolean(4) ? is_boolean(4) && (4 && 4 || !4 && !4) : is_string(4) ? is_string(4) && 4 === 4 : is_undefined(4) ? is_undefined(4) : is_function(4) ? is_function(4) && 4 === 4 : fals) && equal(tail([4, [5, null]]), tail([4, [5, null]]));
[afterMarker] is_pair runs

(false ? is_pair(4) && equal(head(4), head(4)) && equal(tail(4), tail(4)) : is_null(4) ? is_null(4) : is_number(4) ? is_number(4) && 4 === 4 : is_boolean(4) ? is_boolean(4) && (4 && 4 || !4 && !4) : is_string(4) ? is_string(4) && 4 === 4 : is_undefined(4) ? is_undefined(4) : is_function(4) ? is_function(4) && 4 === 4 : fals) && equal(tail([4, [5, null]]), tail([4, [5, null]]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_null(4) ? is_null(4) : is_number(4) ? is_number(4) && 4 === 4 : is_boolean(4) ? is_boolean(4) && (4 && 4 || !4 && !4) : is_string(4) ? is_string(4) && 4 === 4 : is_undefined(4) ? is_undefined(4) : is_function(4) ? is_function(4) && 4 === 4 : fals) && equal(tail([4, [5, null]]), tail([4, [5, null]]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_null(4) ? is_null(4) : is_number(4) ? is_number(4) && 4 === 4 : is_boolean(4) ? is_boolean(4) && (4 && 4 || !4 && !4) : is_string(4) ? is_string(4) && 4 === 4 : is_undefined(4) ? is_undefined(4) : is_function(4) ? is_function(4) && 4 === 4 : fals) && equal(tail([4, [5, null]]), tail([4, [5, null]]));
[beforeMarker] is_null runs

(false ? is_null(4) : is_number(4) ? is_number(4) && 4 === 4 : is_boolean(4) ? is_boolean(4) && (4 && 4 || !4 && !4) : is_string(4) ? is_string(4) && 4 === 4 : is_undefined(4) ? is_undefined(4) : is_function(4) ? is_function(4) && 4 === 4 : fals) && equal(tail([4, [5, null]]), tail([4, [5, null]]));
[afterMarker] is_null runs

(false ? is_null(4) : is_number(4) ? is_number(4) && 4 === 4 : is_boolean(4) ? is_boolean(4) && (4 && 4 || !4 && !4) : is_string(4) ? is_string(4) && 4 === 4 : is_undefined(4) ? is_undefined(4) : is_function(4) ? is_function(4) && 4 === 4 : fals) && equal(tail([4, [5, null]]), tail([4, [5, null]]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_number(4) ? is_number(4) && 4 === 4 : is_boolean(4) ? is_boolean(4) && (4 && 4 || !4 && !4) : is_string(4) ? is_string(4) && 4 === 4 : is_undefined(4) ? is_undefined(4) : is_function(4) ? is_function(4) && 4 === 4 : fals) && equal(tail([4, [5, null]]), tail([4, [5, null]]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_number(4) ? is_number(4) && 4 === 4 : is_boolean(4) ? is_boolean(4) && (4 && 4 || !4 && !4) : is_string(4) ? is_string(4) && 4 === 4 : is_undefined(4) ? is_undefined(4) : is_function(4) ? is_function(4) && 4 === 4 : fals) && equal(tail([4, [5, null]]), tail([4, [5, null]]));
[beforeMarker] is_number runs

(true ? is_number(4) && 4 === 4 : is_boolean(4) ? is_boolean(4) && (4 && 4 || !4 && !4) : is_string(4) ? is_string(4) && 4 === 4 : is_undefined(4) ? is_undefined(4) : is_function(4) ? is_function(4) && 4 === 4 : fals) && equal(tail([4, [5, null]]), tail([4, [5, null]]));
[afterMarker] is_number runs

(true ? is_number(4) && 4 === 4 : is_boolean(4) ? is_boolean(4) && (4 && 4 || !4 && !4) : is_string(4) ? is_string(4) && 4 === 4 : is_undefined(4) ? is_undefined(4) : is_function(4) ? is_function(4) && 4 === 4 : fals) && equal(tail([4, [5, null]]), tail([4, [5, null]]));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_number(4) && 4 === 4 && equal(tail([4, [5, null]]), tail([4, [5, null]]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_number(4) && 4 === 4 && equal(tail([4, [5, null]]), tail([4, [5, null]]));
[beforeMarker] is_number runs

true && 4 === 4 && equal(tail([4, [5, null]]), tail([4, [5, null]]));
[afterMarker] is_number runs

true && 4 === 4 && equal(tail([4, [5, null]]), tail([4, [5, null]]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

4 === 4 && equal(tail([4, [5, null]]), tail([4, [5, null]]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

4 === 4 && equal(tail([4, [5, null]]), tail([4, [5, null]]));
[beforeMarker] Binary expression 4 === 4 evaluated

true && equal(tail([4, [5, null]]), tail([4, [5, null]]));
[afterMarker] Binary expression 4 === 4 evaluated

true && equal(tail([4, [5, null]]), tail([4, [5, null]]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(tail([4, [5, null]]), tail([4, [5, null]]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(tail([4, [5, null]]), tail([4, [5, null]]));
[beforeMarker] tail runs

equal([5, null], tail([4, [5, null]]));
[afterMarker] tail runs

equal([5, null], tail([4, [5, null]]));
[beforeMarker] tail runs

equal([5, null], [5, null]);
[afterMarker] tail runs

equal([5, null], [5, null]);
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)([5, null], [5, null]);
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)([5, null], [5, null]);
[beforeMarker] [5, null], [5, null] substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

is_pair([5, null]) ? is_pair([5, null]) && equal(head([5, null]), head([5, null])) && equal(tail([5, null]), tail([5, null])) : is_null([5, null]) ? is_null([5, null]) : is_number([5, null]) ? is_number([5, null]) && [5, null] === [5, null] : is_boolean([5, null]) ? is_boolean([5, null]) && ([5, null] && [5, null] || ![5, null] && ![5, null]) : is_string([5, null]) ? is_string([5, null]) && [5, null] === [5, null] : is_undefined([5, null]) ? is_undefined([5, null]) : is_function([5, null]) ? is_function([5, null]) && [5, null] === [5, null] : fals;
[afterMarker] [5, null], [5, null] substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

is_pair([5, null]) ? is_pair([5, null]) && equal(head([5, null]), head([5, null])) && equal(tail([5, null]), tail([5, null])) : is_null([5, null]) ? is_null([5, null]) : is_number([5, null]) ? is_number([5, null]) && [5, null] === [5, null] : is_boolean([5, null]) ? is_boolean([5, null]) && ([5, null] && [5, null] || ![5, null] && ![5, null]) : is_string([5, null]) ? is_string([5, null]) && [5, null] === [5, null] : is_undefined([5, null]) ? is_undefined([5, null]) : is_function([5, null]) ? is_function([5, null]) && [5, null] === [5, null] : fals;
[beforeMarker] is_pair runs

true ? is_pair([5, null]) && equal(head([5, null]), head([5, null])) && equal(tail([5, null]), tail([5, null])) : is_null([5, null]) ? is_null([5, null]) : is_number([5, null]) ? is_number([5, null]) && [5, null] === [5, null] : is_boolean([5, null]) ? is_boolean([5, null]) && ([5, null] && [5, null] || ![5, null] && ![5, null]) : is_string([5, null]) ? is_string([5, null]) && [5, null] === [5, null] : is_undefined([5, null]) ? is_undefined([5, null]) : is_function([5, null]) ? is_function([5, null]) && [5, null] === [5, null] : fals;
[afterMarker] is_pair runs

true ? is_pair([5, null]) && equal(head([5, null]), head([5, null])) && equal(tail([5, null]), tail([5, null])) : is_null([5, null]) ? is_null([5, null]) : is_number([5, null]) ? is_number([5, null]) && [5, null] === [5, null] : is_boolean([5, null]) ? is_boolean([5, null]) && ([5, null] && [5, null] || ![5, null] && ![5, null]) : is_string([5, null]) ? is_string([5, null]) && [5, null] === [5, null] : is_undefined([5, null]) ? is_undefined([5, null]) : is_function([5, null]) ? is_function([5, null]) && [5, null] === [5, null] : fals;
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_pair([5, null]) && equal(head([5, null]), head([5, null])) && equal(tail([5, null]), tail([5, null]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_pair([5, null]) && equal(head([5, null]), head([5, null])) && equal(tail([5, null]), tail([5, null]));
[beforeMarker] is_pair runs

true && equal(head([5, null]), head([5, null])) && equal(tail([5, null]), tail([5, null]));
[afterMarker] is_pair runs

true && equal(head([5, null]), head([5, null])) && equal(tail([5, null]), tail([5, null]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(head([5, null]), head([5, null])) && equal(tail([5, null]), tail([5, null]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(head([5, null]), head([5, null])) && equal(tail([5, null]), tail([5, null]));
[beforeMarker] head runs

equal(5, head([5, null])) && equal(tail([5, null]), tail([5, null]));
[afterMarker] head runs

equal(5, head([5, null])) && equal(tail([5, null]), tail([5, null]));
[beforeMarker] head runs

equal(5, 5) && equal(tail([5, null]), tail([5, null]));
[afterMarker] head runs

equal(5, 5) && equal(tail([5, null]), tail([5, null]));
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(5, 5) && equal(tail([5, null]), tail([5, null]));
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(5, 5) && equal(tail([5, null]), tail([5, null]));
[beforeMarker] 5, 5 substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair(5) ? is_pair(5) && equal(head(5), head(5)) && equal(tail(5), tail(5)) : is_null(5) ? is_null(5) : is_number(5) ? is_number(5) && 5 === 5 : is_boolean(5) ? is_boolean(5) && (5 && 5 || !5 && !5) : is_string(5) ? is_string(5) && 5 === 5 : is_undefined(5) ? is_undefined(5) : is_function(5) ? is_function(5) && 5 === 5 : fals) && equal(tail([5, null]), tail([5, null]));
[afterMarker] 5, 5 substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair(5) ? is_pair(5) && equal(head(5), head(5)) && equal(tail(5), tail(5)) : is_null(5) ? is_null(5) : is_number(5) ? is_number(5) && 5 === 5 : is_boolean(5) ? is_boolean(5) && (5 && 5 || !5 && !5) : is_string(5) ? is_string(5) && 5 === 5 : is_undefined(5) ? is_undefined(5) : is_function(5) ? is_function(5) && 5 === 5 : fals) && equal(tail([5, null]), tail([5, null]));
[beforeMarker] is_pair runs

(false ? is_pair(5) && equal(head(5), head(5)) && equal(tail(5), tail(5)) : is_null(5) ? is_null(5) : is_number(5) ? is_number(5) && 5 === 5 : is_boolean(5) ? is_boolean(5) && (5 && 5 || !5 && !5) : is_string(5) ? is_string(5) && 5 === 5 : is_undefined(5) ? is_undefined(5) : is_function(5) ? is_function(5) && 5 === 5 : fals) && equal(tail([5, null]), tail([5, null]));
[afterMarker] is_pair runs

(false ? is_pair(5) && equal(head(5), head(5)) && equal(tail(5), tail(5)) : is_null(5) ? is_null(5) : is_number(5) ? is_number(5) && 5 === 5 : is_boolean(5) ? is_boolean(5) && (5 && 5 || !5 && !5) : is_string(5) ? is_string(5) && 5 === 5 : is_undefined(5) ? is_undefined(5) : is_function(5) ? is_function(5) && 5 === 5 : fals) && equal(tail([5, null]), tail([5, null]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_null(5) ? is_null(5) : is_number(5) ? is_number(5) && 5 === 5 : is_boolean(5) ? is_boolean(5) && (5 && 5 || !5 && !5) : is_string(5) ? is_string(5) && 5 === 5 : is_undefined(5) ? is_undefined(5) : is_function(5) ? is_function(5) && 5 === 5 : fals) && equal(tail([5, null]), tail([5, null]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_null(5) ? is_null(5) : is_number(5) ? is_number(5) && 5 === 5 : is_boolean(5) ? is_boolean(5) && (5 && 5 || !5 && !5) : is_string(5) ? is_string(5) && 5 === 5 : is_undefined(5) ? is_undefined(5) : is_function(5) ? is_function(5) && 5 === 5 : fals) && equal(tail([5, null]), tail([5, null]));
[beforeMarker] is_null runs

(false ? is_null(5) : is_number(5) ? is_number(5) && 5 === 5 : is_boolean(5) ? is_boolean(5) && (5 && 5 || !5 && !5) : is_string(5) ? is_string(5) && 5 === 5 : is_undefined(5) ? is_undefined(5) : is_function(5) ? is_function(5) && 5 === 5 : fals) && equal(tail([5, null]), tail([5, null]));
[afterMarker] is_null runs

(false ? is_null(5) : is_number(5) ? is_number(5) && 5 === 5 : is_boolean(5) ? is_boolean(5) && (5 && 5 || !5 && !5) : is_string(5) ? is_string(5) && 5 === 5 : is_undefined(5) ? is_undefined(5) : is_function(5) ? is_function(5) && 5 === 5 : fals) && equal(tail([5, null]), tail([5, null]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_number(5) ? is_number(5) && 5 === 5 : is_boolean(5) ? is_boolean(5) && (5 && 5 || !5 && !5) : is_string(5) ? is_string(5) && 5 === 5 : is_undefined(5) ? is_undefined(5) : is_function(5) ? is_function(5) && 5 === 5 : fals) && equal(tail([5, null]), tail([5, null]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_number(5) ? is_number(5) && 5 === 5 : is_boolean(5) ? is_boolean(5) && (5 && 5 || !5 && !5) : is_string(5) ? is_string(5) && 5 === 5 : is_undefined(5) ? is_undefined(5) : is_function(5) ? is_function(5) && 5 === 5 : fals) && equal(tail([5, null]), tail([5, null]));
[beforeMarker] is_number runs

(true ? is_number(5) && 5 === 5 : is_boolean(5) ? is_boolean(5) && (5 && 5 || !5 && !5) : is_string(5) ? is_string(5) && 5 === 5 : is_undefined(5) ? is_undefined(5) : is_function(5) ? is_function(5) && 5 === 5 : fals) && equal(tail([5, null]), tail([5, null]));
[afterMarker] is_number runs

(true ? is_number(5) && 5 === 5 : is_boolean(5) ? is_boolean(5) && (5 && 5 || !5 && !5) : is_string(5) ? is_string(5) && 5 === 5 : is_undefined(5) ? is_undefined(5) : is_function(5) ? is_function(5) && 5 === 5 : fals) && equal(tail([5, null]), tail([5, null]));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_number(5) && 5 === 5 && equal(tail([5, null]), tail([5, null]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_number(5) && 5 === 5 && equal(tail([5, null]), tail([5, null]));
[beforeMarker] is_number runs

true && 5 === 5 && equal(tail([5, null]), tail([5, null]));
[afterMarker] is_number runs

true && 5 === 5 && equal(tail([5, null]), tail([5, null]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

5 === 5 && equal(tail([5, null]), tail([5, null]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

5 === 5 && equal(tail([5, null]), tail([5, null]));
[beforeMarker] Binary expression 5 === 5 evaluated

true && equal(tail([5, null]), tail([5, null]));
[afterMarker] Binary expression 5 === 5 evaluated

true && equal(tail([5, null]), tail([5, null]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(tail([5, null]), tail([5, null]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(tail([5, null]), tail([5, null]));
[beforeMarker] tail runs

equal(null, tail([5, null]));
[afterMarker] tail runs

equal(null, tail([5, null]));
[beforeMarker] tail runs

equal(null, null);
[afterMarker] tail runs

equal(null, null);
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(null, null);
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(null, null);
[beforeMarker] null, null substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

is_pair(null) ? is_pair(null) && equal(head(null), head(null)) && equal(tail(null), tail(null)) : is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals;
[afterMarker] null, null substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

is_pair(null) ? is_pair(null) && equal(head(null), head(null)) && equal(tail(null), tail(null)) : is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals;
[beforeMarker] is_pair runs

false ? is_pair(null) && equal(head(null), head(null)) && equal(tail(null), tail(null)) : is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals;
[afterMarker] is_pair runs

false ? is_pair(null) && equal(head(null), head(null)) && equal(tail(null), tail(null)) : is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals;
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals;
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals;
[beforeMarker] is_null runs

true ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals;
[afterMarker] is_null runs

true ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals;
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_null(null);
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_null(null);
[beforeMarker] is_null runs

true;
[afterMarker] is_null runs

true;
[noMarker] Evaluation complete
"
`;

exports[`List operations is_null 1`] = `
"is_null(tail(list(1)));
[noMarker] Start of evaluation

is_null(tail(list(1)));
[beforeMarker] list runs

is_null(tail([1, null]));
[afterMarker] list runs

is_null(tail([1, null]));
[beforeMarker] tail runs

is_null(null);
[afterMarker] tail runs

is_null(null);
[beforeMarker] is_null runs

true;
[afterMarker] is_null runs

true;
[noMarker] Evaluation complete
"
`;

exports[`List operations map on list 1`] = `
"equal(map(x => 2 * x, list(1, 2, 3)), list(2, 4, 6));
[noMarker] Start of evaluation

equal(map(x => 2 * x, list(1, 2, 3)), list(2, 4, 6));
[beforeMarker] list runs

equal(map(x => 2 * x, [1, [2, [3, null]]]), list(2, 4, 6));
[afterMarker] list runs

equal(map(x => 2 * x, [1, [2, [3, null]]]), list(2, 4, 6));
[beforeMarker] map runs

equal($map(x => 2 * x, [1, [2, [3, null]]], null), list(2, 4, 6));
[afterMarker] map runs

equal($map(x => 2 * x, [1, [2, [3, null]]], null), list(2, 4, 6));
[beforeMarker] $map runs

equal(((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => 2 * x, [1, [2, [3, null]]], null), list(2, 4, 6));
[afterMarker] $map runs

equal(((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => 2 * x, [1, [2, [3, null]]], null), list(2, 4, 6));
[beforeMarker] x => 2 * x, [1, [2, [3, null]]], null substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

equal(is_null([1, [2, [3, null]]]) ? reverse(null) : $map(x => 2 * x, tail([1, [2, [3, null]]]), pair((x => 2 * x)(head([1, [2, [3, null]]])), null)), list(2, 4, 6));
[afterMarker] x => 2 * x, [1, [2, [3, null]]], null substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

equal(is_null([1, [2, [3, null]]]) ? reverse(null) : $map(x => 2 * x, tail([1, [2, [3, null]]]), pair((x => 2 * x)(head([1, [2, [3, null]]])), null)), list(2, 4, 6));
[beforeMarker] is_null runs

equal(false ? reverse(null) : $map(x => 2 * x, tail([1, [2, [3, null]]]), pair((x => 2 * x)(head([1, [2, [3, null]]])), null)), list(2, 4, 6));
[afterMarker] is_null runs

equal(false ? reverse(null) : $map(x => 2 * x, tail([1, [2, [3, null]]]), pair((x => 2 * x)(head([1, [2, [3, null]]])), null)), list(2, 4, 6));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal($map(x => 2 * x, tail([1, [2, [3, null]]]), pair((x => 2 * x)(head([1, [2, [3, null]]])), null)), list(2, 4, 6));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal($map(x => 2 * x, tail([1, [2, [3, null]]]), pair((x => 2 * x)(head([1, [2, [3, null]]])), null)), list(2, 4, 6));
[beforeMarker] tail runs

equal($map(x => 2 * x, [2, [3, null]], pair((x => 2 * x)(head([1, [2, [3, null]]])), null)), list(2, 4, 6));
[afterMarker] tail runs

equal($map(x => 2 * x, [2, [3, null]], pair((x => 2 * x)(head([1, [2, [3, null]]])), null)), list(2, 4, 6));
[beforeMarker] head runs

equal($map(x => 2 * x, [2, [3, null]], pair((x => 2 * x)(1), null)), list(2, 4, 6));
[afterMarker] head runs

equal($map(x => 2 * x, [2, [3, null]], pair((x => 2 * x)(1), null)), list(2, 4, 6));
[beforeMarker] 1 substituted into x of x => 2 * x

equal($map(x => 2 * x, [2, [3, null]], pair(2 * 1, null)), list(2, 4, 6));
[afterMarker] 1 substituted into x of x => 2 * x

equal($map(x => 2 * x, [2, [3, null]], pair(2 * 1, null)), list(2, 4, 6));
[beforeMarker] Binary expression 2 * 1 evaluated

equal($map(x => 2 * x, [2, [3, null]], pair(2, null)), list(2, 4, 6));
[afterMarker] Binary expression 2 * 1 evaluated

equal($map(x => 2 * x, [2, [3, null]], pair(2, null)), list(2, 4, 6));
[beforeMarker] pair runs

equal($map(x => 2 * x, [2, [3, null]], [2, null]), list(2, 4, 6));
[afterMarker] pair runs

equal($map(x => 2 * x, [2, [3, null]], [2, null]), list(2, 4, 6));
[beforeMarker] $map runs

equal(((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => 2 * x, [2, [3, null]], [2, null]), list(2, 4, 6));
[afterMarker] $map runs

equal(((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => 2 * x, [2, [3, null]], [2, null]), list(2, 4, 6));
[beforeMarker] x => 2 * x, [2, [3, null]], [2, null] substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

equal(is_null([2, [3, null]]) ? reverse([2, null]) : $map(x => 2 * x, tail([2, [3, null]]), pair((x => 2 * x)(head([2, [3, null]])), [2, null])), list(2, 4, 6));
[afterMarker] x => 2 * x, [2, [3, null]], [2, null] substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

equal(is_null([2, [3, null]]) ? reverse([2, null]) : $map(x => 2 * x, tail([2, [3, null]]), pair((x => 2 * x)(head([2, [3, null]])), [2, null])), list(2, 4, 6));
[beforeMarker] is_null runs

equal(false ? reverse([2, null]) : $map(x => 2 * x, tail([2, [3, null]]), pair((x => 2 * x)(head([2, [3, null]])), [2, null])), list(2, 4, 6));
[afterMarker] is_null runs

equal(false ? reverse([2, null]) : $map(x => 2 * x, tail([2, [3, null]]), pair((x => 2 * x)(head([2, [3, null]])), [2, null])), list(2, 4, 6));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal($map(x => 2 * x, tail([2, [3, null]]), pair((x => 2 * x)(head([2, [3, null]])), [2, null])), list(2, 4, 6));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal($map(x => 2 * x, tail([2, [3, null]]), pair((x => 2 * x)(head([2, [3, null]])), [2, null])), list(2, 4, 6));
[beforeMarker] tail runs

equal($map(x => 2 * x, [3, null], pair((x => 2 * x)(head([2, [3, null]])), [2, null])), list(2, 4, 6));
[afterMarker] tail runs

equal($map(x => 2 * x, [3, null], pair((x => 2 * x)(head([2, [3, null]])), [2, null])), list(2, 4, 6));
[beforeMarker] head runs

equal($map(x => 2 * x, [3, null], pair((x => 2 * x)(2), [2, null])), list(2, 4, 6));
[afterMarker] head runs

equal($map(x => 2 * x, [3, null], pair((x => 2 * x)(2), [2, null])), list(2, 4, 6));
[beforeMarker] 2 substituted into x of x => 2 * x

equal($map(x => 2 * x, [3, null], pair(2 * 2, [2, null])), list(2, 4, 6));
[afterMarker] 2 substituted into x of x => 2 * x

equal($map(x => 2 * x, [3, null], pair(2 * 2, [2, null])), list(2, 4, 6));
[beforeMarker] Binary expression 2 * 2 evaluated

equal($map(x => 2 * x, [3, null], pair(4, [2, null])), list(2, 4, 6));
[afterMarker] Binary expression 2 * 2 evaluated

equal($map(x => 2 * x, [3, null], pair(4, [2, null])), list(2, 4, 6));
[beforeMarker] pair runs

equal($map(x => 2 * x, [3, null], [4, [2, null]]), list(2, 4, 6));
[afterMarker] pair runs

equal($map(x => 2 * x, [3, null], [4, [2, null]]), list(2, 4, 6));
[beforeMarker] $map runs

equal(((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => 2 * x, [3, null], [4, [2, null]]), list(2, 4, 6));
[afterMarker] $map runs

equal(((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => 2 * x, [3, null], [4, [2, null]]), list(2, 4, 6));
[beforeMarker] x => 2 * x, [3, null], [4, [2, null]] substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

equal(is_null([3, null]) ? reverse([4, [2, null]]) : $map(x => 2 * x, tail([3, null]), pair((x => 2 * x)(head([3, null])), [4, [2, null]])), list(2, 4, 6));
[afterMarker] x => 2 * x, [3, null], [4, [2, null]] substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

equal(is_null([3, null]) ? reverse([4, [2, null]]) : $map(x => 2 * x, tail([3, null]), pair((x => 2 * x)(head([3, null])), [4, [2, null]])), list(2, 4, 6));
[beforeMarker] is_null runs

equal(false ? reverse([4, [2, null]]) : $map(x => 2 * x, tail([3, null]), pair((x => 2 * x)(head([3, null])), [4, [2, null]])), list(2, 4, 6));
[afterMarker] is_null runs

equal(false ? reverse([4, [2, null]]) : $map(x => 2 * x, tail([3, null]), pair((x => 2 * x)(head([3, null])), [4, [2, null]])), list(2, 4, 6));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal($map(x => 2 * x, tail([3, null]), pair((x => 2 * x)(head([3, null])), [4, [2, null]])), list(2, 4, 6));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal($map(x => 2 * x, tail([3, null]), pair((x => 2 * x)(head([3, null])), [4, [2, null]])), list(2, 4, 6));
[beforeMarker] tail runs

equal($map(x => 2 * x, null, pair((x => 2 * x)(head([3, null])), [4, [2, null]])), list(2, 4, 6));
[afterMarker] tail runs

equal($map(x => 2 * x, null, pair((x => 2 * x)(head([3, null])), [4, [2, null]])), list(2, 4, 6));
[beforeMarker] head runs

equal($map(x => 2 * x, null, pair((x => 2 * x)(3), [4, [2, null]])), list(2, 4, 6));
[afterMarker] head runs

equal($map(x => 2 * x, null, pair((x => 2 * x)(3), [4, [2, null]])), list(2, 4, 6));
[beforeMarker] 3 substituted into x of x => 2 * x

equal($map(x => 2 * x, null, pair(2 * 3, [4, [2, null]])), list(2, 4, 6));
[afterMarker] 3 substituted into x of x => 2 * x

equal($map(x => 2 * x, null, pair(2 * 3, [4, [2, null]])), list(2, 4, 6));
[beforeMarker] Binary expression 2 * 3 evaluated

equal($map(x => 2 * x, null, pair(6, [4, [2, null]])), list(2, 4, 6));
[afterMarker] Binary expression 2 * 3 evaluated

equal($map(x => 2 * x, null, pair(6, [4, [2, null]])), list(2, 4, 6));
[beforeMarker] pair runs

equal($map(x => 2 * x, null, [6, [4, [2, null]]]), list(2, 4, 6));
[afterMarker] pair runs

equal($map(x => 2 * x, null, [6, [4, [2, null]]]), list(2, 4, 6));
[beforeMarker] $map runs

equal(((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => 2 * x, null, [6, [4, [2, null]]]), list(2, 4, 6));
[afterMarker] $map runs

equal(((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => 2 * x, null, [6, [4, [2, null]]]), list(2, 4, 6));
[beforeMarker] x => 2 * x, null, [6, [4, [2, null]]] substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

equal(is_null(null) ? reverse([6, [4, [2, null]]]) : $map(x => 2 * x, tail(null), pair((x => 2 * x)(head(null)), [6, [4, [2, null]]])), list(2, 4, 6));
[afterMarker] x => 2 * x, null, [6, [4, [2, null]]] substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

equal(is_null(null) ? reverse([6, [4, [2, null]]]) : $map(x => 2 * x, tail(null), pair((x => 2 * x)(head(null)), [6, [4, [2, null]]])), list(2, 4, 6));
[beforeMarker] is_null runs

equal(true ? reverse([6, [4, [2, null]]]) : $map(x => 2 * x, tail(null), pair((x => 2 * x)(head(null)), [6, [4, [2, null]]])), list(2, 4, 6));
[afterMarker] is_null runs

equal(true ? reverse([6, [4, [2, null]]]) : $map(x => 2 * x, tail(null), pair((x => 2 * x)(head(null)), [6, [4, [2, null]]])), list(2, 4, 6));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

equal(reverse([6, [4, [2, null]]]), list(2, 4, 6));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

equal(reverse([6, [4, [2, null]]]), list(2, 4, 6));
[beforeMarker] reverse runs

equal($reverse([6, [4, [2, null]]], null), list(2, 4, 6));
[afterMarker] reverse runs

equal($reverse([6, [4, [2, null]]], null), list(2, 4, 6));
[beforeMarker] $reverse runs

equal(((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([6, [4, [2, null]]], null), list(2, 4, 6));
[afterMarker] $reverse runs

equal(((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([6, [4, [2, null]]], null), list(2, 4, 6));
[beforeMarker] [6, [4, [2, null]]], null substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

equal(is_null([6, [4, [2, null]]]) ? null : $reverse(tail([6, [4, [2, null]]]), pair(head([6, [4, [2, null]]]), null)), list(2, 4, 6));
[afterMarker] [6, [4, [2, null]]], null substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

equal(is_null([6, [4, [2, null]]]) ? null : $reverse(tail([6, [4, [2, null]]]), pair(head([6, [4, [2, null]]]), null)), list(2, 4, 6));
[beforeMarker] is_null runs

equal(false ? null : $reverse(tail([6, [4, [2, null]]]), pair(head([6, [4, [2, null]]]), null)), list(2, 4, 6));
[afterMarker] is_null runs

equal(false ? null : $reverse(tail([6, [4, [2, null]]]), pair(head([6, [4, [2, null]]]), null)), list(2, 4, 6));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal($reverse(tail([6, [4, [2, null]]]), pair(head([6, [4, [2, null]]]), null)), list(2, 4, 6));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal($reverse(tail([6, [4, [2, null]]]), pair(head([6, [4, [2, null]]]), null)), list(2, 4, 6));
[beforeMarker] tail runs

equal($reverse([4, [2, null]], pair(head([6, [4, [2, null]]]), null)), list(2, 4, 6));
[afterMarker] tail runs

equal($reverse([4, [2, null]], pair(head([6, [4, [2, null]]]), null)), list(2, 4, 6));
[beforeMarker] head runs

equal($reverse([4, [2, null]], pair(6, null)), list(2, 4, 6));
[afterMarker] head runs

equal($reverse([4, [2, null]], pair(6, null)), list(2, 4, 6));
[beforeMarker] pair runs

equal($reverse([4, [2, null]], [6, null]), list(2, 4, 6));
[afterMarker] pair runs

equal($reverse([4, [2, null]], [6, null]), list(2, 4, 6));
[beforeMarker] $reverse runs

equal(((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([4, [2, null]], [6, null]), list(2, 4, 6));
[afterMarker] $reverse runs

equal(((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([4, [2, null]], [6, null]), list(2, 4, 6));
[beforeMarker] [4, [2, null]], [6, null] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

equal(is_null([4, [2, null]]) ? [6, null] : $reverse(tail([4, [2, null]]), pair(head([4, [2, null]]), [6, null])), list(2, 4, 6));
[afterMarker] [4, [2, null]], [6, null] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

equal(is_null([4, [2, null]]) ? [6, null] : $reverse(tail([4, [2, null]]), pair(head([4, [2, null]]), [6, null])), list(2, 4, 6));
[beforeMarker] is_null runs

equal(false ? [6, null] : $reverse(tail([4, [2, null]]), pair(head([4, [2, null]]), [6, null])), list(2, 4, 6));
[afterMarker] is_null runs

equal(false ? [6, null] : $reverse(tail([4, [2, null]]), pair(head([4, [2, null]]), [6, null])), list(2, 4, 6));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal($reverse(tail([4, [2, null]]), pair(head([4, [2, null]]), [6, null])), list(2, 4, 6));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal($reverse(tail([4, [2, null]]), pair(head([4, [2, null]]), [6, null])), list(2, 4, 6));
[beforeMarker] tail runs

equal($reverse([2, null], pair(head([4, [2, null]]), [6, null])), list(2, 4, 6));
[afterMarker] tail runs

equal($reverse([2, null], pair(head([4, [2, null]]), [6, null])), list(2, 4, 6));
[beforeMarker] head runs

equal($reverse([2, null], pair(4, [6, null])), list(2, 4, 6));
[afterMarker] head runs

equal($reverse([2, null], pair(4, [6, null])), list(2, 4, 6));
[beforeMarker] pair runs

equal($reverse([2, null], [4, [6, null]]), list(2, 4, 6));
[afterMarker] pair runs

equal($reverse([2, null], [4, [6, null]]), list(2, 4, 6));
[beforeMarker] $reverse runs

equal(((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([2, null], [4, [6, null]]), list(2, 4, 6));
[afterMarker] $reverse runs

equal(((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([2, null], [4, [6, null]]), list(2, 4, 6));
[beforeMarker] [2, null], [4, [6, null]] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

equal(is_null([2, null]) ? [4, [6, null]] : $reverse(tail([2, null]), pair(head([2, null]), [4, [6, null]])), list(2, 4, 6));
[afterMarker] [2, null], [4, [6, null]] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

equal(is_null([2, null]) ? [4, [6, null]] : $reverse(tail([2, null]), pair(head([2, null]), [4, [6, null]])), list(2, 4, 6));
[beforeMarker] is_null runs

equal(false ? [4, [6, null]] : $reverse(tail([2, null]), pair(head([2, null]), [4, [6, null]])), list(2, 4, 6));
[afterMarker] is_null runs

equal(false ? [4, [6, null]] : $reverse(tail([2, null]), pair(head([2, null]), [4, [6, null]])), list(2, 4, 6));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal($reverse(tail([2, null]), pair(head([2, null]), [4, [6, null]])), list(2, 4, 6));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal($reverse(tail([2, null]), pair(head([2, null]), [4, [6, null]])), list(2, 4, 6));
[beforeMarker] tail runs

equal($reverse(null, pair(head([2, null]), [4, [6, null]])), list(2, 4, 6));
[afterMarker] tail runs

equal($reverse(null, pair(head([2, null]), [4, [6, null]])), list(2, 4, 6));
[beforeMarker] head runs

equal($reverse(null, pair(2, [4, [6, null]])), list(2, 4, 6));
[afterMarker] head runs

equal($reverse(null, pair(2, [4, [6, null]])), list(2, 4, 6));
[beforeMarker] pair runs

equal($reverse(null, [2, [4, [6, null]]]), list(2, 4, 6));
[afterMarker] pair runs

equal($reverse(null, [2, [4, [6, null]]]), list(2, 4, 6));
[beforeMarker] $reverse runs

equal(((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))(null, [2, [4, [6, null]]]), list(2, 4, 6));
[afterMarker] $reverse runs

equal(((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))(null, [2, [4, [6, null]]]), list(2, 4, 6));
[beforeMarker] null, [2, [4, [6, null]]] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

equal(is_null(null) ? [2, [4, [6, null]]] : $reverse(tail(null), pair(head(null), [2, [4, [6, null]]])), list(2, 4, 6));
[afterMarker] null, [2, [4, [6, null]]] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

equal(is_null(null) ? [2, [4, [6, null]]] : $reverse(tail(null), pair(head(null), [2, [4, [6, null]]])), list(2, 4, 6));
[beforeMarker] is_null runs

equal(true ? [2, [4, [6, null]]] : $reverse(tail(null), pair(head(null), [2, [4, [6, null]]])), list(2, 4, 6));
[afterMarker] is_null runs

equal(true ? [2, [4, [6, null]]] : $reverse(tail(null), pair(head(null), [2, [4, [6, null]]])), list(2, 4, 6));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

equal([2, [4, [6, null]]], list(2, 4, 6));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

equal([2, [4, [6, null]]], list(2, 4, 6));
[beforeMarker] list runs

equal([2, [4, [6, null]]], [2, [4, [6, null]]]);
[afterMarker] list runs

equal([2, [4, [6, null]]], [2, [4, [6, null]]]);
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)([2, [4, [6, null]]], [2, [4, [6, null]]]);
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)([2, [4, [6, null]]], [2, [4, [6, null]]]);
[beforeMarker] [2, [4, [6, null]]], [2, [4, [6, null]]] substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

is_pair([2, [4, [6, null]]]) ? is_pair([2, [4, [6, null]]]) && equal(head([2, [4, [6, null]]]), head([2, [4, [6, null]]])) && equal(tail([2, [4, [6, null]]]), tail([2, [4, [6, null]]])) : is_null([2, [4, [6, null]]]) ? is_null([2, [4, [6, null]]]) : is_number([2, [4, [6, null]]]) ? is_number([2, [4, [6, null]]]) && [2, [4, [6, null]]] === [2, [4, [6, null]]] : is_boolean([2, [4, [6, null]]]) ? is_boolean([2, [4, [6, null]]]) && ([2, [4, [6, null]]] && [2, [4, [6, null]]] || ![2, [4, [6, null]]] && ![2, [4, [6, null]]]) : is_string([2, [4, [6, null]]]) ? is_string([2, [4, [6, null]]]) && [2, [4, [6, null]]] === [2, [4, [6, null]]] : is_undefined([2, [4, [6, null]]]) ? is_undefined([2, [4, [6, null]]]) : is_function([2, [4, [6, null]]]) ? is_function([2, [4, [6, null]]]) && [2, [4, [6, null]]] === [2, [4, [6, null]]] : fals;
[afterMarker] [2, [4, [6, null]]], [2, [4, [6, null]]] substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

is_pair([2, [4, [6, null]]]) ? is_pair([2, [4, [6, null]]]) && equal(head([2, [4, [6, null]]]), head([2, [4, [6, null]]])) && equal(tail([2, [4, [6, null]]]), tail([2, [4, [6, null]]])) : is_null([2, [4, [6, null]]]) ? is_null([2, [4, [6, null]]]) : is_number([2, [4, [6, null]]]) ? is_number([2, [4, [6, null]]]) && [2, [4, [6, null]]] === [2, [4, [6, null]]] : is_boolean([2, [4, [6, null]]]) ? is_boolean([2, [4, [6, null]]]) && ([2, [4, [6, null]]] && [2, [4, [6, null]]] || ![2, [4, [6, null]]] && ![2, [4, [6, null]]]) : is_string([2, [4, [6, null]]]) ? is_string([2, [4, [6, null]]]) && [2, [4, [6, null]]] === [2, [4, [6, null]]] : is_undefined([2, [4, [6, null]]]) ? is_undefined([2, [4, [6, null]]]) : is_function([2, [4, [6, null]]]) ? is_function([2, [4, [6, null]]]) && [2, [4, [6, null]]] === [2, [4, [6, null]]] : fals;
[beforeMarker] is_pair runs

true ? is_pair([2, [4, [6, null]]]) && equal(head([2, [4, [6, null]]]), head([2, [4, [6, null]]])) && equal(tail([2, [4, [6, null]]]), tail([2, [4, [6, null]]])) : is_null([2, [4, [6, null]]]) ? is_null([2, [4, [6, null]]]) : is_number([2, [4, [6, null]]]) ? is_number([2, [4, [6, null]]]) && [2, [4, [6, null]]] === [2, [4, [6, null]]] : is_boolean([2, [4, [6, null]]]) ? is_boolean([2, [4, [6, null]]]) && ([2, [4, [6, null]]] && [2, [4, [6, null]]] || ![2, [4, [6, null]]] && ![2, [4, [6, null]]]) : is_string([2, [4, [6, null]]]) ? is_string([2, [4, [6, null]]]) && [2, [4, [6, null]]] === [2, [4, [6, null]]] : is_undefined([2, [4, [6, null]]]) ? is_undefined([2, [4, [6, null]]]) : is_function([2, [4, [6, null]]]) ? is_function([2, [4, [6, null]]]) && [2, [4, [6, null]]] === [2, [4, [6, null]]] : fals;
[afterMarker] is_pair runs

true ? is_pair([2, [4, [6, null]]]) && equal(head([2, [4, [6, null]]]), head([2, [4, [6, null]]])) && equal(tail([2, [4, [6, null]]]), tail([2, [4, [6, null]]])) : is_null([2, [4, [6, null]]]) ? is_null([2, [4, [6, null]]]) : is_number([2, [4, [6, null]]]) ? is_number([2, [4, [6, null]]]) && [2, [4, [6, null]]] === [2, [4, [6, null]]] : is_boolean([2, [4, [6, null]]]) ? is_boolean([2, [4, [6, null]]]) && ([2, [4, [6, null]]] && [2, [4, [6, null]]] || ![2, [4, [6, null]]] && ![2, [4, [6, null]]]) : is_string([2, [4, [6, null]]]) ? is_string([2, [4, [6, null]]]) && [2, [4, [6, null]]] === [2, [4, [6, null]]] : is_undefined([2, [4, [6, null]]]) ? is_undefined([2, [4, [6, null]]]) : is_function([2, [4, [6, null]]]) ? is_function([2, [4, [6, null]]]) && [2, [4, [6, null]]] === [2, [4, [6, null]]] : fals;
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_pair([2, [4, [6, null]]]) && equal(head([2, [4, [6, null]]]), head([2, [4, [6, null]]])) && equal(tail([2, [4, [6, null]]]), tail([2, [4, [6, null]]]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_pair([2, [4, [6, null]]]) && equal(head([2, [4, [6, null]]]), head([2, [4, [6, null]]])) && equal(tail([2, [4, [6, null]]]), tail([2, [4, [6, null]]]));
[beforeMarker] is_pair runs

true && equal(head([2, [4, [6, null]]]), head([2, [4, [6, null]]])) && equal(tail([2, [4, [6, null]]]), tail([2, [4, [6, null]]]));
[afterMarker] is_pair runs

true && equal(head([2, [4, [6, null]]]), head([2, [4, [6, null]]])) && equal(tail([2, [4, [6, null]]]), tail([2, [4, [6, null]]]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(head([2, [4, [6, null]]]), head([2, [4, [6, null]]])) && equal(tail([2, [4, [6, null]]]), tail([2, [4, [6, null]]]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(head([2, [4, [6, null]]]), head([2, [4, [6, null]]])) && equal(tail([2, [4, [6, null]]]), tail([2, [4, [6, null]]]));
[beforeMarker] head runs

equal(2, head([2, [4, [6, null]]])) && equal(tail([2, [4, [6, null]]]), tail([2, [4, [6, null]]]));
[afterMarker] head runs

equal(2, head([2, [4, [6, null]]])) && equal(tail([2, [4, [6, null]]]), tail([2, [4, [6, null]]]));
[beforeMarker] head runs

equal(2, 2) && equal(tail([2, [4, [6, null]]]), tail([2, [4, [6, null]]]));
[afterMarker] head runs

equal(2, 2) && equal(tail([2, [4, [6, null]]]), tail([2, [4, [6, null]]]));
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(2, 2) && equal(tail([2, [4, [6, null]]]), tail([2, [4, [6, null]]]));
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(2, 2) && equal(tail([2, [4, [6, null]]]), tail([2, [4, [6, null]]]));
[beforeMarker] 2, 2 substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair(2) ? is_pair(2) && equal(head(2), head(2)) && equal(tail(2), tail(2)) : is_null(2) ? is_null(2) : is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, [4, [6, null]]]), tail([2, [4, [6, null]]]));
[afterMarker] 2, 2 substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair(2) ? is_pair(2) && equal(head(2), head(2)) && equal(tail(2), tail(2)) : is_null(2) ? is_null(2) : is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, [4, [6, null]]]), tail([2, [4, [6, null]]]));
[beforeMarker] is_pair runs

(false ? is_pair(2) && equal(head(2), head(2)) && equal(tail(2), tail(2)) : is_null(2) ? is_null(2) : is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, [4, [6, null]]]), tail([2, [4, [6, null]]]));
[afterMarker] is_pair runs

(false ? is_pair(2) && equal(head(2), head(2)) && equal(tail(2), tail(2)) : is_null(2) ? is_null(2) : is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, [4, [6, null]]]), tail([2, [4, [6, null]]]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_null(2) ? is_null(2) : is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, [4, [6, null]]]), tail([2, [4, [6, null]]]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_null(2) ? is_null(2) : is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, [4, [6, null]]]), tail([2, [4, [6, null]]]));
[beforeMarker] is_null runs

(false ? is_null(2) : is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, [4, [6, null]]]), tail([2, [4, [6, null]]]));
[afterMarker] is_null runs

(false ? is_null(2) : is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, [4, [6, null]]]), tail([2, [4, [6, null]]]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, [4, [6, null]]]), tail([2, [4, [6, null]]]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, [4, [6, null]]]), tail([2, [4, [6, null]]]));
[beforeMarker] is_number runs

(true ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, [4, [6, null]]]), tail([2, [4, [6, null]]]));
[afterMarker] is_number runs

(true ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, [4, [6, null]]]), tail([2, [4, [6, null]]]));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_number(2) && 2 === 2 && equal(tail([2, [4, [6, null]]]), tail([2, [4, [6, null]]]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_number(2) && 2 === 2 && equal(tail([2, [4, [6, null]]]), tail([2, [4, [6, null]]]));
[beforeMarker] is_number runs

true && 2 === 2 && equal(tail([2, [4, [6, null]]]), tail([2, [4, [6, null]]]));
[afterMarker] is_number runs

true && 2 === 2 && equal(tail([2, [4, [6, null]]]), tail([2, [4, [6, null]]]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

2 === 2 && equal(tail([2, [4, [6, null]]]), tail([2, [4, [6, null]]]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

2 === 2 && equal(tail([2, [4, [6, null]]]), tail([2, [4, [6, null]]]));
[beforeMarker] Binary expression 2 === 2 evaluated

true && equal(tail([2, [4, [6, null]]]), tail([2, [4, [6, null]]]));
[afterMarker] Binary expression 2 === 2 evaluated

true && equal(tail([2, [4, [6, null]]]), tail([2, [4, [6, null]]]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(tail([2, [4, [6, null]]]), tail([2, [4, [6, null]]]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(tail([2, [4, [6, null]]]), tail([2, [4, [6, null]]]));
[beforeMarker] tail runs

equal([4, [6, null]], tail([2, [4, [6, null]]]));
[afterMarker] tail runs

equal([4, [6, null]], tail([2, [4, [6, null]]]));
[beforeMarker] tail runs

equal([4, [6, null]], [4, [6, null]]);
[afterMarker] tail runs

equal([4, [6, null]], [4, [6, null]]);
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)([4, [6, null]], [4, [6, null]]);
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)([4, [6, null]], [4, [6, null]]);
[beforeMarker] [4, [6, null]], [4, [6, null]] substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

is_pair([4, [6, null]]) ? is_pair([4, [6, null]]) && equal(head([4, [6, null]]), head([4, [6, null]])) && equal(tail([4, [6, null]]), tail([4, [6, null]])) : is_null([4, [6, null]]) ? is_null([4, [6, null]]) : is_number([4, [6, null]]) ? is_number([4, [6, null]]) && [4, [6, null]] === [4, [6, null]] : is_boolean([4, [6, null]]) ? is_boolean([4, [6, null]]) && ([4, [6, null]] && [4, [6, null]] || ![4, [6, null]] && ![4, [6, null]]) : is_string([4, [6, null]]) ? is_string([4, [6, null]]) && [4, [6, null]] === [4, [6, null]] : is_undefined([4, [6, null]]) ? is_undefined([4, [6, null]]) : is_function([4, [6, null]]) ? is_function([4, [6, null]]) && [4, [6, null]] === [4, [6, null]] : fals;
[afterMarker] [4, [6, null]], [4, [6, null]] substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

is_pair([4, [6, null]]) ? is_pair([4, [6, null]]) && equal(head([4, [6, null]]), head([4, [6, null]])) && equal(tail([4, [6, null]]), tail([4, [6, null]])) : is_null([4, [6, null]]) ? is_null([4, [6, null]]) : is_number([4, [6, null]]) ? is_number([4, [6, null]]) && [4, [6, null]] === [4, [6, null]] : is_boolean([4, [6, null]]) ? is_boolean([4, [6, null]]) && ([4, [6, null]] && [4, [6, null]] || ![4, [6, null]] && ![4, [6, null]]) : is_string([4, [6, null]]) ? is_string([4, [6, null]]) && [4, [6, null]] === [4, [6, null]] : is_undefined([4, [6, null]]) ? is_undefined([4, [6, null]]) : is_function([4, [6, null]]) ? is_function([4, [6, null]]) && [4, [6, null]] === [4, [6, null]] : fals;
[beforeMarker] is_pair runs

true ? is_pair([4, [6, null]]) && equal(head([4, [6, null]]), head([4, [6, null]])) && equal(tail([4, [6, null]]), tail([4, [6, null]])) : is_null([4, [6, null]]) ? is_null([4, [6, null]]) : is_number([4, [6, null]]) ? is_number([4, [6, null]]) && [4, [6, null]] === [4, [6, null]] : is_boolean([4, [6, null]]) ? is_boolean([4, [6, null]]) && ([4, [6, null]] && [4, [6, null]] || ![4, [6, null]] && ![4, [6, null]]) : is_string([4, [6, null]]) ? is_string([4, [6, null]]) && [4, [6, null]] === [4, [6, null]] : is_undefined([4, [6, null]]) ? is_undefined([4, [6, null]]) : is_function([4, [6, null]]) ? is_function([4, [6, null]]) && [4, [6, null]] === [4, [6, null]] : fals;
[afterMarker] is_pair runs

true ? is_pair([4, [6, null]]) && equal(head([4, [6, null]]), head([4, [6, null]])) && equal(tail([4, [6, null]]), tail([4, [6, null]])) : is_null([4, [6, null]]) ? is_null([4, [6, null]]) : is_number([4, [6, null]]) ? is_number([4, [6, null]]) && [4, [6, null]] === [4, [6, null]] : is_boolean([4, [6, null]]) ? is_boolean([4, [6, null]]) && ([4, [6, null]] && [4, [6, null]] || ![4, [6, null]] && ![4, [6, null]]) : is_string([4, [6, null]]) ? is_string([4, [6, null]]) && [4, [6, null]] === [4, [6, null]] : is_undefined([4, [6, null]]) ? is_undefined([4, [6, null]]) : is_function([4, [6, null]]) ? is_function([4, [6, null]]) && [4, [6, null]] === [4, [6, null]] : fals;
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_pair([4, [6, null]]) && equal(head([4, [6, null]]), head([4, [6, null]])) && equal(tail([4, [6, null]]), tail([4, [6, null]]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_pair([4, [6, null]]) && equal(head([4, [6, null]]), head([4, [6, null]])) && equal(tail([4, [6, null]]), tail([4, [6, null]]));
[beforeMarker] is_pair runs

true && equal(head([4, [6, null]]), head([4, [6, null]])) && equal(tail([4, [6, null]]), tail([4, [6, null]]));
[afterMarker] is_pair runs

true && equal(head([4, [6, null]]), head([4, [6, null]])) && equal(tail([4, [6, null]]), tail([4, [6, null]]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(head([4, [6, null]]), head([4, [6, null]])) && equal(tail([4, [6, null]]), tail([4, [6, null]]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(head([4, [6, null]]), head([4, [6, null]])) && equal(tail([4, [6, null]]), tail([4, [6, null]]));
[beforeMarker] head runs

equal(4, head([4, [6, null]])) && equal(tail([4, [6, null]]), tail([4, [6, null]]));
[afterMarker] head runs

equal(4, head([4, [6, null]])) && equal(tail([4, [6, null]]), tail([4, [6, null]]));
[beforeMarker] head runs

equal(4, 4) && equal(tail([4, [6, null]]), tail([4, [6, null]]));
[afterMarker] head runs

equal(4, 4) && equal(tail([4, [6, null]]), tail([4, [6, null]]));
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(4, 4) && equal(tail([4, [6, null]]), tail([4, [6, null]]));
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(4, 4) && equal(tail([4, [6, null]]), tail([4, [6, null]]));
[beforeMarker] 4, 4 substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair(4) ? is_pair(4) && equal(head(4), head(4)) && equal(tail(4), tail(4)) : is_null(4) ? is_null(4) : is_number(4) ? is_number(4) && 4 === 4 : is_boolean(4) ? is_boolean(4) && (4 && 4 || !4 && !4) : is_string(4) ? is_string(4) && 4 === 4 : is_undefined(4) ? is_undefined(4) : is_function(4) ? is_function(4) && 4 === 4 : fals) && equal(tail([4, [6, null]]), tail([4, [6, null]]));
[afterMarker] 4, 4 substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair(4) ? is_pair(4) && equal(head(4), head(4)) && equal(tail(4), tail(4)) : is_null(4) ? is_null(4) : is_number(4) ? is_number(4) && 4 === 4 : is_boolean(4) ? is_boolean(4) && (4 && 4 || !4 && !4) : is_string(4) ? is_string(4) && 4 === 4 : is_undefined(4) ? is_undefined(4) : is_function(4) ? is_function(4) && 4 === 4 : fals) && equal(tail([4, [6, null]]), tail([4, [6, null]]));
[beforeMarker] is_pair runs

(false ? is_pair(4) && equal(head(4), head(4)) && equal(tail(4), tail(4)) : is_null(4) ? is_null(4) : is_number(4) ? is_number(4) && 4 === 4 : is_boolean(4) ? is_boolean(4) && (4 && 4 || !4 && !4) : is_string(4) ? is_string(4) && 4 === 4 : is_undefined(4) ? is_undefined(4) : is_function(4) ? is_function(4) && 4 === 4 : fals) && equal(tail([4, [6, null]]), tail([4, [6, null]]));
[afterMarker] is_pair runs

(false ? is_pair(4) && equal(head(4), head(4)) && equal(tail(4), tail(4)) : is_null(4) ? is_null(4) : is_number(4) ? is_number(4) && 4 === 4 : is_boolean(4) ? is_boolean(4) && (4 && 4 || !4 && !4) : is_string(4) ? is_string(4) && 4 === 4 : is_undefined(4) ? is_undefined(4) : is_function(4) ? is_function(4) && 4 === 4 : fals) && equal(tail([4, [6, null]]), tail([4, [6, null]]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_null(4) ? is_null(4) : is_number(4) ? is_number(4) && 4 === 4 : is_boolean(4) ? is_boolean(4) && (4 && 4 || !4 && !4) : is_string(4) ? is_string(4) && 4 === 4 : is_undefined(4) ? is_undefined(4) : is_function(4) ? is_function(4) && 4 === 4 : fals) && equal(tail([4, [6, null]]), tail([4, [6, null]]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_null(4) ? is_null(4) : is_number(4) ? is_number(4) && 4 === 4 : is_boolean(4) ? is_boolean(4) && (4 && 4 || !4 && !4) : is_string(4) ? is_string(4) && 4 === 4 : is_undefined(4) ? is_undefined(4) : is_function(4) ? is_function(4) && 4 === 4 : fals) && equal(tail([4, [6, null]]), tail([4, [6, null]]));
[beforeMarker] is_null runs

(false ? is_null(4) : is_number(4) ? is_number(4) && 4 === 4 : is_boolean(4) ? is_boolean(4) && (4 && 4 || !4 && !4) : is_string(4) ? is_string(4) && 4 === 4 : is_undefined(4) ? is_undefined(4) : is_function(4) ? is_function(4) && 4 === 4 : fals) && equal(tail([4, [6, null]]), tail([4, [6, null]]));
[afterMarker] is_null runs

(false ? is_null(4) : is_number(4) ? is_number(4) && 4 === 4 : is_boolean(4) ? is_boolean(4) && (4 && 4 || !4 && !4) : is_string(4) ? is_string(4) && 4 === 4 : is_undefined(4) ? is_undefined(4) : is_function(4) ? is_function(4) && 4 === 4 : fals) && equal(tail([4, [6, null]]), tail([4, [6, null]]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_number(4) ? is_number(4) && 4 === 4 : is_boolean(4) ? is_boolean(4) && (4 && 4 || !4 && !4) : is_string(4) ? is_string(4) && 4 === 4 : is_undefined(4) ? is_undefined(4) : is_function(4) ? is_function(4) && 4 === 4 : fals) && equal(tail([4, [6, null]]), tail([4, [6, null]]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_number(4) ? is_number(4) && 4 === 4 : is_boolean(4) ? is_boolean(4) && (4 && 4 || !4 && !4) : is_string(4) ? is_string(4) && 4 === 4 : is_undefined(4) ? is_undefined(4) : is_function(4) ? is_function(4) && 4 === 4 : fals) && equal(tail([4, [6, null]]), tail([4, [6, null]]));
[beforeMarker] is_number runs

(true ? is_number(4) && 4 === 4 : is_boolean(4) ? is_boolean(4) && (4 && 4 || !4 && !4) : is_string(4) ? is_string(4) && 4 === 4 : is_undefined(4) ? is_undefined(4) : is_function(4) ? is_function(4) && 4 === 4 : fals) && equal(tail([4, [6, null]]), tail([4, [6, null]]));
[afterMarker] is_number runs

(true ? is_number(4) && 4 === 4 : is_boolean(4) ? is_boolean(4) && (4 && 4 || !4 && !4) : is_string(4) ? is_string(4) && 4 === 4 : is_undefined(4) ? is_undefined(4) : is_function(4) ? is_function(4) && 4 === 4 : fals) && equal(tail([4, [6, null]]), tail([4, [6, null]]));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_number(4) && 4 === 4 && equal(tail([4, [6, null]]), tail([4, [6, null]]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_number(4) && 4 === 4 && equal(tail([4, [6, null]]), tail([4, [6, null]]));
[beforeMarker] is_number runs

true && 4 === 4 && equal(tail([4, [6, null]]), tail([4, [6, null]]));
[afterMarker] is_number runs

true && 4 === 4 && equal(tail([4, [6, null]]), tail([4, [6, null]]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

4 === 4 && equal(tail([4, [6, null]]), tail([4, [6, null]]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

4 === 4 && equal(tail([4, [6, null]]), tail([4, [6, null]]));
[beforeMarker] Binary expression 4 === 4 evaluated

true && equal(tail([4, [6, null]]), tail([4, [6, null]]));
[afterMarker] Binary expression 4 === 4 evaluated

true && equal(tail([4, [6, null]]), tail([4, [6, null]]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(tail([4, [6, null]]), tail([4, [6, null]]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(tail([4, [6, null]]), tail([4, [6, null]]));
[beforeMarker] tail runs

equal([6, null], tail([4, [6, null]]));
[afterMarker] tail runs

equal([6, null], tail([4, [6, null]]));
[beforeMarker] tail runs

equal([6, null], [6, null]);
[afterMarker] tail runs

equal([6, null], [6, null]);
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)([6, null], [6, null]);
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)([6, null], [6, null]);
[beforeMarker] [6, null], [6, null] substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

is_pair([6, null]) ? is_pair([6, null]) && equal(head([6, null]), head([6, null])) && equal(tail([6, null]), tail([6, null])) : is_null([6, null]) ? is_null([6, null]) : is_number([6, null]) ? is_number([6, null]) && [6, null] === [6, null] : is_boolean([6, null]) ? is_boolean([6, null]) && ([6, null] && [6, null] || ![6, null] && ![6, null]) : is_string([6, null]) ? is_string([6, null]) && [6, null] === [6, null] : is_undefined([6, null]) ? is_undefined([6, null]) : is_function([6, null]) ? is_function([6, null]) && [6, null] === [6, null] : fals;
[afterMarker] [6, null], [6, null] substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

is_pair([6, null]) ? is_pair([6, null]) && equal(head([6, null]), head([6, null])) && equal(tail([6, null]), tail([6, null])) : is_null([6, null]) ? is_null([6, null]) : is_number([6, null]) ? is_number([6, null]) && [6, null] === [6, null] : is_boolean([6, null]) ? is_boolean([6, null]) && ([6, null] && [6, null] || ![6, null] && ![6, null]) : is_string([6, null]) ? is_string([6, null]) && [6, null] === [6, null] : is_undefined([6, null]) ? is_undefined([6, null]) : is_function([6, null]) ? is_function([6, null]) && [6, null] === [6, null] : fals;
[beforeMarker] is_pair runs

true ? is_pair([6, null]) && equal(head([6, null]), head([6, null])) && equal(tail([6, null]), tail([6, null])) : is_null([6, null]) ? is_null([6, null]) : is_number([6, null]) ? is_number([6, null]) && [6, null] === [6, null] : is_boolean([6, null]) ? is_boolean([6, null]) && ([6, null] && [6, null] || ![6, null] && ![6, null]) : is_string([6, null]) ? is_string([6, null]) && [6, null] === [6, null] : is_undefined([6, null]) ? is_undefined([6, null]) : is_function([6, null]) ? is_function([6, null]) && [6, null] === [6, null] : fals;
[afterMarker] is_pair runs

true ? is_pair([6, null]) && equal(head([6, null]), head([6, null])) && equal(tail([6, null]), tail([6, null])) : is_null([6, null]) ? is_null([6, null]) : is_number([6, null]) ? is_number([6, null]) && [6, null] === [6, null] : is_boolean([6, null]) ? is_boolean([6, null]) && ([6, null] && [6, null] || ![6, null] && ![6, null]) : is_string([6, null]) ? is_string([6, null]) && [6, null] === [6, null] : is_undefined([6, null]) ? is_undefined([6, null]) : is_function([6, null]) ? is_function([6, null]) && [6, null] === [6, null] : fals;
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_pair([6, null]) && equal(head([6, null]), head([6, null])) && equal(tail([6, null]), tail([6, null]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_pair([6, null]) && equal(head([6, null]), head([6, null])) && equal(tail([6, null]), tail([6, null]));
[beforeMarker] is_pair runs

true && equal(head([6, null]), head([6, null])) && equal(tail([6, null]), tail([6, null]));
[afterMarker] is_pair runs

true && equal(head([6, null]), head([6, null])) && equal(tail([6, null]), tail([6, null]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(head([6, null]), head([6, null])) && equal(tail([6, null]), tail([6, null]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(head([6, null]), head([6, null])) && equal(tail([6, null]), tail([6, null]));
[beforeMarker] head runs

equal(6, head([6, null])) && equal(tail([6, null]), tail([6, null]));
[afterMarker] head runs

equal(6, head([6, null])) && equal(tail([6, null]), tail([6, null]));
[beforeMarker] head runs

equal(6, 6) && equal(tail([6, null]), tail([6, null]));
[afterMarker] head runs

equal(6, 6) && equal(tail([6, null]), tail([6, null]));
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(6, 6) && equal(tail([6, null]), tail([6, null]));
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(6, 6) && equal(tail([6, null]), tail([6, null]));
[beforeMarker] 6, 6 substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair(6) ? is_pair(6) && equal(head(6), head(6)) && equal(tail(6), tail(6)) : is_null(6) ? is_null(6) : is_number(6) ? is_number(6) && 6 === 6 : is_boolean(6) ? is_boolean(6) && (6 && 6 || !6 && !6) : is_string(6) ? is_string(6) && 6 === 6 : is_undefined(6) ? is_undefined(6) : is_function(6) ? is_function(6) && 6 === 6 : fals) && equal(tail([6, null]), tail([6, null]));
[afterMarker] 6, 6 substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair(6) ? is_pair(6) && equal(head(6), head(6)) && equal(tail(6), tail(6)) : is_null(6) ? is_null(6) : is_number(6) ? is_number(6) && 6 === 6 : is_boolean(6) ? is_boolean(6) && (6 && 6 || !6 && !6) : is_string(6) ? is_string(6) && 6 === 6 : is_undefined(6) ? is_undefined(6) : is_function(6) ? is_function(6) && 6 === 6 : fals) && equal(tail([6, null]), tail([6, null]));
[beforeMarker] is_pair runs

(false ? is_pair(6) && equal(head(6), head(6)) && equal(tail(6), tail(6)) : is_null(6) ? is_null(6) : is_number(6) ? is_number(6) && 6 === 6 : is_boolean(6) ? is_boolean(6) && (6 && 6 || !6 && !6) : is_string(6) ? is_string(6) && 6 === 6 : is_undefined(6) ? is_undefined(6) : is_function(6) ? is_function(6) && 6 === 6 : fals) && equal(tail([6, null]), tail([6, null]));
[afterMarker] is_pair runs

(false ? is_pair(6) && equal(head(6), head(6)) && equal(tail(6), tail(6)) : is_null(6) ? is_null(6) : is_number(6) ? is_number(6) && 6 === 6 : is_boolean(6) ? is_boolean(6) && (6 && 6 || !6 && !6) : is_string(6) ? is_string(6) && 6 === 6 : is_undefined(6) ? is_undefined(6) : is_function(6) ? is_function(6) && 6 === 6 : fals) && equal(tail([6, null]), tail([6, null]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_null(6) ? is_null(6) : is_number(6) ? is_number(6) && 6 === 6 : is_boolean(6) ? is_boolean(6) && (6 && 6 || !6 && !6) : is_string(6) ? is_string(6) && 6 === 6 : is_undefined(6) ? is_undefined(6) : is_function(6) ? is_function(6) && 6 === 6 : fals) && equal(tail([6, null]), tail([6, null]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_null(6) ? is_null(6) : is_number(6) ? is_number(6) && 6 === 6 : is_boolean(6) ? is_boolean(6) && (6 && 6 || !6 && !6) : is_string(6) ? is_string(6) && 6 === 6 : is_undefined(6) ? is_undefined(6) : is_function(6) ? is_function(6) && 6 === 6 : fals) && equal(tail([6, null]), tail([6, null]));
[beforeMarker] is_null runs

(false ? is_null(6) : is_number(6) ? is_number(6) && 6 === 6 : is_boolean(6) ? is_boolean(6) && (6 && 6 || !6 && !6) : is_string(6) ? is_string(6) && 6 === 6 : is_undefined(6) ? is_undefined(6) : is_function(6) ? is_function(6) && 6 === 6 : fals) && equal(tail([6, null]), tail([6, null]));
[afterMarker] is_null runs

(false ? is_null(6) : is_number(6) ? is_number(6) && 6 === 6 : is_boolean(6) ? is_boolean(6) && (6 && 6 || !6 && !6) : is_string(6) ? is_string(6) && 6 === 6 : is_undefined(6) ? is_undefined(6) : is_function(6) ? is_function(6) && 6 === 6 : fals) && equal(tail([6, null]), tail([6, null]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_number(6) ? is_number(6) && 6 === 6 : is_boolean(6) ? is_boolean(6) && (6 && 6 || !6 && !6) : is_string(6) ? is_string(6) && 6 === 6 : is_undefined(6) ? is_undefined(6) : is_function(6) ? is_function(6) && 6 === 6 : fals) && equal(tail([6, null]), tail([6, null]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_number(6) ? is_number(6) && 6 === 6 : is_boolean(6) ? is_boolean(6) && (6 && 6 || !6 && !6) : is_string(6) ? is_string(6) && 6 === 6 : is_undefined(6) ? is_undefined(6) : is_function(6) ? is_function(6) && 6 === 6 : fals) && equal(tail([6, null]), tail([6, null]));
[beforeMarker] is_number runs

(true ? is_number(6) && 6 === 6 : is_boolean(6) ? is_boolean(6) && (6 && 6 || !6 && !6) : is_string(6) ? is_string(6) && 6 === 6 : is_undefined(6) ? is_undefined(6) : is_function(6) ? is_function(6) && 6 === 6 : fals) && equal(tail([6, null]), tail([6, null]));
[afterMarker] is_number runs

(true ? is_number(6) && 6 === 6 : is_boolean(6) ? is_boolean(6) && (6 && 6 || !6 && !6) : is_string(6) ? is_string(6) && 6 === 6 : is_undefined(6) ? is_undefined(6) : is_function(6) ? is_function(6) && 6 === 6 : fals) && equal(tail([6, null]), tail([6, null]));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_number(6) && 6 === 6 && equal(tail([6, null]), tail([6, null]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_number(6) && 6 === 6 && equal(tail([6, null]), tail([6, null]));
[beforeMarker] is_number runs

true && 6 === 6 && equal(tail([6, null]), tail([6, null]));
[afterMarker] is_number runs

true && 6 === 6 && equal(tail([6, null]), tail([6, null]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

6 === 6 && equal(tail([6, null]), tail([6, null]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

6 === 6 && equal(tail([6, null]), tail([6, null]));
[beforeMarker] Binary expression 6 === 6 evaluated

true && equal(tail([6, null]), tail([6, null]));
[afterMarker] Binary expression 6 === 6 evaluated

true && equal(tail([6, null]), tail([6, null]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(tail([6, null]), tail([6, null]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(tail([6, null]), tail([6, null]));
[beforeMarker] tail runs

equal(null, tail([6, null]));
[afterMarker] tail runs

equal(null, tail([6, null]));
[beforeMarker] tail runs

equal(null, null);
[afterMarker] tail runs

equal(null, null);
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(null, null);
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(null, null);
[beforeMarker] null, null substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

is_pair(null) ? is_pair(null) && equal(head(null), head(null)) && equal(tail(null), tail(null)) : is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals;
[afterMarker] null, null substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

is_pair(null) ? is_pair(null) && equal(head(null), head(null)) && equal(tail(null), tail(null)) : is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals;
[beforeMarker] is_pair runs

false ? is_pair(null) && equal(head(null), head(null)) && equal(tail(null), tail(null)) : is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals;
[afterMarker] is_pair runs

false ? is_pair(null) && equal(head(null), head(null)) && equal(tail(null), tail(null)) : is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals;
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals;
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals;
[beforeMarker] is_null runs

true ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals;
[afterMarker] is_null runs

true ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals;
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_null(null);
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_null(null);
[beforeMarker] is_null runs

true;
[afterMarker] is_null runs

true;
[noMarker] Evaluation complete
"
`;

exports[`List operations subsets 1`] = `
"function subsets(s) { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); }}equal(subsets(list(1, 2)), list(null, list(2), list(1), list(1, 2)));
[noMarker] Start of evaluation

function subsets(s) { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); }}equal(subsets(list(1, 2)), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] Function subsets declared, parameter(s) s required

equal((s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); }})(list(1, 2)), list(null, list(2), list(1), list(1, 2)));
[afterMarker] Function subsets declared, parameter(s) s required

equal((s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); }})(list(1, 2)), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] list runs

equal((s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); }})([1, [2, null]]), list(null, list(2), list(1), list(1, 2)));
[afterMarker] list runs

equal((s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); }})([1, [2, null]]), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] Function subsets takes in [1, [2, null]] as input s

equal({ if (is_null([1, [2, null]])) { return list(null); } else { const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(tail([1, [2, null]])); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] Function subsets takes in [1, [2, null]] as input s

equal({ if (is_null([1, [2, null]])) { return list(null); } else { const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(tail([1, [2, null]])); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] is_null runs

equal({ if (false) { return list(null); } else { const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(tail([1, [2, null]])); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] is_null runs

equal({ if (false) { return list(null); } else { const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(tail([1, [2, null]])); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] If statement evaluated, condition false, proceed to else block

equal({ { undefined; const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(tail([1, [2, null]])); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] If statement evaluated, condition false, proceed to else block

equal({ { undefined; const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(tail([1, [2, null]])); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] tail runs

equal({ { undefined; const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })([2, null]); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] tail runs

equal({ { undefined; const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })([2, null]); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] Function subsets takes in [2, null] as input s

equal({ { undefined; const rest = { if (is_null([2, null])) { return list(null); } else { const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(tail([2, null])); return append(rest, map(x => pair(head([2, null]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] Function subsets takes in [2, null] as input s

equal({ { undefined; const rest = { if (is_null([2, null])) { return list(null); } else { const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(tail([2, null])); return append(rest, map(x => pair(head([2, null]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] is_null runs

equal({ { undefined; const rest = { if (false) { return list(null); } else { const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(tail([2, null])); return append(rest, map(x => pair(head([2, null]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] is_null runs

equal({ { undefined; const rest = { if (false) { return list(null); } else { const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(tail([2, null])); return append(rest, map(x => pair(head([2, null]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] If statement evaluated, condition false, proceed to else block

equal({ { undefined; const rest = { { undefined; const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(tail([2, null])); return append(rest, map(x => pair(head([2, null]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] If statement evaluated, condition false, proceed to else block

equal({ { undefined; const rest = { { undefined; const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(tail([2, null])); return append(rest, map(x => pair(head([2, null]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] tail runs

equal({ { undefined; const rest = { { undefined; const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(null); return append(rest, map(x => pair(head([2, null]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] tail runs

equal({ { undefined; const rest = { { undefined; const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(null); return append(rest, map(x => pair(head([2, null]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] Function subsets takes in null as input s

equal({ { undefined; const rest = { { undefined; const rest = { if (is_null(null)) { return list(null); } else { const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(tail(null)); return append(rest, map(x => pair(head(null), x), rest)); } }; return append(rest, map(x => pair(head([2, null]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] Function subsets takes in null as input s

equal({ { undefined; const rest = { { undefined; const rest = { if (is_null(null)) { return list(null); } else { const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(tail(null)); return append(rest, map(x => pair(head(null), x), rest)); } }; return append(rest, map(x => pair(head([2, null]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] is_null runs

equal({ { undefined; const rest = { { undefined; const rest = { if (true) { return list(null); } else { const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(tail(null)); return append(rest, map(x => pair(head(null), x), rest)); } }; return append(rest, map(x => pair(head([2, null]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] is_null runs

equal({ { undefined; const rest = { { undefined; const rest = { if (true) { return list(null); } else { const rest = (s => { if (is_null(s)) { return list(null); } else { const rest = subsets(tail(s)); return append(rest, map(x => pair(head(s), x), rest)); } })(tail(null)); return append(rest, map(x => pair(head(null), x), rest)); } }; return append(rest, map(x => pair(head([2, null]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] If statement evaluated, condition true, proceed to if block

equal({ { undefined; const rest = { { undefined; const rest = { { undefined; return list(null); } }; return append(rest, map(x => pair(head([2, null]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] If statement evaluated, condition true, proceed to if block

equal({ { undefined; const rest = { { undefined; const rest = { { undefined; return list(null); } }; return append(rest, map(x => pair(head([2, null]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] undefined finished evaluating

equal({ { undefined; const rest = { { undefined; const rest = { { return list(null); } }; return append(rest, map(x => pair(head([2, null]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] undefined finished evaluating

equal({ { undefined; const rest = { { undefined; const rest = { { return list(null); } }; return append(rest, map(x => pair(head([2, null]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] return list(null); finished evaluating

equal({ { undefined; const rest = { { undefined; const rest = { return list(null); }; return append(rest, map(x => pair(head([2, null]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] return list(null); finished evaluating

equal({ { undefined; const rest = { { undefined; const rest = { return list(null); }; return append(rest, map(x => pair(head([2, null]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] list(null) returned

equal({ { undefined; const rest = { { undefined; const rest = list(null); return append(rest, map(x => pair(head([2, null]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] list(null) returned

equal({ { undefined; const rest = { { undefined; const rest = list(null); return append(rest, map(x => pair(head([2, null]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] list runs

equal({ { undefined; const rest = { { undefined; const rest = [null, null]; return append(rest, map(x => pair(head([2, null]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] list runs

equal({ { undefined; const rest = { { undefined; const rest = [null, null]; return append(rest, map(x => pair(head([2, null]), x), rest)); } }; return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] Constant rest declared and substituted into the rest of block

equal({ { undefined; const rest = { { undefined; return append([null, null], map(x => pair(head([2, null]), x), [null, null])); } }; return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] Constant rest declared and substituted into the rest of block

equal({ { undefined; const rest = { { undefined; return append([null, null], map(x => pair(head([2, null]), x), [null, null])); } }; return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] undefined finished evaluating

equal({ { undefined; const rest = { { return append([null, null], map(x => pair(head([2, null]), x), [null, null])); } }; return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] undefined finished evaluating

equal({ { undefined; const rest = { { return append([null, null], map(x => pair(head([2, null]), x), [null, null])); } }; return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] return append([null, null], map(x => pair(head([2, null]), x), [null, null])); finished evaluating

equal({ { undefined; const rest = { return append([null, null], map(x => pair(head([2, null]), x), [null, null])); }; return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] return append([null, null], map(x => pair(head([2, null]), x), [null, null])); finished evaluating

equal({ { undefined; const rest = { return append([null, null], map(x => pair(head([2, null]), x), [null, null])); }; return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] append([null, null], map(x => pair(head([2, null]), x), [null, null])) returned

equal({ { undefined; const rest = append([null, null], map(x => pair(head([2, null]), x), [null, null])); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] append([null, null], map(x => pair(head([2, null]), x), [null, null])) returned

equal({ { undefined; const rest = append([null, null], map(x => pair(head([2, null]), x), [null, null])); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] map runs

equal({ { undefined; const rest = append([null, null], $map(x => pair(head([2, null]), x), [null, null], null)); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] map runs

equal({ { undefined; const rest = append([null, null], $map(x => pair(head([2, null]), x), [null, null], null)); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] $map runs

equal({ { undefined; const rest = append([null, null], ((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => pair(head([2, null]), x), [null, null], null)); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] $map runs

equal({ { undefined; const rest = append([null, null], ((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => pair(head([2, null]), x), [null, null], null)); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] x => pair(head([2, null]), x), [null, null], null substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

equal({ { undefined; const rest = append([null, null], is_null([null, null]) ? reverse(null) : $map(x => pair(head([2, null]), x), tail([null, null]), pair((x => pair(head([2, null]), x))(head([null, null])), null))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] x => pair(head([2, null]), x), [null, null], null substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

equal({ { undefined; const rest = append([null, null], is_null([null, null]) ? reverse(null) : $map(x => pair(head([2, null]), x), tail([null, null]), pair((x => pair(head([2, null]), x))(head([null, null])), null))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] is_null runs

equal({ { undefined; const rest = append([null, null], false ? reverse(null) : $map(x => pair(head([2, null]), x), tail([null, null]), pair((x => pair(head([2, null]), x))(head([null, null])), null))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] is_null runs

equal({ { undefined; const rest = append([null, null], false ? reverse(null) : $map(x => pair(head([2, null]), x), tail([null, null]), pair((x => pair(head([2, null]), x))(head([null, null])), null))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal({ { undefined; const rest = append([null, null], $map(x => pair(head([2, null]), x), tail([null, null]), pair((x => pair(head([2, null]), x))(head([null, null])), null))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal({ { undefined; const rest = append([null, null], $map(x => pair(head([2, null]), x), tail([null, null]), pair((x => pair(head([2, null]), x))(head([null, null])), null))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] tail runs

equal({ { undefined; const rest = append([null, null], $map(x => pair(head([2, null]), x), null, pair((x => pair(head([2, null]), x))(head([null, null])), null))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] tail runs

equal({ { undefined; const rest = append([null, null], $map(x => pair(head([2, null]), x), null, pair((x => pair(head([2, null]), x))(head([null, null])), null))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] head runs

equal({ { undefined; const rest = append([null, null], $map(x => pair(head([2, null]), x), null, pair((x => pair(head([2, null]), x))(null), null))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] head runs

equal({ { undefined; const rest = append([null, null], $map(x => pair(head([2, null]), x), null, pair((x => pair(head([2, null]), x))(null), null))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] null substituted into x of x => pair(head([2, null]), x)

equal({ { undefined; const rest = append([null, null], $map(x => pair(head([2, null]), x), null, pair(pair(head([2, null]), null), null))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] null substituted into x of x => pair(head([2, null]), x)

equal({ { undefined; const rest = append([null, null], $map(x => pair(head([2, null]), x), null, pair(pair(head([2, null]), null), null))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] head runs

equal({ { undefined; const rest = append([null, null], $map(x => pair(head([2, null]), x), null, pair(pair(2, null), null))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] head runs

equal({ { undefined; const rest = append([null, null], $map(x => pair(head([2, null]), x), null, pair(pair(2, null), null))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] pair runs

equal({ { undefined; const rest = append([null, null], $map(x => pair(head([2, null]), x), null, pair([2, null], null))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] pair runs

equal({ { undefined; const rest = append([null, null], $map(x => pair(head([2, null]), x), null, pair([2, null], null))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] pair runs

equal({ { undefined; const rest = append([null, null], $map(x => pair(head([2, null]), x), null, [[2, null], null])); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] pair runs

equal({ { undefined; const rest = append([null, null], $map(x => pair(head([2, null]), x), null, [[2, null], null])); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] $map runs

equal({ { undefined; const rest = append([null, null], ((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => pair(head([2, null]), x), null, [[2, null], null])); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] $map runs

equal({ { undefined; const rest = append([null, null], ((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => pair(head([2, null]), x), null, [[2, null], null])); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] x => pair(head([2, null]), x), null, [[2, null], null] substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

equal({ { undefined; const rest = append([null, null], is_null(null) ? reverse([[2, null], null]) : $map(x => pair(head([2, null]), x), tail(null), pair((x => pair(head([2, null]), x))(head(null)), [[2, null], null]))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] x => pair(head([2, null]), x), null, [[2, null], null] substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

equal({ { undefined; const rest = append([null, null], is_null(null) ? reverse([[2, null], null]) : $map(x => pair(head([2, null]), x), tail(null), pair((x => pair(head([2, null]), x))(head(null)), [[2, null], null]))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] is_null runs

equal({ { undefined; const rest = append([null, null], true ? reverse([[2, null], null]) : $map(x => pair(head([2, null]), x), tail(null), pair((x => pair(head([2, null]), x))(head(null)), [[2, null], null]))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] is_null runs

equal({ { undefined; const rest = append([null, null], true ? reverse([[2, null], null]) : $map(x => pair(head([2, null]), x), tail(null), pair((x => pair(head([2, null]), x))(head(null)), [[2, null], null]))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

equal({ { undefined; const rest = append([null, null], reverse([[2, null], null])); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

equal({ { undefined; const rest = append([null, null], reverse([[2, null], null])); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] reverse runs

equal({ { undefined; const rest = append([null, null], $reverse([[2, null], null], null)); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] reverse runs

equal({ { undefined; const rest = append([null, null], $reverse([[2, null], null], null)); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] $reverse runs

equal({ { undefined; const rest = append([null, null], ((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([[2, null], null], null)); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] $reverse runs

equal({ { undefined; const rest = append([null, null], ((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([[2, null], null], null)); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] [[2, null], null], null substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

equal({ { undefined; const rest = append([null, null], is_null([[2, null], null]) ? null : $reverse(tail([[2, null], null]), pair(head([[2, null], null]), null))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] [[2, null], null], null substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

equal({ { undefined; const rest = append([null, null], is_null([[2, null], null]) ? null : $reverse(tail([[2, null], null]), pair(head([[2, null], null]), null))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] is_null runs

equal({ { undefined; const rest = append([null, null], false ? null : $reverse(tail([[2, null], null]), pair(head([[2, null], null]), null))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] is_null runs

equal({ { undefined; const rest = append([null, null], false ? null : $reverse(tail([[2, null], null]), pair(head([[2, null], null]), null))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal({ { undefined; const rest = append([null, null], $reverse(tail([[2, null], null]), pair(head([[2, null], null]), null))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal({ { undefined; const rest = append([null, null], $reverse(tail([[2, null], null]), pair(head([[2, null], null]), null))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] tail runs

equal({ { undefined; const rest = append([null, null], $reverse(null, pair(head([[2, null], null]), null))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] tail runs

equal({ { undefined; const rest = append([null, null], $reverse(null, pair(head([[2, null], null]), null))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] head runs

equal({ { undefined; const rest = append([null, null], $reverse(null, pair([2, null], null))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] head runs

equal({ { undefined; const rest = append([null, null], $reverse(null, pair([2, null], null))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] pair runs

equal({ { undefined; const rest = append([null, null], $reverse(null, [[2, null], null])); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] pair runs

equal({ { undefined; const rest = append([null, null], $reverse(null, [[2, null], null])); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] $reverse runs

equal({ { undefined; const rest = append([null, null], ((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))(null, [[2, null], null])); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] $reverse runs

equal({ { undefined; const rest = append([null, null], ((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))(null, [[2, null], null])); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] null, [[2, null], null] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

equal({ { undefined; const rest = append([null, null], is_null(null) ? [[2, null], null] : $reverse(tail(null), pair(head(null), [[2, null], null]))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] null, [[2, null], null] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

equal({ { undefined; const rest = append([null, null], is_null(null) ? [[2, null], null] : $reverse(tail(null), pair(head(null), [[2, null], null]))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] is_null runs

equal({ { undefined; const rest = append([null, null], true ? [[2, null], null] : $reverse(tail(null), pair(head(null), [[2, null], null]))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] is_null runs

equal({ { undefined; const rest = append([null, null], true ? [[2, null], null] : $reverse(tail(null), pair(head(null), [[2, null], null]))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

equal({ { undefined; const rest = append([null, null], [[2, null], null]); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

equal({ { undefined; const rest = append([null, null], [[2, null], null]); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] append runs

equal({ { undefined; const rest = $append([null, null], [[2, null], null], xs => xs); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] append runs

equal({ { undefined; const rest = $append([null, null], [[2, null], null], xs => xs); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] $append runs

equal({ { undefined; const rest = ((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([null, null], [[2, null], null], xs => xs); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] $append runs

equal({ { undefined; const rest = ((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([null, null], [[2, null], null], xs => xs); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] [null, null], [[2, null], null], xs => xs substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

equal({ { undefined; const rest = is_null([null, null]) ? (xs => xs)([[2, null], null]) : $append(tail([null, null]), [[2, null], null], zs => (xs => xs)(pair(head([null, null]), zs))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] [null, null], [[2, null], null], xs => xs substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

equal({ { undefined; const rest = is_null([null, null]) ? (xs => xs)([[2, null], null]) : $append(tail([null, null]), [[2, null], null], zs => (xs => xs)(pair(head([null, null]), zs))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] is_null runs

equal({ { undefined; const rest = false ? (xs => xs)([[2, null], null]) : $append(tail([null, null]), [[2, null], null], zs => (xs => xs)(pair(head([null, null]), zs))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] is_null runs

equal({ { undefined; const rest = false ? (xs => xs)([[2, null], null]) : $append(tail([null, null]), [[2, null], null], zs => (xs => xs)(pair(head([null, null]), zs))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal({ { undefined; const rest = $append(tail([null, null]), [[2, null], null], zs => (xs => xs)(pair(head([null, null]), zs))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal({ { undefined; const rest = $append(tail([null, null]), [[2, null], null], zs => (xs => xs)(pair(head([null, null]), zs))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] tail runs

equal({ { undefined; const rest = $append(null, [[2, null], null], zs => (xs => xs)(pair(head([null, null]), zs))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] tail runs

equal({ { undefined; const rest = $append(null, [[2, null], null], zs => (xs => xs)(pair(head([null, null]), zs))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] $append runs

equal({ { undefined; const rest = ((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))(null, [[2, null], null], zs => (xs => xs)(pair(head([null, null]), zs))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] $append runs

equal({ { undefined; const rest = ((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))(null, [[2, null], null], zs => (xs => xs)(pair(head([null, null]), zs))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] null, [[2, null], null], zs => (xs => xs)(pair(head([null, null]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

equal({ { undefined; const rest = is_null(null) ? (zs => (xs => xs)(pair(head([null, null]), zs)))([[2, null], null]) : $append(tail(null), [[2, null], null], zs => (zs => (xs => xs)(pair(head([null, null]), zs)))(pair(head(null), zs))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] null, [[2, null], null], zs => (xs => xs)(pair(head([null, null]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

equal({ { undefined; const rest = is_null(null) ? (zs => (xs => xs)(pair(head([null, null]), zs)))([[2, null], null]) : $append(tail(null), [[2, null], null], zs => (zs => (xs => xs)(pair(head([null, null]), zs)))(pair(head(null), zs))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] is_null runs

equal({ { undefined; const rest = true ? (zs => (xs => xs)(pair(head([null, null]), zs)))([[2, null], null]) : $append(tail(null), [[2, null], null], zs => (zs => (xs => xs)(pair(head([null, null]), zs)))(pair(head(null), zs))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] is_null runs

equal({ { undefined; const rest = true ? (zs => (xs => xs)(pair(head([null, null]), zs)))([[2, null], null]) : $append(tail(null), [[2, null], null], zs => (zs => (xs => xs)(pair(head([null, null]), zs)))(pair(head(null), zs))); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

equal({ { undefined; const rest = (zs => (xs => xs)(pair(head([null, null]), zs)))([[2, null], null]); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

equal({ { undefined; const rest = (zs => (xs => xs)(pair(head([null, null]), zs)))([[2, null], null]); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] [[2, null], null] substituted into zs of zs => (xs => xs)(pair(head([null, null]), zs))

equal({ { undefined; const rest = (xs => xs)(pair(head([null, null]), [[2, null], null])); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] [[2, null], null] substituted into zs of zs => (xs => xs)(pair(head([null, null]), zs))

equal({ { undefined; const rest = (xs => xs)(pair(head([null, null]), [[2, null], null])); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] head runs

equal({ { undefined; const rest = (xs => xs)(pair(null, [[2, null], null])); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] head runs

equal({ { undefined; const rest = (xs => xs)(pair(null, [[2, null], null])); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] pair runs

equal({ { undefined; const rest = (xs => xs)([null, [[2, null], null]]); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] pair runs

equal({ { undefined; const rest = (xs => xs)([null, [[2, null], null]]); return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] [null, [[2, null], null]] substituted into xs of xs => xs

equal({ { undefined; const rest = [null, [[2, null], null]]; return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] [null, [[2, null], null]] substituted into xs of xs => xs

equal({ { undefined; const rest = [null, [[2, null], null]]; return append(rest, map(x => pair(head([1, [2, null]]), x), rest)); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] Constant rest declared and substituted into the rest of block

equal({ { undefined; return append([null, [[2, null], null]], map(x => pair(head([1, [2, null]]), x), [null, [[2, null], null]])); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] Constant rest declared and substituted into the rest of block

equal({ { undefined; return append([null, [[2, null], null]], map(x => pair(head([1, [2, null]]), x), [null, [[2, null], null]])); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] undefined finished evaluating

equal({ { return append([null, [[2, null], null]], map(x => pair(head([1, [2, null]]), x), [null, [[2, null], null]])); }}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] undefined finished evaluating

equal({ { return append([null, [[2, null], null]], map(x => pair(head([1, [2, null]]), x), [null, [[2, null], null]])); }}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] return append([null, [[2, null], null]], map(x => pair(head([1, [2, null]]), x), [null, [[2, null], null]])); finished evaluating

equal({ return append([null, [[2, null], null]], map(x => pair(head([1, [2, null]]), x), [null, [[2, null], null]]));}, list(null, list(2), list(1), list(1, 2)));
[afterMarker] return append([null, [[2, null], null]], map(x => pair(head([1, [2, null]]), x), [null, [[2, null], null]])); finished evaluating

equal({ return append([null, [[2, null], null]], map(x => pair(head([1, [2, null]]), x), [null, [[2, null], null]]));}, list(null, list(2), list(1), list(1, 2)));
[beforeMarker] append([null, [[2, null], null]], map(x => pair(head([1, [2, null]]), x), [null, [[2, null], null]])) returned

equal(append([null, [[2, null], null]], map(x => pair(head([1, [2, null]]), x), [null, [[2, null], null]])), list(null, list(2), list(1), list(1, 2)));
[afterMarker] append([null, [[2, null], null]], map(x => pair(head([1, [2, null]]), x), [null, [[2, null], null]])) returned

equal(append([null, [[2, null], null]], map(x => pair(head([1, [2, null]]), x), [null, [[2, null], null]])), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] map runs

equal(append([null, [[2, null], null]], $map(x => pair(head([1, [2, null]]), x), [null, [[2, null], null]], null)), list(null, list(2), list(1), list(1, 2)));
[afterMarker] map runs

equal(append([null, [[2, null], null]], $map(x => pair(head([1, [2, null]]), x), [null, [[2, null], null]], null)), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] $map runs

equal(append([null, [[2, null], null]], ((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => pair(head([1, [2, null]]), x), [null, [[2, null], null]], null)), list(null, list(2), list(1), list(1, 2)));
[afterMarker] $map runs

equal(append([null, [[2, null], null]], ((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => pair(head([1, [2, null]]), x), [null, [[2, null], null]], null)), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] x => pair(head([1, [2, null]]), x), [null, [[2, null], null]], null substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

equal(append([null, [[2, null], null]], is_null([null, [[2, null], null]]) ? reverse(null) : $map(x => pair(head([1, [2, null]]), x), tail([null, [[2, null], null]]), pair((x => pair(head([1, [2, null]]), x))(head([null, [[2, null], null]])), null))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] x => pair(head([1, [2, null]]), x), [null, [[2, null], null]], null substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

equal(append([null, [[2, null], null]], is_null([null, [[2, null], null]]) ? reverse(null) : $map(x => pair(head([1, [2, null]]), x), tail([null, [[2, null], null]]), pair((x => pair(head([1, [2, null]]), x))(head([null, [[2, null], null]])), null))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] is_null runs

equal(append([null, [[2, null], null]], false ? reverse(null) : $map(x => pair(head([1, [2, null]]), x), tail([null, [[2, null], null]]), pair((x => pair(head([1, [2, null]]), x))(head([null, [[2, null], null]])), null))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] is_null runs

equal(append([null, [[2, null], null]], false ? reverse(null) : $map(x => pair(head([1, [2, null]]), x), tail([null, [[2, null], null]]), pair((x => pair(head([1, [2, null]]), x))(head([null, [[2, null], null]])), null))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal(append([null, [[2, null], null]], $map(x => pair(head([1, [2, null]]), x), tail([null, [[2, null], null]]), pair((x => pair(head([1, [2, null]]), x))(head([null, [[2, null], null]])), null))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal(append([null, [[2, null], null]], $map(x => pair(head([1, [2, null]]), x), tail([null, [[2, null], null]]), pair((x => pair(head([1, [2, null]]), x))(head([null, [[2, null], null]])), null))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] tail runs

equal(append([null, [[2, null], null]], $map(x => pair(head([1, [2, null]]), x), [[2, null], null], pair((x => pair(head([1, [2, null]]), x))(head([null, [[2, null], null]])), null))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] tail runs

equal(append([null, [[2, null], null]], $map(x => pair(head([1, [2, null]]), x), [[2, null], null], pair((x => pair(head([1, [2, null]]), x))(head([null, [[2, null], null]])), null))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] head runs

equal(append([null, [[2, null], null]], $map(x => pair(head([1, [2, null]]), x), [[2, null], null], pair((x => pair(head([1, [2, null]]), x))(null), null))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] head runs

equal(append([null, [[2, null], null]], $map(x => pair(head([1, [2, null]]), x), [[2, null], null], pair((x => pair(head([1, [2, null]]), x))(null), null))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] null substituted into x of x => pair(head([1, [2, null]]), x)

equal(append([null, [[2, null], null]], $map(x => pair(head([1, [2, null]]), x), [[2, null], null], pair(pair(head([1, [2, null]]), null), null))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] null substituted into x of x => pair(head([1, [2, null]]), x)

equal(append([null, [[2, null], null]], $map(x => pair(head([1, [2, null]]), x), [[2, null], null], pair(pair(head([1, [2, null]]), null), null))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] head runs

equal(append([null, [[2, null], null]], $map(x => pair(head([1, [2, null]]), x), [[2, null], null], pair(pair(1, null), null))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] head runs

equal(append([null, [[2, null], null]], $map(x => pair(head([1, [2, null]]), x), [[2, null], null], pair(pair(1, null), null))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] pair runs

equal(append([null, [[2, null], null]], $map(x => pair(head([1, [2, null]]), x), [[2, null], null], pair([1, null], null))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] pair runs

equal(append([null, [[2, null], null]], $map(x => pair(head([1, [2, null]]), x), [[2, null], null], pair([1, null], null))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] pair runs

equal(append([null, [[2, null], null]], $map(x => pair(head([1, [2, null]]), x), [[2, null], null], [[1, null], null])), list(null, list(2), list(1), list(1, 2)));
[afterMarker] pair runs

equal(append([null, [[2, null], null]], $map(x => pair(head([1, [2, null]]), x), [[2, null], null], [[1, null], null])), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] $map runs

equal(append([null, [[2, null], null]], ((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => pair(head([1, [2, null]]), x), [[2, null], null], [[1, null], null])), list(null, list(2), list(1), list(1, 2)));
[afterMarker] $map runs

equal(append([null, [[2, null], null]], ((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => pair(head([1, [2, null]]), x), [[2, null], null], [[1, null], null])), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] x => pair(head([1, [2, null]]), x), [[2, null], null], [[1, null], null] substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

equal(append([null, [[2, null], null]], is_null([[2, null], null]) ? reverse([[1, null], null]) : $map(x => pair(head([1, [2, null]]), x), tail([[2, null], null]), pair((x => pair(head([1, [2, null]]), x))(head([[2, null], null])), [[1, null], null]))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] x => pair(head([1, [2, null]]), x), [[2, null], null], [[1, null], null] substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

equal(append([null, [[2, null], null]], is_null([[2, null], null]) ? reverse([[1, null], null]) : $map(x => pair(head([1, [2, null]]), x), tail([[2, null], null]), pair((x => pair(head([1, [2, null]]), x))(head([[2, null], null])), [[1, null], null]))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] is_null runs

equal(append([null, [[2, null], null]], false ? reverse([[1, null], null]) : $map(x => pair(head([1, [2, null]]), x), tail([[2, null], null]), pair((x => pair(head([1, [2, null]]), x))(head([[2, null], null])), [[1, null], null]))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] is_null runs

equal(append([null, [[2, null], null]], false ? reverse([[1, null], null]) : $map(x => pair(head([1, [2, null]]), x), tail([[2, null], null]), pair((x => pair(head([1, [2, null]]), x))(head([[2, null], null])), [[1, null], null]))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal(append([null, [[2, null], null]], $map(x => pair(head([1, [2, null]]), x), tail([[2, null], null]), pair((x => pair(head([1, [2, null]]), x))(head([[2, null], null])), [[1, null], null]))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal(append([null, [[2, null], null]], $map(x => pair(head([1, [2, null]]), x), tail([[2, null], null]), pair((x => pair(head([1, [2, null]]), x))(head([[2, null], null])), [[1, null], null]))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] tail runs

equal(append([null, [[2, null], null]], $map(x => pair(head([1, [2, null]]), x), null, pair((x => pair(head([1, [2, null]]), x))(head([[2, null], null])), [[1, null], null]))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] tail runs

equal(append([null, [[2, null], null]], $map(x => pair(head([1, [2, null]]), x), null, pair((x => pair(head([1, [2, null]]), x))(head([[2, null], null])), [[1, null], null]))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] head runs

equal(append([null, [[2, null], null]], $map(x => pair(head([1, [2, null]]), x), null, pair((x => pair(head([1, [2, null]]), x))([2, null]), [[1, null], null]))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] head runs

equal(append([null, [[2, null], null]], $map(x => pair(head([1, [2, null]]), x), null, pair((x => pair(head([1, [2, null]]), x))([2, null]), [[1, null], null]))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] [2, null] substituted into x of x => pair(head([1, [2, null]]), x)

equal(append([null, [[2, null], null]], $map(x => pair(head([1, [2, null]]), x), null, pair(pair(head([1, [2, null]]), [2, null]), [[1, null], null]))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] [2, null] substituted into x of x => pair(head([1, [2, null]]), x)

equal(append([null, [[2, null], null]], $map(x => pair(head([1, [2, null]]), x), null, pair(pair(head([1, [2, null]]), [2, null]), [[1, null], null]))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] head runs

equal(append([null, [[2, null], null]], $map(x => pair(head([1, [2, null]]), x), null, pair(pair(1, [2, null]), [[1, null], null]))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] head runs

equal(append([null, [[2, null], null]], $map(x => pair(head([1, [2, null]]), x), null, pair(pair(1, [2, null]), [[1, null], null]))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] pair runs

equal(append([null, [[2, null], null]], $map(x => pair(head([1, [2, null]]), x), null, pair([1, [2, null]], [[1, null], null]))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] pair runs

equal(append([null, [[2, null], null]], $map(x => pair(head([1, [2, null]]), x), null, pair([1, [2, null]], [[1, null], null]))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] pair runs

equal(append([null, [[2, null], null]], $map(x => pair(head([1, [2, null]]), x), null, [[1, [2, null]], [[1, null], null]])), list(null, list(2), list(1), list(1, 2)));
[afterMarker] pair runs

equal(append([null, [[2, null], null]], $map(x => pair(head([1, [2, null]]), x), null, [[1, [2, null]], [[1, null], null]])), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] $map runs

equal(append([null, [[2, null], null]], ((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => pair(head([1, [2, null]]), x), null, [[1, [2, null]], [[1, null], null]])), list(null, list(2), list(1), list(1, 2)));
[afterMarker] $map runs

equal(append([null, [[2, null], null]], ((f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc)))(x => pair(head([1, [2, null]]), x), null, [[1, [2, null]], [[1, null], null]])), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] x => pair(head([1, [2, null]]), x), null, [[1, [2, null]], [[1, null], null]] substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

equal(append([null, [[2, null], null]], is_null(null) ? reverse([[1, [2, null]], [[1, null], null]]) : $map(x => pair(head([1, [2, null]]), x), tail(null), pair((x => pair(head([1, [2, null]]), x))(head(null)), [[1, [2, null]], [[1, null], null]]))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] x => pair(head([1, [2, null]]), x), null, [[1, [2, null]], [[1, null], null]] substituted into f, xs, acc of (f, xs, acc) => is_null(xs) ? reverse(acc) : $map(f, tail(xs), pair(f(head(xs)), acc))

equal(append([null, [[2, null], null]], is_null(null) ? reverse([[1, [2, null]], [[1, null], null]]) : $map(x => pair(head([1, [2, null]]), x), tail(null), pair((x => pair(head([1, [2, null]]), x))(head(null)), [[1, [2, null]], [[1, null], null]]))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] is_null runs

equal(append([null, [[2, null], null]], true ? reverse([[1, [2, null]], [[1, null], null]]) : $map(x => pair(head([1, [2, null]]), x), tail(null), pair((x => pair(head([1, [2, null]]), x))(head(null)), [[1, [2, null]], [[1, null], null]]))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] is_null runs

equal(append([null, [[2, null], null]], true ? reverse([[1, [2, null]], [[1, null], null]]) : $map(x => pair(head([1, [2, null]]), x), tail(null), pair((x => pair(head([1, [2, null]]), x))(head(null)), [[1, [2, null]], [[1, null], null]]))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

equal(append([null, [[2, null], null]], reverse([[1, [2, null]], [[1, null], null]])), list(null, list(2), list(1), list(1, 2)));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

equal(append([null, [[2, null], null]], reverse([[1, [2, null]], [[1, null], null]])), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] reverse runs

equal(append([null, [[2, null], null]], $reverse([[1, [2, null]], [[1, null], null]], null)), list(null, list(2), list(1), list(1, 2)));
[afterMarker] reverse runs

equal(append([null, [[2, null], null]], $reverse([[1, [2, null]], [[1, null], null]], null)), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] $reverse runs

equal(append([null, [[2, null], null]], ((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([[1, [2, null]], [[1, null], null]], null)), list(null, list(2), list(1), list(1, 2)));
[afterMarker] $reverse runs

equal(append([null, [[2, null], null]], ((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([[1, [2, null]], [[1, null], null]], null)), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] [[1, [2, null]], [[1, null], null]], null substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

equal(append([null, [[2, null], null]], is_null([[1, [2, null]], [[1, null], null]]) ? null : $reverse(tail([[1, [2, null]], [[1, null], null]]), pair(head([[1, [2, null]], [[1, null], null]]), null))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] [[1, [2, null]], [[1, null], null]], null substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

equal(append([null, [[2, null], null]], is_null([[1, [2, null]], [[1, null], null]]) ? null : $reverse(tail([[1, [2, null]], [[1, null], null]]), pair(head([[1, [2, null]], [[1, null], null]]), null))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] is_null runs

equal(append([null, [[2, null], null]], false ? null : $reverse(tail([[1, [2, null]], [[1, null], null]]), pair(head([[1, [2, null]], [[1, null], null]]), null))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] is_null runs

equal(append([null, [[2, null], null]], false ? null : $reverse(tail([[1, [2, null]], [[1, null], null]]), pair(head([[1, [2, null]], [[1, null], null]]), null))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal(append([null, [[2, null], null]], $reverse(tail([[1, [2, null]], [[1, null], null]]), pair(head([[1, [2, null]], [[1, null], null]]), null))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal(append([null, [[2, null], null]], $reverse(tail([[1, [2, null]], [[1, null], null]]), pair(head([[1, [2, null]], [[1, null], null]]), null))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] tail runs

equal(append([null, [[2, null], null]], $reverse([[1, null], null], pair(head([[1, [2, null]], [[1, null], null]]), null))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] tail runs

equal(append([null, [[2, null], null]], $reverse([[1, null], null], pair(head([[1, [2, null]], [[1, null], null]]), null))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] head runs

equal(append([null, [[2, null], null]], $reverse([[1, null], null], pair([1, [2, null]], null))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] head runs

equal(append([null, [[2, null], null]], $reverse([[1, null], null], pair([1, [2, null]], null))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] pair runs

equal(append([null, [[2, null], null]], $reverse([[1, null], null], [[1, [2, null]], null])), list(null, list(2), list(1), list(1, 2)));
[afterMarker] pair runs

equal(append([null, [[2, null], null]], $reverse([[1, null], null], [[1, [2, null]], null])), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] $reverse runs

equal(append([null, [[2, null], null]], ((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([[1, null], null], [[1, [2, null]], null])), list(null, list(2), list(1), list(1, 2)));
[afterMarker] $reverse runs

equal(append([null, [[2, null], null]], ((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))([[1, null], null], [[1, [2, null]], null])), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] [[1, null], null], [[1, [2, null]], null] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

equal(append([null, [[2, null], null]], is_null([[1, null], null]) ? [[1, [2, null]], null] : $reverse(tail([[1, null], null]), pair(head([[1, null], null]), [[1, [2, null]], null]))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] [[1, null], null], [[1, [2, null]], null] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

equal(append([null, [[2, null], null]], is_null([[1, null], null]) ? [[1, [2, null]], null] : $reverse(tail([[1, null], null]), pair(head([[1, null], null]), [[1, [2, null]], null]))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] is_null runs

equal(append([null, [[2, null], null]], false ? [[1, [2, null]], null] : $reverse(tail([[1, null], null]), pair(head([[1, null], null]), [[1, [2, null]], null]))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] is_null runs

equal(append([null, [[2, null], null]], false ? [[1, [2, null]], null] : $reverse(tail([[1, null], null]), pair(head([[1, null], null]), [[1, [2, null]], null]))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal(append([null, [[2, null], null]], $reverse(tail([[1, null], null]), pair(head([[1, null], null]), [[1, [2, null]], null]))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal(append([null, [[2, null], null]], $reverse(tail([[1, null], null]), pair(head([[1, null], null]), [[1, [2, null]], null]))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] tail runs

equal(append([null, [[2, null], null]], $reverse(null, pair(head([[1, null], null]), [[1, [2, null]], null]))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] tail runs

equal(append([null, [[2, null], null]], $reverse(null, pair(head([[1, null], null]), [[1, [2, null]], null]))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] head runs

equal(append([null, [[2, null], null]], $reverse(null, pair([1, null], [[1, [2, null]], null]))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] head runs

equal(append([null, [[2, null], null]], $reverse(null, pair([1, null], [[1, [2, null]], null]))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] pair runs

equal(append([null, [[2, null], null]], $reverse(null, [[1, null], [[1, [2, null]], null]])), list(null, list(2), list(1), list(1, 2)));
[afterMarker] pair runs

equal(append([null, [[2, null], null]], $reverse(null, [[1, null], [[1, [2, null]], null]])), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] $reverse runs

equal(append([null, [[2, null], null]], ((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))(null, [[1, null], [[1, [2, null]], null]])), list(null, list(2), list(1), list(1, 2)));
[afterMarker] $reverse runs

equal(append([null, [[2, null], null]], ((original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed)))(null, [[1, null], [[1, [2, null]], null]])), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] null, [[1, null], [[1, [2, null]], null]] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

equal(append([null, [[2, null], null]], is_null(null) ? [[1, null], [[1, [2, null]], null]] : $reverse(tail(null), pair(head(null), [[1, null], [[1, [2, null]], null]]))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] null, [[1, null], [[1, [2, null]], null]] substituted into original, reversed of (original, reversed) => is_null(original) ? reversed : $reverse(tail(original), pair(head(original), reversed))

equal(append([null, [[2, null], null]], is_null(null) ? [[1, null], [[1, [2, null]], null]] : $reverse(tail(null), pair(head(null), [[1, null], [[1, [2, null]], null]]))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] is_null runs

equal(append([null, [[2, null], null]], true ? [[1, null], [[1, [2, null]], null]] : $reverse(tail(null), pair(head(null), [[1, null], [[1, [2, null]], null]]))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] is_null runs

equal(append([null, [[2, null], null]], true ? [[1, null], [[1, [2, null]], null]] : $reverse(tail(null), pair(head(null), [[1, null], [[1, [2, null]], null]]))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

equal(append([null, [[2, null], null]], [[1, null], [[1, [2, null]], null]]), list(null, list(2), list(1), list(1, 2)));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

equal(append([null, [[2, null], null]], [[1, null], [[1, [2, null]], null]]), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] append runs

equal($append([null, [[2, null], null]], [[1, null], [[1, [2, null]], null]], xs => xs), list(null, list(2), list(1), list(1, 2)));
[afterMarker] append runs

equal($append([null, [[2, null], null]], [[1, null], [[1, [2, null]], null]], xs => xs), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] $append runs

equal(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([null, [[2, null], null]], [[1, null], [[1, [2, null]], null]], xs => xs), list(null, list(2), list(1), list(1, 2)));
[afterMarker] $append runs

equal(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([null, [[2, null], null]], [[1, null], [[1, [2, null]], null]], xs => xs), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] [null, [[2, null], null]], [[1, null], [[1, [2, null]], null]], xs => xs substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

equal(is_null([null, [[2, null], null]]) ? (xs => xs)([[1, null], [[1, [2, null]], null]]) : $append(tail([null, [[2, null], null]]), [[1, null], [[1, [2, null]], null]], zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] [null, [[2, null], null]], [[1, null], [[1, [2, null]], null]], xs => xs substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

equal(is_null([null, [[2, null], null]]) ? (xs => xs)([[1, null], [[1, [2, null]], null]]) : $append(tail([null, [[2, null], null]]), [[1, null], [[1, [2, null]], null]], zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] is_null runs

equal(false ? (xs => xs)([[1, null], [[1, [2, null]], null]]) : $append(tail([null, [[2, null], null]]), [[1, null], [[1, [2, null]], null]], zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] is_null runs

equal(false ? (xs => xs)([[1, null], [[1, [2, null]], null]]) : $append(tail([null, [[2, null], null]]), [[1, null], [[1, [2, null]], null]], zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal($append(tail([null, [[2, null], null]]), [[1, null], [[1, [2, null]], null]], zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal($append(tail([null, [[2, null], null]]), [[1, null], [[1, [2, null]], null]], zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] tail runs

equal($append([[2, null], null], [[1, null], [[1, [2, null]], null]], zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] tail runs

equal($append([[2, null], null], [[1, null], [[1, [2, null]], null]], zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] $append runs

equal(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([[2, null], null], [[1, null], [[1, [2, null]], null]], zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] $append runs

equal(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))([[2, null], null], [[1, null], [[1, [2, null]], null]], zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] [[2, null], null], [[1, null], [[1, [2, null]], null]], zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

equal(is_null([[2, null], null]) ? (zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs)))([[1, null], [[1, [2, null]], null]]) : $append(tail([[2, null], null]), [[1, null], [[1, [2, null]], null]], zs => (zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs)))(pair(head([[2, null], null]), zs))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] [[2, null], null], [[1, null], [[1, [2, null]], null]], zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

equal(is_null([[2, null], null]) ? (zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs)))([[1, null], [[1, [2, null]], null]]) : $append(tail([[2, null], null]), [[1, null], [[1, [2, null]], null]], zs => (zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs)))(pair(head([[2, null], null]), zs))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] is_null runs

equal(false ? (zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs)))([[1, null], [[1, [2, null]], null]]) : $append(tail([[2, null], null]), [[1, null], [[1, [2, null]], null]], zs => (zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs)))(pair(head([[2, null], null]), zs))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] is_null runs

equal(false ? (zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs)))([[1, null], [[1, [2, null]], null]]) : $append(tail([[2, null], null]), [[1, null], [[1, [2, null]], null]], zs => (zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs)))(pair(head([[2, null], null]), zs))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal($append(tail([[2, null], null]), [[1, null], [[1, [2, null]], null]], zs => (zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs)))(pair(head([[2, null], null]), zs))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

equal($append(tail([[2, null], null]), [[1, null], [[1, [2, null]], null]], zs => (zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs)))(pair(head([[2, null], null]), zs))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] tail runs

equal($append(null, [[1, null], [[1, [2, null]], null]], zs => (zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs)))(pair(head([[2, null], null]), zs))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] tail runs

equal($append(null, [[1, null], [[1, [2, null]], null]], zs => (zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs)))(pair(head([[2, null], null]), zs))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] $append runs

equal(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))(null, [[1, null], [[1, [2, null]], null]], zs => (zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs)))(pair(head([[2, null], null]), zs))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] $append runs

equal(((xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs))))(null, [[1, null], [[1, [2, null]], null]], zs => (zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs)))(pair(head([[2, null], null]), zs))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] null, [[1, null], [[1, [2, null]], null]], zs => (zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs)))(pair(head([[2, null], null]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

equal(is_null(null) ? (zs => (zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs)))(pair(head([[2, null], null]), zs)))([[1, null], [[1, [2, null]], null]]) : $append(tail(null), [[1, null], [[1, [2, null]], null]], zs => (zs => (zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs)))(pair(head([[2, null], null]), zs)))(pair(head(null), zs))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] null, [[1, null], [[1, [2, null]], null]], zs => (zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs)))(pair(head([[2, null], null]), zs)) substituted into xs, ys, cont of (xs, ys, cont) => is_null(xs) ? cont(ys) : $append(tail(xs), ys, zs => cont(pair(head(xs), zs)))

equal(is_null(null) ? (zs => (zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs)))(pair(head([[2, null], null]), zs)))([[1, null], [[1, [2, null]], null]]) : $append(tail(null), [[1, null], [[1, [2, null]], null]], zs => (zs => (zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs)))(pair(head([[2, null], null]), zs)))(pair(head(null), zs))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] is_null runs

equal(true ? (zs => (zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs)))(pair(head([[2, null], null]), zs)))([[1, null], [[1, [2, null]], null]]) : $append(tail(null), [[1, null], [[1, [2, null]], null]], zs => (zs => (zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs)))(pair(head([[2, null], null]), zs)))(pair(head(null), zs))), list(null, list(2), list(1), list(1, 2)));
[afterMarker] is_null runs

equal(true ? (zs => (zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs)))(pair(head([[2, null], null]), zs)))([[1, null], [[1, [2, null]], null]]) : $append(tail(null), [[1, null], [[1, [2, null]], null]], zs => (zs => (zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs)))(pair(head([[2, null], null]), zs)))(pair(head(null), zs))), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

equal((zs => (zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs)))(pair(head([[2, null], null]), zs)))([[1, null], [[1, [2, null]], null]]), list(null, list(2), list(1), list(1, 2)));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

equal((zs => (zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs)))(pair(head([[2, null], null]), zs)))([[1, null], [[1, [2, null]], null]]), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] [[1, null], [[1, [2, null]], null]] substituted into zs of zs => (zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs)))(pair(head([[2, null], null]), zs))

equal((zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs)))(pair(head([[2, null], null]), [[1, null], [[1, [2, null]], null]])), list(null, list(2), list(1), list(1, 2)));
[afterMarker] [[1, null], [[1, [2, null]], null]] substituted into zs of zs => (zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs)))(pair(head([[2, null], null]), zs))

equal((zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs)))(pair(head([[2, null], null]), [[1, null], [[1, [2, null]], null]])), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] head runs

equal((zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs)))(pair([2, null], [[1, null], [[1, [2, null]], null]])), list(null, list(2), list(1), list(1, 2)));
[afterMarker] head runs

equal((zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs)))(pair([2, null], [[1, null], [[1, [2, null]], null]])), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] pair runs

equal((zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs)))([[2, null], [[1, null], [[1, [2, null]], null]]]), list(null, list(2), list(1), list(1, 2)));
[afterMarker] pair runs

equal((zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs)))([[2, null], [[1, null], [[1, [2, null]], null]]]), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] [[2, null], [[1, null], [[1, [2, null]], null]]] substituted into zs of zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs))

equal((xs => xs)(pair(head([null, [[2, null], null]]), [[2, null], [[1, null], [[1, [2, null]], null]]])), list(null, list(2), list(1), list(1, 2)));
[afterMarker] [[2, null], [[1, null], [[1, [2, null]], null]]] substituted into zs of zs => (xs => xs)(pair(head([null, [[2, null], null]]), zs))

equal((xs => xs)(pair(head([null, [[2, null], null]]), [[2, null], [[1, null], [[1, [2, null]], null]]])), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] head runs

equal((xs => xs)(pair(null, [[2, null], [[1, null], [[1, [2, null]], null]]])), list(null, list(2), list(1), list(1, 2)));
[afterMarker] head runs

equal((xs => xs)(pair(null, [[2, null], [[1, null], [[1, [2, null]], null]]])), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] pair runs

equal((xs => xs)([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), list(null, list(2), list(1), list(1, 2)));
[afterMarker] pair runs

equal((xs => xs)([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), list(null, list(2), list(1), list(1, 2)));
[beforeMarker] [null, [[2, null], [[1, null], [[1, [2, null]], null]]]] substituted into xs of xs => xs

equal([null, [[2, null], [[1, null], [[1, [2, null]], null]]]], list(null, list(2), list(1), list(1, 2)));
[afterMarker] [null, [[2, null], [[1, null], [[1, [2, null]], null]]]] substituted into xs of xs => xs

equal([null, [[2, null], [[1, null], [[1, [2, null]], null]]]], list(null, list(2), list(1), list(1, 2)));
[beforeMarker] list runs

equal([null, [[2, null], [[1, null], [[1, [2, null]], null]]]], list(null, [2, null], list(1), list(1, 2)));
[afterMarker] list runs

equal([null, [[2, null], [[1, null], [[1, [2, null]], null]]]], list(null, [2, null], list(1), list(1, 2)));
[beforeMarker] list runs

equal([null, [[2, null], [[1, null], [[1, [2, null]], null]]]], list(null, [2, null], [1, null], list(1, 2)));
[afterMarker] list runs

equal([null, [[2, null], [[1, null], [[1, [2, null]], null]]]], list(null, [2, null], [1, null], list(1, 2)));
[beforeMarker] list runs

equal([null, [[2, null], [[1, null], [[1, [2, null]], null]]]], list(null, [2, null], [1, null], [1, [2, null]]));
[afterMarker] list runs

equal([null, [[2, null], [[1, null], [[1, [2, null]], null]]]], list(null, [2, null], [1, null], [1, [2, null]]));
[beforeMarker] list runs

equal([null, [[2, null], [[1, null], [[1, [2, null]], null]]]], [null, [[2, null], [[1, null], [[1, [2, null]], null]]]]);
[afterMarker] list runs

equal([null, [[2, null], [[1, null], [[1, [2, null]], null]]]], [null, [[2, null], [[1, null], [[1, [2, null]], null]]]]);
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)([null, [[2, null], [[1, null], [[1, [2, null]], null]]]], [null, [[2, null], [[1, null], [[1, [2, null]], null]]]]);
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)([null, [[2, null], [[1, null], [[1, [2, null]], null]]]], [null, [[2, null], [[1, null], [[1, [2, null]], null]]]]);
[beforeMarker] [null, [[2, null], [[1, null], [[1, [2, null]], null]]]], [null, [[2, null], [[1, null], [[1, [2, null]], null]]]] substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

is_pair([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) ? is_pair([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) && equal(head([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), head([null, [[2, null], [[1, null], [[1, [2, null]], null]]]])) && equal(tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]])) : is_null([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) ? is_null([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) : is_number([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) ? is_number([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) && [null, [[2, null], [[1, null], [[1, [2, null]], null]]]] === [null, [[2, null], [[1, null], [[1, [2, null]], null]]]] : is_boolean([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) ? is_boolean([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) && ([null, [[2, null], [[1, null], [[1, [2, null]], null]]]] && [null, [[2, null], [[1, null], [[1, [2, null]], null]]]] || ![null, [[2, null], [[1, null], [[1, [2, null]], null]]]] && ![null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) : is_string([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) ? is_string([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) && [null, [[2, null], [[1, null], [[1, [2, null]], null]]]] === [null, [[2, null], [[1, null], [[1, [2, null]], null]]]] : is_undefined([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) ? is_undefined([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) : is_function([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) ? is_function([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) && [null, [[2, null], [[1, null], [[1, [2, null]], null]]]] === [null, [[2, null], [[1, null], [[1, [2, null]], null]]]] : fals;
[afterMarker] [null, [[2, null], [[1, null], [[1, [2, null]], null]]]], [null, [[2, null], [[1, null], [[1, [2, null]], null]]]] substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

is_pair([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) ? is_pair([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) && equal(head([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), head([null, [[2, null], [[1, null], [[1, [2, null]], null]]]])) && equal(tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]])) : is_null([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) ? is_null([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) : is_number([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) ? is_number([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) && [null, [[2, null], [[1, null], [[1, [2, null]], null]]]] === [null, [[2, null], [[1, null], [[1, [2, null]], null]]]] : is_boolean([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) ? is_boolean([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) && ([null, [[2, null], [[1, null], [[1, [2, null]], null]]]] && [null, [[2, null], [[1, null], [[1, [2, null]], null]]]] || ![null, [[2, null], [[1, null], [[1, [2, null]], null]]]] && ![null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) : is_string([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) ? is_string([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) && [null, [[2, null], [[1, null], [[1, [2, null]], null]]]] === [null, [[2, null], [[1, null], [[1, [2, null]], null]]]] : is_undefined([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) ? is_undefined([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) : is_function([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) ? is_function([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) && [null, [[2, null], [[1, null], [[1, [2, null]], null]]]] === [null, [[2, null], [[1, null], [[1, [2, null]], null]]]] : fals;
[beforeMarker] is_pair runs

true ? is_pair([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) && equal(head([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), head([null, [[2, null], [[1, null], [[1, [2, null]], null]]]])) && equal(tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]])) : is_null([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) ? is_null([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) : is_number([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) ? is_number([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) && [null, [[2, null], [[1, null], [[1, [2, null]], null]]]] === [null, [[2, null], [[1, null], [[1, [2, null]], null]]]] : is_boolean([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) ? is_boolean([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) && ([null, [[2, null], [[1, null], [[1, [2, null]], null]]]] && [null, [[2, null], [[1, null], [[1, [2, null]], null]]]] || ![null, [[2, null], [[1, null], [[1, [2, null]], null]]]] && ![null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) : is_string([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) ? is_string([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) && [null, [[2, null], [[1, null], [[1, [2, null]], null]]]] === [null, [[2, null], [[1, null], [[1, [2, null]], null]]]] : is_undefined([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) ? is_undefined([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) : is_function([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) ? is_function([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) && [null, [[2, null], [[1, null], [[1, [2, null]], null]]]] === [null, [[2, null], [[1, null], [[1, [2, null]], null]]]] : fals;
[afterMarker] is_pair runs

true ? is_pair([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) && equal(head([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), head([null, [[2, null], [[1, null], [[1, [2, null]], null]]]])) && equal(tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]])) : is_null([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) ? is_null([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) : is_number([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) ? is_number([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) && [null, [[2, null], [[1, null], [[1, [2, null]], null]]]] === [null, [[2, null], [[1, null], [[1, [2, null]], null]]]] : is_boolean([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) ? is_boolean([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) && ([null, [[2, null], [[1, null], [[1, [2, null]], null]]]] && [null, [[2, null], [[1, null], [[1, [2, null]], null]]]] || ![null, [[2, null], [[1, null], [[1, [2, null]], null]]]] && ![null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) : is_string([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) ? is_string([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) && [null, [[2, null], [[1, null], [[1, [2, null]], null]]]] === [null, [[2, null], [[1, null], [[1, [2, null]], null]]]] : is_undefined([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) ? is_undefined([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) : is_function([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) ? is_function([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) && [null, [[2, null], [[1, null], [[1, [2, null]], null]]]] === [null, [[2, null], [[1, null], [[1, [2, null]], null]]]] : fals;
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_pair([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) && equal(head([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), head([null, [[2, null], [[1, null], [[1, [2, null]], null]]]])) && equal(tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_pair([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]) && equal(head([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), head([null, [[2, null], [[1, null], [[1, [2, null]], null]]]])) && equal(tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]));
[beforeMarker] is_pair runs

true && equal(head([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), head([null, [[2, null], [[1, null], [[1, [2, null]], null]]]])) && equal(tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]));
[afterMarker] is_pair runs

true && equal(head([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), head([null, [[2, null], [[1, null], [[1, [2, null]], null]]]])) && equal(tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(head([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), head([null, [[2, null], [[1, null], [[1, [2, null]], null]]]])) && equal(tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(head([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), head([null, [[2, null], [[1, null], [[1, [2, null]], null]]]])) && equal(tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]));
[beforeMarker] head runs

equal(null, head([null, [[2, null], [[1, null], [[1, [2, null]], null]]]])) && equal(tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]));
[afterMarker] head runs

equal(null, head([null, [[2, null], [[1, null], [[1, [2, null]], null]]]])) && equal(tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]));
[beforeMarker] head runs

equal(null, null) && equal(tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]));
[afterMarker] head runs

equal(null, null) && equal(tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]));
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(null, null) && equal(tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]));
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(null, null) && equal(tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]));
[beforeMarker] null, null substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair(null) ? is_pair(null) && equal(head(null), head(null)) && equal(tail(null), tail(null)) : is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals) && equal(tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]));
[afterMarker] null, null substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair(null) ? is_pair(null) && equal(head(null), head(null)) && equal(tail(null), tail(null)) : is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals) && equal(tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]));
[beforeMarker] is_pair runs

(false ? is_pair(null) && equal(head(null), head(null)) && equal(tail(null), tail(null)) : is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals) && equal(tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]));
[afterMarker] is_pair runs

(false ? is_pair(null) && equal(head(null), head(null)) && equal(tail(null), tail(null)) : is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals) && equal(tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals) && equal(tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals) && equal(tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]));
[beforeMarker] is_null runs

(true ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals) && equal(tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]));
[afterMarker] is_null runs

(true ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals) && equal(tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_null(null) && equal(tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_null(null) && equal(tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]));
[beforeMarker] is_null runs

true && equal(tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]));
[afterMarker] is_null runs

true && equal(tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]), tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]));
[beforeMarker] tail runs

equal([[2, null], [[1, null], [[1, [2, null]], null]]], tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]));
[afterMarker] tail runs

equal([[2, null], [[1, null], [[1, [2, null]], null]]], tail([null, [[2, null], [[1, null], [[1, [2, null]], null]]]]));
[beforeMarker] tail runs

equal([[2, null], [[1, null], [[1, [2, null]], null]]], [[2, null], [[1, null], [[1, [2, null]], null]]]);
[afterMarker] tail runs

equal([[2, null], [[1, null], [[1, [2, null]], null]]], [[2, null], [[1, null], [[1, [2, null]], null]]]);
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)([[2, null], [[1, null], [[1, [2, null]], null]]], [[2, null], [[1, null], [[1, [2, null]], null]]]);
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)([[2, null], [[1, null], [[1, [2, null]], null]]], [[2, null], [[1, null], [[1, [2, null]], null]]]);
[beforeMarker] [[2, null], [[1, null], [[1, [2, null]], null]]], [[2, null], [[1, null], [[1, [2, null]], null]]] substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

is_pair([[2, null], [[1, null], [[1, [2, null]], null]]]) ? is_pair([[2, null], [[1, null], [[1, [2, null]], null]]]) && equal(head([[2, null], [[1, null], [[1, [2, null]], null]]]), head([[2, null], [[1, null], [[1, [2, null]], null]]])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]])) : is_null([[2, null], [[1, null], [[1, [2, null]], null]]]) ? is_null([[2, null], [[1, null], [[1, [2, null]], null]]]) : is_number([[2, null], [[1, null], [[1, [2, null]], null]]]) ? is_number([[2, null], [[1, null], [[1, [2, null]], null]]]) && [[2, null], [[1, null], [[1, [2, null]], null]]] === [[2, null], [[1, null], [[1, [2, null]], null]]] : is_boolean([[2, null], [[1, null], [[1, [2, null]], null]]]) ? is_boolean([[2, null], [[1, null], [[1, [2, null]], null]]]) && ([[2, null], [[1, null], [[1, [2, null]], null]]] && [[2, null], [[1, null], [[1, [2, null]], null]]] || ![[2, null], [[1, null], [[1, [2, null]], null]]] && ![[2, null], [[1, null], [[1, [2, null]], null]]]) : is_string([[2, null], [[1, null], [[1, [2, null]], null]]]) ? is_string([[2, null], [[1, null], [[1, [2, null]], null]]]) && [[2, null], [[1, null], [[1, [2, null]], null]]] === [[2, null], [[1, null], [[1, [2, null]], null]]] : is_undefined([[2, null], [[1, null], [[1, [2, null]], null]]]) ? is_undefined([[2, null], [[1, null], [[1, [2, null]], null]]]) : is_function([[2, null], [[1, null], [[1, [2, null]], null]]]) ? is_function([[2, null], [[1, null], [[1, [2, null]], null]]]) && [[2, null], [[1, null], [[1, [2, null]], null]]] === [[2, null], [[1, null], [[1, [2, null]], null]]] : fals;
[afterMarker] [[2, null], [[1, null], [[1, [2, null]], null]]], [[2, null], [[1, null], [[1, [2, null]], null]]] substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

is_pair([[2, null], [[1, null], [[1, [2, null]], null]]]) ? is_pair([[2, null], [[1, null], [[1, [2, null]], null]]]) && equal(head([[2, null], [[1, null], [[1, [2, null]], null]]]), head([[2, null], [[1, null], [[1, [2, null]], null]]])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]])) : is_null([[2, null], [[1, null], [[1, [2, null]], null]]]) ? is_null([[2, null], [[1, null], [[1, [2, null]], null]]]) : is_number([[2, null], [[1, null], [[1, [2, null]], null]]]) ? is_number([[2, null], [[1, null], [[1, [2, null]], null]]]) && [[2, null], [[1, null], [[1, [2, null]], null]]] === [[2, null], [[1, null], [[1, [2, null]], null]]] : is_boolean([[2, null], [[1, null], [[1, [2, null]], null]]]) ? is_boolean([[2, null], [[1, null], [[1, [2, null]], null]]]) && ([[2, null], [[1, null], [[1, [2, null]], null]]] && [[2, null], [[1, null], [[1, [2, null]], null]]] || ![[2, null], [[1, null], [[1, [2, null]], null]]] && ![[2, null], [[1, null], [[1, [2, null]], null]]]) : is_string([[2, null], [[1, null], [[1, [2, null]], null]]]) ? is_string([[2, null], [[1, null], [[1, [2, null]], null]]]) && [[2, null], [[1, null], [[1, [2, null]], null]]] === [[2, null], [[1, null], [[1, [2, null]], null]]] : is_undefined([[2, null], [[1, null], [[1, [2, null]], null]]]) ? is_undefined([[2, null], [[1, null], [[1, [2, null]], null]]]) : is_function([[2, null], [[1, null], [[1, [2, null]], null]]]) ? is_function([[2, null], [[1, null], [[1, [2, null]], null]]]) && [[2, null], [[1, null], [[1, [2, null]], null]]] === [[2, null], [[1, null], [[1, [2, null]], null]]] : fals;
[beforeMarker] is_pair runs

true ? is_pair([[2, null], [[1, null], [[1, [2, null]], null]]]) && equal(head([[2, null], [[1, null], [[1, [2, null]], null]]]), head([[2, null], [[1, null], [[1, [2, null]], null]]])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]])) : is_null([[2, null], [[1, null], [[1, [2, null]], null]]]) ? is_null([[2, null], [[1, null], [[1, [2, null]], null]]]) : is_number([[2, null], [[1, null], [[1, [2, null]], null]]]) ? is_number([[2, null], [[1, null], [[1, [2, null]], null]]]) && [[2, null], [[1, null], [[1, [2, null]], null]]] === [[2, null], [[1, null], [[1, [2, null]], null]]] : is_boolean([[2, null], [[1, null], [[1, [2, null]], null]]]) ? is_boolean([[2, null], [[1, null], [[1, [2, null]], null]]]) && ([[2, null], [[1, null], [[1, [2, null]], null]]] && [[2, null], [[1, null], [[1, [2, null]], null]]] || ![[2, null], [[1, null], [[1, [2, null]], null]]] && ![[2, null], [[1, null], [[1, [2, null]], null]]]) : is_string([[2, null], [[1, null], [[1, [2, null]], null]]]) ? is_string([[2, null], [[1, null], [[1, [2, null]], null]]]) && [[2, null], [[1, null], [[1, [2, null]], null]]] === [[2, null], [[1, null], [[1, [2, null]], null]]] : is_undefined([[2, null], [[1, null], [[1, [2, null]], null]]]) ? is_undefined([[2, null], [[1, null], [[1, [2, null]], null]]]) : is_function([[2, null], [[1, null], [[1, [2, null]], null]]]) ? is_function([[2, null], [[1, null], [[1, [2, null]], null]]]) && [[2, null], [[1, null], [[1, [2, null]], null]]] === [[2, null], [[1, null], [[1, [2, null]], null]]] : fals;
[afterMarker] is_pair runs

true ? is_pair([[2, null], [[1, null], [[1, [2, null]], null]]]) && equal(head([[2, null], [[1, null], [[1, [2, null]], null]]]), head([[2, null], [[1, null], [[1, [2, null]], null]]])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]])) : is_null([[2, null], [[1, null], [[1, [2, null]], null]]]) ? is_null([[2, null], [[1, null], [[1, [2, null]], null]]]) : is_number([[2, null], [[1, null], [[1, [2, null]], null]]]) ? is_number([[2, null], [[1, null], [[1, [2, null]], null]]]) && [[2, null], [[1, null], [[1, [2, null]], null]]] === [[2, null], [[1, null], [[1, [2, null]], null]]] : is_boolean([[2, null], [[1, null], [[1, [2, null]], null]]]) ? is_boolean([[2, null], [[1, null], [[1, [2, null]], null]]]) && ([[2, null], [[1, null], [[1, [2, null]], null]]] && [[2, null], [[1, null], [[1, [2, null]], null]]] || ![[2, null], [[1, null], [[1, [2, null]], null]]] && ![[2, null], [[1, null], [[1, [2, null]], null]]]) : is_string([[2, null], [[1, null], [[1, [2, null]], null]]]) ? is_string([[2, null], [[1, null], [[1, [2, null]], null]]]) && [[2, null], [[1, null], [[1, [2, null]], null]]] === [[2, null], [[1, null], [[1, [2, null]], null]]] : is_undefined([[2, null], [[1, null], [[1, [2, null]], null]]]) ? is_undefined([[2, null], [[1, null], [[1, [2, null]], null]]]) : is_function([[2, null], [[1, null], [[1, [2, null]], null]]]) ? is_function([[2, null], [[1, null], [[1, [2, null]], null]]]) && [[2, null], [[1, null], [[1, [2, null]], null]]] === [[2, null], [[1, null], [[1, [2, null]], null]]] : fals;
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_pair([[2, null], [[1, null], [[1, [2, null]], null]]]) && equal(head([[2, null], [[1, null], [[1, [2, null]], null]]]), head([[2, null], [[1, null], [[1, [2, null]], null]]])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_pair([[2, null], [[1, null], [[1, [2, null]], null]]]) && equal(head([[2, null], [[1, null], [[1, [2, null]], null]]]), head([[2, null], [[1, null], [[1, [2, null]], null]]])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[beforeMarker] is_pair runs

true && equal(head([[2, null], [[1, null], [[1, [2, null]], null]]]), head([[2, null], [[1, null], [[1, [2, null]], null]]])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[afterMarker] is_pair runs

true && equal(head([[2, null], [[1, null], [[1, [2, null]], null]]]), head([[2, null], [[1, null], [[1, [2, null]], null]]])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(head([[2, null], [[1, null], [[1, [2, null]], null]]]), head([[2, null], [[1, null], [[1, [2, null]], null]]])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(head([[2, null], [[1, null], [[1, [2, null]], null]]]), head([[2, null], [[1, null], [[1, [2, null]], null]]])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[beforeMarker] head runs

equal([2, null], head([[2, null], [[1, null], [[1, [2, null]], null]]])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[afterMarker] head runs

equal([2, null], head([[2, null], [[1, null], [[1, [2, null]], null]]])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[beforeMarker] head runs

equal([2, null], [2, null]) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[afterMarker] head runs

equal([2, null], [2, null]) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)([2, null], [2, null]) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)([2, null], [2, null]) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[beforeMarker] [2, null], [2, null] substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair([2, null]) ? is_pair([2, null]) && equal(head([2, null]), head([2, null])) && equal(tail([2, null]), tail([2, null])) : is_null([2, null]) ? is_null([2, null]) : is_number([2, null]) ? is_number([2, null]) && [2, null] === [2, null] : is_boolean([2, null]) ? is_boolean([2, null]) && ([2, null] && [2, null] || ![2, null] && ![2, null]) : is_string([2, null]) ? is_string([2, null]) && [2, null] === [2, null] : is_undefined([2, null]) ? is_undefined([2, null]) : is_function([2, null]) ? is_function([2, null]) && [2, null] === [2, null] : fals) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[afterMarker] [2, null], [2, null] substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair([2, null]) ? is_pair([2, null]) && equal(head([2, null]), head([2, null])) && equal(tail([2, null]), tail([2, null])) : is_null([2, null]) ? is_null([2, null]) : is_number([2, null]) ? is_number([2, null]) && [2, null] === [2, null] : is_boolean([2, null]) ? is_boolean([2, null]) && ([2, null] && [2, null] || ![2, null] && ![2, null]) : is_string([2, null]) ? is_string([2, null]) && [2, null] === [2, null] : is_undefined([2, null]) ? is_undefined([2, null]) : is_function([2, null]) ? is_function([2, null]) && [2, null] === [2, null] : fals) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[beforeMarker] is_pair runs

(true ? is_pair([2, null]) && equal(head([2, null]), head([2, null])) && equal(tail([2, null]), tail([2, null])) : is_null([2, null]) ? is_null([2, null]) : is_number([2, null]) ? is_number([2, null]) && [2, null] === [2, null] : is_boolean([2, null]) ? is_boolean([2, null]) && ([2, null] && [2, null] || ![2, null] && ![2, null]) : is_string([2, null]) ? is_string([2, null]) && [2, null] === [2, null] : is_undefined([2, null]) ? is_undefined([2, null]) : is_function([2, null]) ? is_function([2, null]) && [2, null] === [2, null] : fals) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[afterMarker] is_pair runs

(true ? is_pair([2, null]) && equal(head([2, null]), head([2, null])) && equal(tail([2, null]), tail([2, null])) : is_null([2, null]) ? is_null([2, null]) : is_number([2, null]) ? is_number([2, null]) && [2, null] === [2, null] : is_boolean([2, null]) ? is_boolean([2, null]) && ([2, null] && [2, null] || ![2, null] && ![2, null]) : is_string([2, null]) ? is_string([2, null]) && [2, null] === [2, null] : is_undefined([2, null]) ? is_undefined([2, null]) : is_function([2, null]) ? is_function([2, null]) && [2, null] === [2, null] : fals) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_pair([2, null]) && equal(head([2, null]), head([2, null])) && equal(tail([2, null]), tail([2, null])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_pair([2, null]) && equal(head([2, null]), head([2, null])) && equal(tail([2, null]), tail([2, null])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[beforeMarker] is_pair runs

true && equal(head([2, null]), head([2, null])) && equal(tail([2, null]), tail([2, null])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[afterMarker] is_pair runs

true && equal(head([2, null]), head([2, null])) && equal(tail([2, null]), tail([2, null])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(head([2, null]), head([2, null])) && equal(tail([2, null]), tail([2, null])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(head([2, null]), head([2, null])) && equal(tail([2, null]), tail([2, null])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[beforeMarker] head runs

equal(2, head([2, null])) && equal(tail([2, null]), tail([2, null])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[afterMarker] head runs

equal(2, head([2, null])) && equal(tail([2, null]), tail([2, null])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[beforeMarker] head runs

equal(2, 2) && equal(tail([2, null]), tail([2, null])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[afterMarker] head runs

equal(2, 2) && equal(tail([2, null]), tail([2, null])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(2, 2) && equal(tail([2, null]), tail([2, null])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(2, 2) && equal(tail([2, null]), tail([2, null])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[beforeMarker] 2, 2 substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair(2) ? is_pair(2) && equal(head(2), head(2)) && equal(tail(2), tail(2)) : is_null(2) ? is_null(2) : is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, null]), tail([2, null])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[afterMarker] 2, 2 substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair(2) ? is_pair(2) && equal(head(2), head(2)) && equal(tail(2), tail(2)) : is_null(2) ? is_null(2) : is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, null]), tail([2, null])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[beforeMarker] is_pair runs

(false ? is_pair(2) && equal(head(2), head(2)) && equal(tail(2), tail(2)) : is_null(2) ? is_null(2) : is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, null]), tail([2, null])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[afterMarker] is_pair runs

(false ? is_pair(2) && equal(head(2), head(2)) && equal(tail(2), tail(2)) : is_null(2) ? is_null(2) : is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, null]), tail([2, null])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_null(2) ? is_null(2) : is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, null]), tail([2, null])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_null(2) ? is_null(2) : is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, null]), tail([2, null])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[beforeMarker] is_null runs

(false ? is_null(2) : is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, null]), tail([2, null])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[afterMarker] is_null runs

(false ? is_null(2) : is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, null]), tail([2, null])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, null]), tail([2, null])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, null]), tail([2, null])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[beforeMarker] is_number runs

(true ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, null]), tail([2, null])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[afterMarker] is_number runs

(true ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, null]), tail([2, null])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_number(2) && 2 === 2 && equal(tail([2, null]), tail([2, null])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_number(2) && 2 === 2 && equal(tail([2, null]), tail([2, null])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[beforeMarker] is_number runs

true && 2 === 2 && equal(tail([2, null]), tail([2, null])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[afterMarker] is_number runs

true && 2 === 2 && equal(tail([2, null]), tail([2, null])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

2 === 2 && equal(tail([2, null]), tail([2, null])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

2 === 2 && equal(tail([2, null]), tail([2, null])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[beforeMarker] Binary expression 2 === 2 evaluated

true && equal(tail([2, null]), tail([2, null])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[afterMarker] Binary expression 2 === 2 evaluated

true && equal(tail([2, null]), tail([2, null])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(tail([2, null]), tail([2, null])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(tail([2, null]), tail([2, null])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[beforeMarker] tail runs

equal(null, tail([2, null])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[afterMarker] tail runs

equal(null, tail([2, null])) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[beforeMarker] tail runs

equal(null, null) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[afterMarker] tail runs

equal(null, null) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(null, null) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(null, null) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[beforeMarker] null, null substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair(null) ? is_pair(null) && equal(head(null), head(null)) && equal(tail(null), tail(null)) : is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[afterMarker] null, null substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair(null) ? is_pair(null) && equal(head(null), head(null)) && equal(tail(null), tail(null)) : is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[beforeMarker] is_pair runs

(false ? is_pair(null) && equal(head(null), head(null)) && equal(tail(null), tail(null)) : is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[afterMarker] is_pair runs

(false ? is_pair(null) && equal(head(null), head(null)) && equal(tail(null), tail(null)) : is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[beforeMarker] is_null runs

(true ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[afterMarker] is_null runs

(true ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_null(null) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_null(null) && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[beforeMarker] is_null runs

true && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[afterMarker] is_null runs

true && equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(tail([[2, null], [[1, null], [[1, [2, null]], null]]]), tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[beforeMarker] tail runs

equal([[1, null], [[1, [2, null]], null]], tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[afterMarker] tail runs

equal([[1, null], [[1, [2, null]], null]], tail([[2, null], [[1, null], [[1, [2, null]], null]]]));
[beforeMarker] tail runs

equal([[1, null], [[1, [2, null]], null]], [[1, null], [[1, [2, null]], null]]);
[afterMarker] tail runs

equal([[1, null], [[1, [2, null]], null]], [[1, null], [[1, [2, null]], null]]);
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)([[1, null], [[1, [2, null]], null]], [[1, null], [[1, [2, null]], null]]);
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)([[1, null], [[1, [2, null]], null]], [[1, null], [[1, [2, null]], null]]);
[beforeMarker] [[1, null], [[1, [2, null]], null]], [[1, null], [[1, [2, null]], null]] substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

is_pair([[1, null], [[1, [2, null]], null]]) ? is_pair([[1, null], [[1, [2, null]], null]]) && equal(head([[1, null], [[1, [2, null]], null]]), head([[1, null], [[1, [2, null]], null]])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]])) : is_null([[1, null], [[1, [2, null]], null]]) ? is_null([[1, null], [[1, [2, null]], null]]) : is_number([[1, null], [[1, [2, null]], null]]) ? is_number([[1, null], [[1, [2, null]], null]]) && [[1, null], [[1, [2, null]], null]] === [[1, null], [[1, [2, null]], null]] : is_boolean([[1, null], [[1, [2, null]], null]]) ? is_boolean([[1, null], [[1, [2, null]], null]]) && ([[1, null], [[1, [2, null]], null]] && [[1, null], [[1, [2, null]], null]] || ![[1, null], [[1, [2, null]], null]] && ![[1, null], [[1, [2, null]], null]]) : is_string([[1, null], [[1, [2, null]], null]]) ? is_string([[1, null], [[1, [2, null]], null]]) && [[1, null], [[1, [2, null]], null]] === [[1, null], [[1, [2, null]], null]] : is_undefined([[1, null], [[1, [2, null]], null]]) ? is_undefined([[1, null], [[1, [2, null]], null]]) : is_function([[1, null], [[1, [2, null]], null]]) ? is_function([[1, null], [[1, [2, null]], null]]) && [[1, null], [[1, [2, null]], null]] === [[1, null], [[1, [2, null]], null]] : fals;
[afterMarker] [[1, null], [[1, [2, null]], null]], [[1, null], [[1, [2, null]], null]] substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

is_pair([[1, null], [[1, [2, null]], null]]) ? is_pair([[1, null], [[1, [2, null]], null]]) && equal(head([[1, null], [[1, [2, null]], null]]), head([[1, null], [[1, [2, null]], null]])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]])) : is_null([[1, null], [[1, [2, null]], null]]) ? is_null([[1, null], [[1, [2, null]], null]]) : is_number([[1, null], [[1, [2, null]], null]]) ? is_number([[1, null], [[1, [2, null]], null]]) && [[1, null], [[1, [2, null]], null]] === [[1, null], [[1, [2, null]], null]] : is_boolean([[1, null], [[1, [2, null]], null]]) ? is_boolean([[1, null], [[1, [2, null]], null]]) && ([[1, null], [[1, [2, null]], null]] && [[1, null], [[1, [2, null]], null]] || ![[1, null], [[1, [2, null]], null]] && ![[1, null], [[1, [2, null]], null]]) : is_string([[1, null], [[1, [2, null]], null]]) ? is_string([[1, null], [[1, [2, null]], null]]) && [[1, null], [[1, [2, null]], null]] === [[1, null], [[1, [2, null]], null]] : is_undefined([[1, null], [[1, [2, null]], null]]) ? is_undefined([[1, null], [[1, [2, null]], null]]) : is_function([[1, null], [[1, [2, null]], null]]) ? is_function([[1, null], [[1, [2, null]], null]]) && [[1, null], [[1, [2, null]], null]] === [[1, null], [[1, [2, null]], null]] : fals;
[beforeMarker] is_pair runs

true ? is_pair([[1, null], [[1, [2, null]], null]]) && equal(head([[1, null], [[1, [2, null]], null]]), head([[1, null], [[1, [2, null]], null]])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]])) : is_null([[1, null], [[1, [2, null]], null]]) ? is_null([[1, null], [[1, [2, null]], null]]) : is_number([[1, null], [[1, [2, null]], null]]) ? is_number([[1, null], [[1, [2, null]], null]]) && [[1, null], [[1, [2, null]], null]] === [[1, null], [[1, [2, null]], null]] : is_boolean([[1, null], [[1, [2, null]], null]]) ? is_boolean([[1, null], [[1, [2, null]], null]]) && ([[1, null], [[1, [2, null]], null]] && [[1, null], [[1, [2, null]], null]] || ![[1, null], [[1, [2, null]], null]] && ![[1, null], [[1, [2, null]], null]]) : is_string([[1, null], [[1, [2, null]], null]]) ? is_string([[1, null], [[1, [2, null]], null]]) && [[1, null], [[1, [2, null]], null]] === [[1, null], [[1, [2, null]], null]] : is_undefined([[1, null], [[1, [2, null]], null]]) ? is_undefined([[1, null], [[1, [2, null]], null]]) : is_function([[1, null], [[1, [2, null]], null]]) ? is_function([[1, null], [[1, [2, null]], null]]) && [[1, null], [[1, [2, null]], null]] === [[1, null], [[1, [2, null]], null]] : fals;
[afterMarker] is_pair runs

true ? is_pair([[1, null], [[1, [2, null]], null]]) && equal(head([[1, null], [[1, [2, null]], null]]), head([[1, null], [[1, [2, null]], null]])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]])) : is_null([[1, null], [[1, [2, null]], null]]) ? is_null([[1, null], [[1, [2, null]], null]]) : is_number([[1, null], [[1, [2, null]], null]]) ? is_number([[1, null], [[1, [2, null]], null]]) && [[1, null], [[1, [2, null]], null]] === [[1, null], [[1, [2, null]], null]] : is_boolean([[1, null], [[1, [2, null]], null]]) ? is_boolean([[1, null], [[1, [2, null]], null]]) && ([[1, null], [[1, [2, null]], null]] && [[1, null], [[1, [2, null]], null]] || ![[1, null], [[1, [2, null]], null]] && ![[1, null], [[1, [2, null]], null]]) : is_string([[1, null], [[1, [2, null]], null]]) ? is_string([[1, null], [[1, [2, null]], null]]) && [[1, null], [[1, [2, null]], null]] === [[1, null], [[1, [2, null]], null]] : is_undefined([[1, null], [[1, [2, null]], null]]) ? is_undefined([[1, null], [[1, [2, null]], null]]) : is_function([[1, null], [[1, [2, null]], null]]) ? is_function([[1, null], [[1, [2, null]], null]]) && [[1, null], [[1, [2, null]], null]] === [[1, null], [[1, [2, null]], null]] : fals;
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_pair([[1, null], [[1, [2, null]], null]]) && equal(head([[1, null], [[1, [2, null]], null]]), head([[1, null], [[1, [2, null]], null]])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_pair([[1, null], [[1, [2, null]], null]]) && equal(head([[1, null], [[1, [2, null]], null]]), head([[1, null], [[1, [2, null]], null]])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[beforeMarker] is_pair runs

true && equal(head([[1, null], [[1, [2, null]], null]]), head([[1, null], [[1, [2, null]], null]])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[afterMarker] is_pair runs

true && equal(head([[1, null], [[1, [2, null]], null]]), head([[1, null], [[1, [2, null]], null]])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(head([[1, null], [[1, [2, null]], null]]), head([[1, null], [[1, [2, null]], null]])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(head([[1, null], [[1, [2, null]], null]]), head([[1, null], [[1, [2, null]], null]])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[beforeMarker] head runs

equal([1, null], head([[1, null], [[1, [2, null]], null]])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[afterMarker] head runs

equal([1, null], head([[1, null], [[1, [2, null]], null]])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[beforeMarker] head runs

equal([1, null], [1, null]) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[afterMarker] head runs

equal([1, null], [1, null]) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)([1, null], [1, null]) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)([1, null], [1, null]) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[beforeMarker] [1, null], [1, null] substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair([1, null]) ? is_pair([1, null]) && equal(head([1, null]), head([1, null])) && equal(tail([1, null]), tail([1, null])) : is_null([1, null]) ? is_null([1, null]) : is_number([1, null]) ? is_number([1, null]) && [1, null] === [1, null] : is_boolean([1, null]) ? is_boolean([1, null]) && ([1, null] && [1, null] || ![1, null] && ![1, null]) : is_string([1, null]) ? is_string([1, null]) && [1, null] === [1, null] : is_undefined([1, null]) ? is_undefined([1, null]) : is_function([1, null]) ? is_function([1, null]) && [1, null] === [1, null] : fals) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[afterMarker] [1, null], [1, null] substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair([1, null]) ? is_pair([1, null]) && equal(head([1, null]), head([1, null])) && equal(tail([1, null]), tail([1, null])) : is_null([1, null]) ? is_null([1, null]) : is_number([1, null]) ? is_number([1, null]) && [1, null] === [1, null] : is_boolean([1, null]) ? is_boolean([1, null]) && ([1, null] && [1, null] || ![1, null] && ![1, null]) : is_string([1, null]) ? is_string([1, null]) && [1, null] === [1, null] : is_undefined([1, null]) ? is_undefined([1, null]) : is_function([1, null]) ? is_function([1, null]) && [1, null] === [1, null] : fals) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[beforeMarker] is_pair runs

(true ? is_pair([1, null]) && equal(head([1, null]), head([1, null])) && equal(tail([1, null]), tail([1, null])) : is_null([1, null]) ? is_null([1, null]) : is_number([1, null]) ? is_number([1, null]) && [1, null] === [1, null] : is_boolean([1, null]) ? is_boolean([1, null]) && ([1, null] && [1, null] || ![1, null] && ![1, null]) : is_string([1, null]) ? is_string([1, null]) && [1, null] === [1, null] : is_undefined([1, null]) ? is_undefined([1, null]) : is_function([1, null]) ? is_function([1, null]) && [1, null] === [1, null] : fals) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[afterMarker] is_pair runs

(true ? is_pair([1, null]) && equal(head([1, null]), head([1, null])) && equal(tail([1, null]), tail([1, null])) : is_null([1, null]) ? is_null([1, null]) : is_number([1, null]) ? is_number([1, null]) && [1, null] === [1, null] : is_boolean([1, null]) ? is_boolean([1, null]) && ([1, null] && [1, null] || ![1, null] && ![1, null]) : is_string([1, null]) ? is_string([1, null]) && [1, null] === [1, null] : is_undefined([1, null]) ? is_undefined([1, null]) : is_function([1, null]) ? is_function([1, null]) && [1, null] === [1, null] : fals) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_pair([1, null]) && equal(head([1, null]), head([1, null])) && equal(tail([1, null]), tail([1, null])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_pair([1, null]) && equal(head([1, null]), head([1, null])) && equal(tail([1, null]), tail([1, null])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[beforeMarker] is_pair runs

true && equal(head([1, null]), head([1, null])) && equal(tail([1, null]), tail([1, null])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[afterMarker] is_pair runs

true && equal(head([1, null]), head([1, null])) && equal(tail([1, null]), tail([1, null])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(head([1, null]), head([1, null])) && equal(tail([1, null]), tail([1, null])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(head([1, null]), head([1, null])) && equal(tail([1, null]), tail([1, null])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[beforeMarker] head runs

equal(1, head([1, null])) && equal(tail([1, null]), tail([1, null])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[afterMarker] head runs

equal(1, head([1, null])) && equal(tail([1, null]), tail([1, null])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[beforeMarker] head runs

equal(1, 1) && equal(tail([1, null]), tail([1, null])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[afterMarker] head runs

equal(1, 1) && equal(tail([1, null]), tail([1, null])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(1, 1) && equal(tail([1, null]), tail([1, null])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(1, 1) && equal(tail([1, null]), tail([1, null])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[beforeMarker] 1, 1 substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair(1) ? is_pair(1) && equal(head(1), head(1)) && equal(tail(1), tail(1)) : is_null(1) ? is_null(1) : is_number(1) ? is_number(1) && 1 === 1 : is_boolean(1) ? is_boolean(1) && (1 && 1 || !1 && !1) : is_string(1) ? is_string(1) && 1 === 1 : is_undefined(1) ? is_undefined(1) : is_function(1) ? is_function(1) && 1 === 1 : fals) && equal(tail([1, null]), tail([1, null])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[afterMarker] 1, 1 substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair(1) ? is_pair(1) && equal(head(1), head(1)) && equal(tail(1), tail(1)) : is_null(1) ? is_null(1) : is_number(1) ? is_number(1) && 1 === 1 : is_boolean(1) ? is_boolean(1) && (1 && 1 || !1 && !1) : is_string(1) ? is_string(1) && 1 === 1 : is_undefined(1) ? is_undefined(1) : is_function(1) ? is_function(1) && 1 === 1 : fals) && equal(tail([1, null]), tail([1, null])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[beforeMarker] is_pair runs

(false ? is_pair(1) && equal(head(1), head(1)) && equal(tail(1), tail(1)) : is_null(1) ? is_null(1) : is_number(1) ? is_number(1) && 1 === 1 : is_boolean(1) ? is_boolean(1) && (1 && 1 || !1 && !1) : is_string(1) ? is_string(1) && 1 === 1 : is_undefined(1) ? is_undefined(1) : is_function(1) ? is_function(1) && 1 === 1 : fals) && equal(tail([1, null]), tail([1, null])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[afterMarker] is_pair runs

(false ? is_pair(1) && equal(head(1), head(1)) && equal(tail(1), tail(1)) : is_null(1) ? is_null(1) : is_number(1) ? is_number(1) && 1 === 1 : is_boolean(1) ? is_boolean(1) && (1 && 1 || !1 && !1) : is_string(1) ? is_string(1) && 1 === 1 : is_undefined(1) ? is_undefined(1) : is_function(1) ? is_function(1) && 1 === 1 : fals) && equal(tail([1, null]), tail([1, null])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_null(1) ? is_null(1) : is_number(1) ? is_number(1) && 1 === 1 : is_boolean(1) ? is_boolean(1) && (1 && 1 || !1 && !1) : is_string(1) ? is_string(1) && 1 === 1 : is_undefined(1) ? is_undefined(1) : is_function(1) ? is_function(1) && 1 === 1 : fals) && equal(tail([1, null]), tail([1, null])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_null(1) ? is_null(1) : is_number(1) ? is_number(1) && 1 === 1 : is_boolean(1) ? is_boolean(1) && (1 && 1 || !1 && !1) : is_string(1) ? is_string(1) && 1 === 1 : is_undefined(1) ? is_undefined(1) : is_function(1) ? is_function(1) && 1 === 1 : fals) && equal(tail([1, null]), tail([1, null])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[beforeMarker] is_null runs

(false ? is_null(1) : is_number(1) ? is_number(1) && 1 === 1 : is_boolean(1) ? is_boolean(1) && (1 && 1 || !1 && !1) : is_string(1) ? is_string(1) && 1 === 1 : is_undefined(1) ? is_undefined(1) : is_function(1) ? is_function(1) && 1 === 1 : fals) && equal(tail([1, null]), tail([1, null])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[afterMarker] is_null runs

(false ? is_null(1) : is_number(1) ? is_number(1) && 1 === 1 : is_boolean(1) ? is_boolean(1) && (1 && 1 || !1 && !1) : is_string(1) ? is_string(1) && 1 === 1 : is_undefined(1) ? is_undefined(1) : is_function(1) ? is_function(1) && 1 === 1 : fals) && equal(tail([1, null]), tail([1, null])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_number(1) ? is_number(1) && 1 === 1 : is_boolean(1) ? is_boolean(1) && (1 && 1 || !1 && !1) : is_string(1) ? is_string(1) && 1 === 1 : is_undefined(1) ? is_undefined(1) : is_function(1) ? is_function(1) && 1 === 1 : fals) && equal(tail([1, null]), tail([1, null])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_number(1) ? is_number(1) && 1 === 1 : is_boolean(1) ? is_boolean(1) && (1 && 1 || !1 && !1) : is_string(1) ? is_string(1) && 1 === 1 : is_undefined(1) ? is_undefined(1) : is_function(1) ? is_function(1) && 1 === 1 : fals) && equal(tail([1, null]), tail([1, null])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[beforeMarker] is_number runs

(true ? is_number(1) && 1 === 1 : is_boolean(1) ? is_boolean(1) && (1 && 1 || !1 && !1) : is_string(1) ? is_string(1) && 1 === 1 : is_undefined(1) ? is_undefined(1) : is_function(1) ? is_function(1) && 1 === 1 : fals) && equal(tail([1, null]), tail([1, null])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[afterMarker] is_number runs

(true ? is_number(1) && 1 === 1 : is_boolean(1) ? is_boolean(1) && (1 && 1 || !1 && !1) : is_string(1) ? is_string(1) && 1 === 1 : is_undefined(1) ? is_undefined(1) : is_function(1) ? is_function(1) && 1 === 1 : fals) && equal(tail([1, null]), tail([1, null])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_number(1) && 1 === 1 && equal(tail([1, null]), tail([1, null])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_number(1) && 1 === 1 && equal(tail([1, null]), tail([1, null])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[beforeMarker] is_number runs

true && 1 === 1 && equal(tail([1, null]), tail([1, null])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[afterMarker] is_number runs

true && 1 === 1 && equal(tail([1, null]), tail([1, null])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

1 === 1 && equal(tail([1, null]), tail([1, null])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

1 === 1 && equal(tail([1, null]), tail([1, null])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[beforeMarker] Binary expression 1 === 1 evaluated

true && equal(tail([1, null]), tail([1, null])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[afterMarker] Binary expression 1 === 1 evaluated

true && equal(tail([1, null]), tail([1, null])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(tail([1, null]), tail([1, null])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(tail([1, null]), tail([1, null])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[beforeMarker] tail runs

equal(null, tail([1, null])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[afterMarker] tail runs

equal(null, tail([1, null])) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[beforeMarker] tail runs

equal(null, null) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[afterMarker] tail runs

equal(null, null) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(null, null) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(null, null) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[beforeMarker] null, null substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair(null) ? is_pair(null) && equal(head(null), head(null)) && equal(tail(null), tail(null)) : is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[afterMarker] null, null substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair(null) ? is_pair(null) && equal(head(null), head(null)) && equal(tail(null), tail(null)) : is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[beforeMarker] is_pair runs

(false ? is_pair(null) && equal(head(null), head(null)) && equal(tail(null), tail(null)) : is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[afterMarker] is_pair runs

(false ? is_pair(null) && equal(head(null), head(null)) && equal(tail(null), tail(null)) : is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[beforeMarker] is_null runs

(true ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[afterMarker] is_null runs

(true ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_null(null) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_null(null) && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[beforeMarker] is_null runs

true && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[afterMarker] is_null runs

true && equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(tail([[1, null], [[1, [2, null]], null]]), tail([[1, null], [[1, [2, null]], null]]));
[beforeMarker] tail runs

equal([[1, [2, null]], null], tail([[1, null], [[1, [2, null]], null]]));
[afterMarker] tail runs

equal([[1, [2, null]], null], tail([[1, null], [[1, [2, null]], null]]));
[beforeMarker] tail runs

equal([[1, [2, null]], null], [[1, [2, null]], null]);
[afterMarker] tail runs

equal([[1, [2, null]], null], [[1, [2, null]], null]);
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)([[1, [2, null]], null], [[1, [2, null]], null]);
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)([[1, [2, null]], null], [[1, [2, null]], null]);
[beforeMarker] [[1, [2, null]], null], [[1, [2, null]], null] substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

is_pair([[1, [2, null]], null]) ? is_pair([[1, [2, null]], null]) && equal(head([[1, [2, null]], null]), head([[1, [2, null]], null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null])) : is_null([[1, [2, null]], null]) ? is_null([[1, [2, null]], null]) : is_number([[1, [2, null]], null]) ? is_number([[1, [2, null]], null]) && [[1, [2, null]], null] === [[1, [2, null]], null] : is_boolean([[1, [2, null]], null]) ? is_boolean([[1, [2, null]], null]) && ([[1, [2, null]], null] && [[1, [2, null]], null] || ![[1, [2, null]], null] && ![[1, [2, null]], null]) : is_string([[1, [2, null]], null]) ? is_string([[1, [2, null]], null]) && [[1, [2, null]], null] === [[1, [2, null]], null] : is_undefined([[1, [2, null]], null]) ? is_undefined([[1, [2, null]], null]) : is_function([[1, [2, null]], null]) ? is_function([[1, [2, null]], null]) && [[1, [2, null]], null] === [[1, [2, null]], null] : fals;
[afterMarker] [[1, [2, null]], null], [[1, [2, null]], null] substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

is_pair([[1, [2, null]], null]) ? is_pair([[1, [2, null]], null]) && equal(head([[1, [2, null]], null]), head([[1, [2, null]], null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null])) : is_null([[1, [2, null]], null]) ? is_null([[1, [2, null]], null]) : is_number([[1, [2, null]], null]) ? is_number([[1, [2, null]], null]) && [[1, [2, null]], null] === [[1, [2, null]], null] : is_boolean([[1, [2, null]], null]) ? is_boolean([[1, [2, null]], null]) && ([[1, [2, null]], null] && [[1, [2, null]], null] || ![[1, [2, null]], null] && ![[1, [2, null]], null]) : is_string([[1, [2, null]], null]) ? is_string([[1, [2, null]], null]) && [[1, [2, null]], null] === [[1, [2, null]], null] : is_undefined([[1, [2, null]], null]) ? is_undefined([[1, [2, null]], null]) : is_function([[1, [2, null]], null]) ? is_function([[1, [2, null]], null]) && [[1, [2, null]], null] === [[1, [2, null]], null] : fals;
[beforeMarker] is_pair runs

true ? is_pair([[1, [2, null]], null]) && equal(head([[1, [2, null]], null]), head([[1, [2, null]], null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null])) : is_null([[1, [2, null]], null]) ? is_null([[1, [2, null]], null]) : is_number([[1, [2, null]], null]) ? is_number([[1, [2, null]], null]) && [[1, [2, null]], null] === [[1, [2, null]], null] : is_boolean([[1, [2, null]], null]) ? is_boolean([[1, [2, null]], null]) && ([[1, [2, null]], null] && [[1, [2, null]], null] || ![[1, [2, null]], null] && ![[1, [2, null]], null]) : is_string([[1, [2, null]], null]) ? is_string([[1, [2, null]], null]) && [[1, [2, null]], null] === [[1, [2, null]], null] : is_undefined([[1, [2, null]], null]) ? is_undefined([[1, [2, null]], null]) : is_function([[1, [2, null]], null]) ? is_function([[1, [2, null]], null]) && [[1, [2, null]], null] === [[1, [2, null]], null] : fals;
[afterMarker] is_pair runs

true ? is_pair([[1, [2, null]], null]) && equal(head([[1, [2, null]], null]), head([[1, [2, null]], null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null])) : is_null([[1, [2, null]], null]) ? is_null([[1, [2, null]], null]) : is_number([[1, [2, null]], null]) ? is_number([[1, [2, null]], null]) && [[1, [2, null]], null] === [[1, [2, null]], null] : is_boolean([[1, [2, null]], null]) ? is_boolean([[1, [2, null]], null]) && ([[1, [2, null]], null] && [[1, [2, null]], null] || ![[1, [2, null]], null] && ![[1, [2, null]], null]) : is_string([[1, [2, null]], null]) ? is_string([[1, [2, null]], null]) && [[1, [2, null]], null] === [[1, [2, null]], null] : is_undefined([[1, [2, null]], null]) ? is_undefined([[1, [2, null]], null]) : is_function([[1, [2, null]], null]) ? is_function([[1, [2, null]], null]) && [[1, [2, null]], null] === [[1, [2, null]], null] : fals;
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_pair([[1, [2, null]], null]) && equal(head([[1, [2, null]], null]), head([[1, [2, null]], null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_pair([[1, [2, null]], null]) && equal(head([[1, [2, null]], null]), head([[1, [2, null]], null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] is_pair runs

true && equal(head([[1, [2, null]], null]), head([[1, [2, null]], null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] is_pair runs

true && equal(head([[1, [2, null]], null]), head([[1, [2, null]], null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(head([[1, [2, null]], null]), head([[1, [2, null]], null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(head([[1, [2, null]], null]), head([[1, [2, null]], null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] head runs

equal([1, [2, null]], head([[1, [2, null]], null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] head runs

equal([1, [2, null]], head([[1, [2, null]], null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] head runs

equal([1, [2, null]], [1, [2, null]]) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] head runs

equal([1, [2, null]], [1, [2, null]]) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)([1, [2, null]], [1, [2, null]]) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)([1, [2, null]], [1, [2, null]]) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] [1, [2, null]], [1, [2, null]] substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair([1, [2, null]]) ? is_pair([1, [2, null]]) && equal(head([1, [2, null]]), head([1, [2, null]])) && equal(tail([1, [2, null]]), tail([1, [2, null]])) : is_null([1, [2, null]]) ? is_null([1, [2, null]]) : is_number([1, [2, null]]) ? is_number([1, [2, null]]) && [1, [2, null]] === [1, [2, null]] : is_boolean([1, [2, null]]) ? is_boolean([1, [2, null]]) && ([1, [2, null]] && [1, [2, null]] || ![1, [2, null]] && ![1, [2, null]]) : is_string([1, [2, null]]) ? is_string([1, [2, null]]) && [1, [2, null]] === [1, [2, null]] : is_undefined([1, [2, null]]) ? is_undefined([1, [2, null]]) : is_function([1, [2, null]]) ? is_function([1, [2, null]]) && [1, [2, null]] === [1, [2, null]] : fals) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] [1, [2, null]], [1, [2, null]] substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair([1, [2, null]]) ? is_pair([1, [2, null]]) && equal(head([1, [2, null]]), head([1, [2, null]])) && equal(tail([1, [2, null]]), tail([1, [2, null]])) : is_null([1, [2, null]]) ? is_null([1, [2, null]]) : is_number([1, [2, null]]) ? is_number([1, [2, null]]) && [1, [2, null]] === [1, [2, null]] : is_boolean([1, [2, null]]) ? is_boolean([1, [2, null]]) && ([1, [2, null]] && [1, [2, null]] || ![1, [2, null]] && ![1, [2, null]]) : is_string([1, [2, null]]) ? is_string([1, [2, null]]) && [1, [2, null]] === [1, [2, null]] : is_undefined([1, [2, null]]) ? is_undefined([1, [2, null]]) : is_function([1, [2, null]]) ? is_function([1, [2, null]]) && [1, [2, null]] === [1, [2, null]] : fals) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] is_pair runs

(true ? is_pair([1, [2, null]]) && equal(head([1, [2, null]]), head([1, [2, null]])) && equal(tail([1, [2, null]]), tail([1, [2, null]])) : is_null([1, [2, null]]) ? is_null([1, [2, null]]) : is_number([1, [2, null]]) ? is_number([1, [2, null]]) && [1, [2, null]] === [1, [2, null]] : is_boolean([1, [2, null]]) ? is_boolean([1, [2, null]]) && ([1, [2, null]] && [1, [2, null]] || ![1, [2, null]] && ![1, [2, null]]) : is_string([1, [2, null]]) ? is_string([1, [2, null]]) && [1, [2, null]] === [1, [2, null]] : is_undefined([1, [2, null]]) ? is_undefined([1, [2, null]]) : is_function([1, [2, null]]) ? is_function([1, [2, null]]) && [1, [2, null]] === [1, [2, null]] : fals) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] is_pair runs

(true ? is_pair([1, [2, null]]) && equal(head([1, [2, null]]), head([1, [2, null]])) && equal(tail([1, [2, null]]), tail([1, [2, null]])) : is_null([1, [2, null]]) ? is_null([1, [2, null]]) : is_number([1, [2, null]]) ? is_number([1, [2, null]]) && [1, [2, null]] === [1, [2, null]] : is_boolean([1, [2, null]]) ? is_boolean([1, [2, null]]) && ([1, [2, null]] && [1, [2, null]] || ![1, [2, null]] && ![1, [2, null]]) : is_string([1, [2, null]]) ? is_string([1, [2, null]]) && [1, [2, null]] === [1, [2, null]] : is_undefined([1, [2, null]]) ? is_undefined([1, [2, null]]) : is_function([1, [2, null]]) ? is_function([1, [2, null]]) && [1, [2, null]] === [1, [2, null]] : fals) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_pair([1, [2, null]]) && equal(head([1, [2, null]]), head([1, [2, null]])) && equal(tail([1, [2, null]]), tail([1, [2, null]])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_pair([1, [2, null]]) && equal(head([1, [2, null]]), head([1, [2, null]])) && equal(tail([1, [2, null]]), tail([1, [2, null]])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] is_pair runs

true && equal(head([1, [2, null]]), head([1, [2, null]])) && equal(tail([1, [2, null]]), tail([1, [2, null]])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] is_pair runs

true && equal(head([1, [2, null]]), head([1, [2, null]])) && equal(tail([1, [2, null]]), tail([1, [2, null]])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(head([1, [2, null]]), head([1, [2, null]])) && equal(tail([1, [2, null]]), tail([1, [2, null]])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(head([1, [2, null]]), head([1, [2, null]])) && equal(tail([1, [2, null]]), tail([1, [2, null]])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] head runs

equal(1, head([1, [2, null]])) && equal(tail([1, [2, null]]), tail([1, [2, null]])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] head runs

equal(1, head([1, [2, null]])) && equal(tail([1, [2, null]]), tail([1, [2, null]])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] head runs

equal(1, 1) && equal(tail([1, [2, null]]), tail([1, [2, null]])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] head runs

equal(1, 1) && equal(tail([1, [2, null]]), tail([1, [2, null]])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(1, 1) && equal(tail([1, [2, null]]), tail([1, [2, null]])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(1, 1) && equal(tail([1, [2, null]]), tail([1, [2, null]])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] 1, 1 substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair(1) ? is_pair(1) && equal(head(1), head(1)) && equal(tail(1), tail(1)) : is_null(1) ? is_null(1) : is_number(1) ? is_number(1) && 1 === 1 : is_boolean(1) ? is_boolean(1) && (1 && 1 || !1 && !1) : is_string(1) ? is_string(1) && 1 === 1 : is_undefined(1) ? is_undefined(1) : is_function(1) ? is_function(1) && 1 === 1 : fals) && equal(tail([1, [2, null]]), tail([1, [2, null]])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] 1, 1 substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair(1) ? is_pair(1) && equal(head(1), head(1)) && equal(tail(1), tail(1)) : is_null(1) ? is_null(1) : is_number(1) ? is_number(1) && 1 === 1 : is_boolean(1) ? is_boolean(1) && (1 && 1 || !1 && !1) : is_string(1) ? is_string(1) && 1 === 1 : is_undefined(1) ? is_undefined(1) : is_function(1) ? is_function(1) && 1 === 1 : fals) && equal(tail([1, [2, null]]), tail([1, [2, null]])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] is_pair runs

(false ? is_pair(1) && equal(head(1), head(1)) && equal(tail(1), tail(1)) : is_null(1) ? is_null(1) : is_number(1) ? is_number(1) && 1 === 1 : is_boolean(1) ? is_boolean(1) && (1 && 1 || !1 && !1) : is_string(1) ? is_string(1) && 1 === 1 : is_undefined(1) ? is_undefined(1) : is_function(1) ? is_function(1) && 1 === 1 : fals) && equal(tail([1, [2, null]]), tail([1, [2, null]])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] is_pair runs

(false ? is_pair(1) && equal(head(1), head(1)) && equal(tail(1), tail(1)) : is_null(1) ? is_null(1) : is_number(1) ? is_number(1) && 1 === 1 : is_boolean(1) ? is_boolean(1) && (1 && 1 || !1 && !1) : is_string(1) ? is_string(1) && 1 === 1 : is_undefined(1) ? is_undefined(1) : is_function(1) ? is_function(1) && 1 === 1 : fals) && equal(tail([1, [2, null]]), tail([1, [2, null]])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_null(1) ? is_null(1) : is_number(1) ? is_number(1) && 1 === 1 : is_boolean(1) ? is_boolean(1) && (1 && 1 || !1 && !1) : is_string(1) ? is_string(1) && 1 === 1 : is_undefined(1) ? is_undefined(1) : is_function(1) ? is_function(1) && 1 === 1 : fals) && equal(tail([1, [2, null]]), tail([1, [2, null]])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_null(1) ? is_null(1) : is_number(1) ? is_number(1) && 1 === 1 : is_boolean(1) ? is_boolean(1) && (1 && 1 || !1 && !1) : is_string(1) ? is_string(1) && 1 === 1 : is_undefined(1) ? is_undefined(1) : is_function(1) ? is_function(1) && 1 === 1 : fals) && equal(tail([1, [2, null]]), tail([1, [2, null]])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] is_null runs

(false ? is_null(1) : is_number(1) ? is_number(1) && 1 === 1 : is_boolean(1) ? is_boolean(1) && (1 && 1 || !1 && !1) : is_string(1) ? is_string(1) && 1 === 1 : is_undefined(1) ? is_undefined(1) : is_function(1) ? is_function(1) && 1 === 1 : fals) && equal(tail([1, [2, null]]), tail([1, [2, null]])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] is_null runs

(false ? is_null(1) : is_number(1) ? is_number(1) && 1 === 1 : is_boolean(1) ? is_boolean(1) && (1 && 1 || !1 && !1) : is_string(1) ? is_string(1) && 1 === 1 : is_undefined(1) ? is_undefined(1) : is_function(1) ? is_function(1) && 1 === 1 : fals) && equal(tail([1, [2, null]]), tail([1, [2, null]])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_number(1) ? is_number(1) && 1 === 1 : is_boolean(1) ? is_boolean(1) && (1 && 1 || !1 && !1) : is_string(1) ? is_string(1) && 1 === 1 : is_undefined(1) ? is_undefined(1) : is_function(1) ? is_function(1) && 1 === 1 : fals) && equal(tail([1, [2, null]]), tail([1, [2, null]])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_number(1) ? is_number(1) && 1 === 1 : is_boolean(1) ? is_boolean(1) && (1 && 1 || !1 && !1) : is_string(1) ? is_string(1) && 1 === 1 : is_undefined(1) ? is_undefined(1) : is_function(1) ? is_function(1) && 1 === 1 : fals) && equal(tail([1, [2, null]]), tail([1, [2, null]])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] is_number runs

(true ? is_number(1) && 1 === 1 : is_boolean(1) ? is_boolean(1) && (1 && 1 || !1 && !1) : is_string(1) ? is_string(1) && 1 === 1 : is_undefined(1) ? is_undefined(1) : is_function(1) ? is_function(1) && 1 === 1 : fals) && equal(tail([1, [2, null]]), tail([1, [2, null]])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] is_number runs

(true ? is_number(1) && 1 === 1 : is_boolean(1) ? is_boolean(1) && (1 && 1 || !1 && !1) : is_string(1) ? is_string(1) && 1 === 1 : is_undefined(1) ? is_undefined(1) : is_function(1) ? is_function(1) && 1 === 1 : fals) && equal(tail([1, [2, null]]), tail([1, [2, null]])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_number(1) && 1 === 1 && equal(tail([1, [2, null]]), tail([1, [2, null]])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_number(1) && 1 === 1 && equal(tail([1, [2, null]]), tail([1, [2, null]])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] is_number runs

true && 1 === 1 && equal(tail([1, [2, null]]), tail([1, [2, null]])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] is_number runs

true && 1 === 1 && equal(tail([1, [2, null]]), tail([1, [2, null]])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

1 === 1 && equal(tail([1, [2, null]]), tail([1, [2, null]])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

1 === 1 && equal(tail([1, [2, null]]), tail([1, [2, null]])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] Binary expression 1 === 1 evaluated

true && equal(tail([1, [2, null]]), tail([1, [2, null]])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] Binary expression 1 === 1 evaluated

true && equal(tail([1, [2, null]]), tail([1, [2, null]])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(tail([1, [2, null]]), tail([1, [2, null]])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(tail([1, [2, null]]), tail([1, [2, null]])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] tail runs

equal([2, null], tail([1, [2, null]])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] tail runs

equal([2, null], tail([1, [2, null]])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] tail runs

equal([2, null], [2, null]) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] tail runs

equal([2, null], [2, null]) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)([2, null], [2, null]) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)([2, null], [2, null]) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] [2, null], [2, null] substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair([2, null]) ? is_pair([2, null]) && equal(head([2, null]), head([2, null])) && equal(tail([2, null]), tail([2, null])) : is_null([2, null]) ? is_null([2, null]) : is_number([2, null]) ? is_number([2, null]) && [2, null] === [2, null] : is_boolean([2, null]) ? is_boolean([2, null]) && ([2, null] && [2, null] || ![2, null] && ![2, null]) : is_string([2, null]) ? is_string([2, null]) && [2, null] === [2, null] : is_undefined([2, null]) ? is_undefined([2, null]) : is_function([2, null]) ? is_function([2, null]) && [2, null] === [2, null] : fals) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] [2, null], [2, null] substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair([2, null]) ? is_pair([2, null]) && equal(head([2, null]), head([2, null])) && equal(tail([2, null]), tail([2, null])) : is_null([2, null]) ? is_null([2, null]) : is_number([2, null]) ? is_number([2, null]) && [2, null] === [2, null] : is_boolean([2, null]) ? is_boolean([2, null]) && ([2, null] && [2, null] || ![2, null] && ![2, null]) : is_string([2, null]) ? is_string([2, null]) && [2, null] === [2, null] : is_undefined([2, null]) ? is_undefined([2, null]) : is_function([2, null]) ? is_function([2, null]) && [2, null] === [2, null] : fals) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] is_pair runs

(true ? is_pair([2, null]) && equal(head([2, null]), head([2, null])) && equal(tail([2, null]), tail([2, null])) : is_null([2, null]) ? is_null([2, null]) : is_number([2, null]) ? is_number([2, null]) && [2, null] === [2, null] : is_boolean([2, null]) ? is_boolean([2, null]) && ([2, null] && [2, null] || ![2, null] && ![2, null]) : is_string([2, null]) ? is_string([2, null]) && [2, null] === [2, null] : is_undefined([2, null]) ? is_undefined([2, null]) : is_function([2, null]) ? is_function([2, null]) && [2, null] === [2, null] : fals) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] is_pair runs

(true ? is_pair([2, null]) && equal(head([2, null]), head([2, null])) && equal(tail([2, null]), tail([2, null])) : is_null([2, null]) ? is_null([2, null]) : is_number([2, null]) ? is_number([2, null]) && [2, null] === [2, null] : is_boolean([2, null]) ? is_boolean([2, null]) && ([2, null] && [2, null] || ![2, null] && ![2, null]) : is_string([2, null]) ? is_string([2, null]) && [2, null] === [2, null] : is_undefined([2, null]) ? is_undefined([2, null]) : is_function([2, null]) ? is_function([2, null]) && [2, null] === [2, null] : fals) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_pair([2, null]) && equal(head([2, null]), head([2, null])) && equal(tail([2, null]), tail([2, null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_pair([2, null]) && equal(head([2, null]), head([2, null])) && equal(tail([2, null]), tail([2, null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] is_pair runs

true && equal(head([2, null]), head([2, null])) && equal(tail([2, null]), tail([2, null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] is_pair runs

true && equal(head([2, null]), head([2, null])) && equal(tail([2, null]), tail([2, null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(head([2, null]), head([2, null])) && equal(tail([2, null]), tail([2, null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(head([2, null]), head([2, null])) && equal(tail([2, null]), tail([2, null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] head runs

equal(2, head([2, null])) && equal(tail([2, null]), tail([2, null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] head runs

equal(2, head([2, null])) && equal(tail([2, null]), tail([2, null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] head runs

equal(2, 2) && equal(tail([2, null]), tail([2, null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] head runs

equal(2, 2) && equal(tail([2, null]), tail([2, null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(2, 2) && equal(tail([2, null]), tail([2, null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(2, 2) && equal(tail([2, null]), tail([2, null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] 2, 2 substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair(2) ? is_pair(2) && equal(head(2), head(2)) && equal(tail(2), tail(2)) : is_null(2) ? is_null(2) : is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, null]), tail([2, null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] 2, 2 substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair(2) ? is_pair(2) && equal(head(2), head(2)) && equal(tail(2), tail(2)) : is_null(2) ? is_null(2) : is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, null]), tail([2, null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] is_pair runs

(false ? is_pair(2) && equal(head(2), head(2)) && equal(tail(2), tail(2)) : is_null(2) ? is_null(2) : is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, null]), tail([2, null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] is_pair runs

(false ? is_pair(2) && equal(head(2), head(2)) && equal(tail(2), tail(2)) : is_null(2) ? is_null(2) : is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, null]), tail([2, null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_null(2) ? is_null(2) : is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, null]), tail([2, null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_null(2) ? is_null(2) : is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, null]), tail([2, null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] is_null runs

(false ? is_null(2) : is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, null]), tail([2, null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] is_null runs

(false ? is_null(2) : is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, null]), tail([2, null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, null]), tail([2, null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_number(2) ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, null]), tail([2, null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] is_number runs

(true ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, null]), tail([2, null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] is_number runs

(true ? is_number(2) && 2 === 2 : is_boolean(2) ? is_boolean(2) && (2 && 2 || !2 && !2) : is_string(2) ? is_string(2) && 2 === 2 : is_undefined(2) ? is_undefined(2) : is_function(2) ? is_function(2) && 2 === 2 : fals) && equal(tail([2, null]), tail([2, null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_number(2) && 2 === 2 && equal(tail([2, null]), tail([2, null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_number(2) && 2 === 2 && equal(tail([2, null]), tail([2, null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] is_number runs

true && 2 === 2 && equal(tail([2, null]), tail([2, null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] is_number runs

true && 2 === 2 && equal(tail([2, null]), tail([2, null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

2 === 2 && equal(tail([2, null]), tail([2, null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

2 === 2 && equal(tail([2, null]), tail([2, null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] Binary expression 2 === 2 evaluated

true && equal(tail([2, null]), tail([2, null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] Binary expression 2 === 2 evaluated

true && equal(tail([2, null]), tail([2, null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(tail([2, null]), tail([2, null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(tail([2, null]), tail([2, null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] tail runs

equal(null, tail([2, null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] tail runs

equal(null, tail([2, null])) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] tail runs

equal(null, null) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] tail runs

equal(null, null) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(null, null) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(null, null) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] null, null substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair(null) ? is_pair(null) && equal(head(null), head(null)) && equal(tail(null), tail(null)) : is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] null, null substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

(is_pair(null) ? is_pair(null) && equal(head(null), head(null)) && equal(tail(null), tail(null)) : is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] is_pair runs

(false ? is_pair(null) && equal(head(null), head(null)) && equal(tail(null), tail(null)) : is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] is_pair runs

(false ? is_pair(null) && equal(head(null), head(null)) && equal(tail(null), tail(null)) : is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

(is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] is_null runs

(true ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] is_null runs

(true ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_null(null) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_null(null) && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] is_null runs

true && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] is_null runs

true && equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[afterMarker] AND operation evaluated, left of operator is true, continue evaluating right of operator

equal(tail([[1, [2, null]], null]), tail([[1, [2, null]], null]));
[beforeMarker] tail runs

equal(null, tail([[1, [2, null]], null]));
[afterMarker] tail runs

equal(null, tail([[1, [2, null]], null]));
[beforeMarker] tail runs

equal(null, null);
[afterMarker] tail runs

equal(null, null);
[beforeMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(null, null);
[afterMarker] equal runs

((xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals)(null, null);
[beforeMarker] null, null substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

is_pair(null) ? is_pair(null) && equal(head(null), head(null)) && equal(tail(null), tail(null)) : is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals;
[afterMarker] null, null substituted into xs, ys of (xs, ys) => is_pair(xs) ? is_pair(ys) && equal(head(xs), head(ys)) && equal(tail(xs), tail(ys)) : is_null(xs) ? is_null(ys) : is_number(xs) ? is_number(ys) && xs === ys : is_boolean(xs) ? is_boolean(ys) && (xs && ys || !xs && !ys) : is_string(xs) ? is_string(ys) && xs === ys : is_undefined(xs) ? is_undefined(ys) : is_function(xs) ? is_function(ys) && xs === ys : fals

is_pair(null) ? is_pair(null) && equal(head(null), head(null)) && equal(tail(null), tail(null)) : is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals;
[beforeMarker] is_pair runs

false ? is_pair(null) && equal(head(null), head(null)) && equal(tail(null), tail(null)) : is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals;
[afterMarker] is_pair runs

false ? is_pair(null) && equal(head(null), head(null)) && equal(tail(null), tail(null)) : is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals;
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals;
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

is_null(null) ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals;
[beforeMarker] is_null runs

true ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals;
[afterMarker] is_null runs

true ? is_null(null) : is_number(null) ? is_number(null) && null === null : is_boolean(null) ? is_boolean(null) && (null && null || !null && !null) : is_string(null) ? is_string(null) && null === null : is_undefined(null) ? is_undefined(null) : is_function(null) ? is_function(null) && null === null : fals;
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_null(null);
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

is_null(null);
[beforeMarker] is_null runs

true;
[afterMarker] is_null runs

true;
[noMarker] Evaluation complete
"
`;

exports[`Programs Eliminate-constant-declaration test case 1 1`] = `
"const x = 0;
[noMarker] Start of evaluation

const x = 0;
[beforeMarker] Constant x declared and substituted into the rest of block


[afterMarker] Constant x declared and substituted into the rest of block

undefined;
[noMarker] Evaluation complete
"
`;

exports[`Programs Eliminate-constant-declaration test case 2 1`] = `
"1;const x = 0;
[noMarker] Start of evaluation

1;const x = 0;
[beforeMarker] Constant x declared and substituted into the rest of block

1;
[afterMarker] Constant x declared and substituted into the rest of block

1;
[noMarker] Evaluation complete
"
`;

exports[`Programs Eliminate-function-declaration test case 1 1`] = `
"function foo(x) { return 0;}
[noMarker] Start of evaluation

function foo(x) { return 0;}
[beforeMarker] Function foo declared, parameter(s) x required


[afterMarker] Function foo declared, parameter(s) x required

undefined;
[noMarker] Evaluation complete
"
`;

exports[`Programs Eliminate-function-declaration test case 2 1`] = `
"1;function foo(x) { return 0;}
[noMarker] Start of evaluation

1;function foo(x) { return 0;}
[beforeMarker] Function foo declared, parameter(s) x required

1;
[afterMarker] Function foo declared, parameter(s) x required

1;
[noMarker] Evaluation complete
"
`;

exports[`Programs Program-intro test case 1 1`] = `
"1 + 1;
[noMarker] Start of evaluation

1 + 1;
[beforeMarker] Binary expression 1 + 1 evaluated

2;
[afterMarker] Binary expression 1 + 1 evaluated

2;
[noMarker] Evaluation complete
"
`;

exports[`Programs Program-intro test case 2 1`] = `
"1;1 + 1;
[noMarker] Start of evaluation

1;1 + 1;
[beforeMarker] Binary expression 1 + 1 evaluated

1;2;
[afterMarker] Binary expression 1 + 1 evaluated

1;2;
[beforeMarker] 1 finished evaluating

2;
[afterMarker] 1 finished evaluating

2;
[noMarker] Evaluation complete
"
`;

exports[`Programs Program-reduce test case 1`] = `
"1;2;
[noMarker] Start of evaluation

1;2;
[beforeMarker] 1 finished evaluating

2;
[afterMarker] 1 finished evaluating

2;
[noMarker] Evaluation complete
"
`;

exports[`SOURCE 0 (Tests from previous stepper) 1 + math_sin 1`] = `
"1 + math_sin;
[noMarker] Start of evaluation

1 + math_sin;
[noMarker] Evaluation complete
"
`;

exports[`SOURCE 0 (Tests from previous stepper) Even odd mutual 1`] = `
"const odd = n => n === 0 ? false : even(n - 1);const even = n => n === 0 || odd(n - 1);even(1);
[noMarker] Start of evaluation

const odd = n => n === 0 ? false : even(n - 1);const even = n => n === 0 || odd(n - 1);even(1);
[beforeMarker] Constant odd declared and substituted into the rest of block

const even = n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1);even(1);
[afterMarker] Constant odd declared and substituted into the rest of block

const even = n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1);even(1);
[beforeMarker] Constant even declared and substituted into the rest of block

(n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1))(1);
[afterMarker] Constant even declared and substituted into the rest of block

(n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1))(1);
[beforeMarker] 1 substituted into n of n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1)

1 === 0 || (n => n === 0 ? false : (n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1))(n - 1))(1 - 1);
[afterMarker] 1 substituted into n of n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1)

1 === 0 || (n => n === 0 ? false : (n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1))(n - 1))(1 - 1);
[beforeMarker] Binary expression 1 === 0 evaluated

false || (n => n === 0 ? false : (n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1))(n - 1))(1 - 1);
[afterMarker] Binary expression 1 === 0 evaluated

false || (n => n === 0 ? false : (n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1))(n - 1))(1 - 1);
[beforeMarker] OR operation evaluated, left of operator is false, continue evaluating right of operator

(n => n === 0 ? false : (n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1))(n - 1))(1 - 1);
[afterMarker] OR operation evaluated, left of operator is false, continue evaluating right of operator

(n => n === 0 ? false : (n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1))(n - 1))(1 - 1);
[beforeMarker] Binary expression 1 - 1 evaluated

(n => n === 0 ? false : (n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1))(n - 1))(0);
[afterMarker] Binary expression 1 - 1 evaluated

(n => n === 0 ? false : (n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1))(n - 1))(0);
[beforeMarker] 0 substituted into n of n => n === 0 ? false : (n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1))(n - 1)

0 === 0 ? false : (n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1))(0 - 1);
[afterMarker] 0 substituted into n of n => n === 0 ? false : (n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1))(n - 1)

0 === 0 ? false : (n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1))(0 - 1);
[beforeMarker] Binary expression 0 === 0 evaluated

true ? false : (n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1))(0 - 1);
[afterMarker] Binary expression 0 === 0 evaluated

true ? false : (n => n === 0 || (n => n === 0 ? false : even(n - 1))(n - 1))(0 - 1);
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

false;
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

false;
[noMarker] Evaluation complete
"
`;

exports[`SOURCE 0 (Tests from previous stepper) Infinite recursion 1`] = `
"function f() { return f();}f();
[noMarker] Start of evaluation

function f() { return f();}f();
[beforeMarker] Function f declared, parameter(s)  required

(() => { return f();})();
[afterMarker] Function f declared, parameter(s)  required

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[beforeMarker] () => {...} runs

(() => { return f();})();
[afterMarker] () => {...} runs

(() => { return f();})();
[noMarker] Maximum number of steps exceeded

(() => { return f();})();
[noMarker] Evaluation complete
"
`;

exports[`SOURCE 0 (Tests from previous stepper) expmod 1`] = `
"function is_even(n) { return n % 2 === 0;}function expmod(base, exp, m) { if (exp === 0) { return 1; } else { if (is_even(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } }}expmod(4, 3, 5);
[noMarker] Start of evaluation

function is_even(n) { return n % 2 === 0;}function expmod(base, exp, m) { if (exp === 0) { return 1; } else { if (is_even(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } }}expmod(4, 3, 5);
[beforeMarker] Function is_even declared, parameter(s) n required

function expmod(base, exp, m) { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } }}expmod(4, 3, 5);
[afterMarker] Function is_even declared, parameter(s) n required

function expmod(base, exp, m) { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } }}expmod(4, 3, 5);
[beforeMarker] Function expmod declared, parameter(s) base,exp,m required

((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } }})(4, 3, 5);
[afterMarker] Function expmod declared, parameter(s) base,exp,m required

((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } }})(4, 3, 5);
[beforeMarker] Function expmod takes in 4, 3, 5 as input base, exp, m

{ if (3 === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(3)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; } }};
[afterMarker] Function expmod takes in 4, 3, 5 as input base, exp, m

{ if (3 === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(3)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; } }};
[beforeMarker] Binary expression 3 === 0 evaluated

{ if (false) { return 1; } else { if ((n => { return n % 2 === 0; })(3)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; } }};
[afterMarker] Binary expression 3 === 0 evaluated

{ if (false) { return 1; } else { if ((n => { return n % 2 === 0; })(3)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; } }};
[beforeMarker] If statement evaluated, condition false, proceed to else block

{ { undefined; if ((n => { return n % 2 === 0; })(3)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; } }};
[afterMarker] If statement evaluated, condition false, proceed to else block

{ { undefined; if ((n => { return n % 2 === 0; })(3)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; } }};
[beforeMarker] Function is_even takes in 3 as input n

{ { undefined; if (3 % 2 === 0) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; } }};
[afterMarker] Function is_even takes in 3 as input n

{ { undefined; if (3 % 2 === 0) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; } }};
[beforeMarker] Binary expression 3 % 2 evaluated

{ { undefined; if (1 === 0) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; } }};
[afterMarker] Binary expression 3 % 2 evaluated

{ { undefined; if (1 === 0) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; } }};
[beforeMarker] Binary expression 1 === 0 evaluated

{ { undefined; if (false) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; } }};
[afterMarker] Binary expression 1 === 0 evaluated

{ { undefined; if (false) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; } }};
[beforeMarker] If statement evaluated, condition false, proceed to else block

{ { undefined; { undefined; return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; } }};
[afterMarker] If statement evaluated, condition false, proceed to else block

{ { undefined; { undefined; return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; } }};
[beforeMarker] undefined finished evaluating

{ { undefined; { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; } }};
[afterMarker] undefined finished evaluating

{ { undefined; { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; } }};
[beforeMarker] return 4 * ((base, exp, m) => {
  if (exp === 0) {
    return 1;
  } else {
    if ((n => {
      return n % 2 === 0;
    })(exp)) {
      const to_half = expmod(base, exp / 2, m);
      return to_half * to_half % m;
    } else {
      return base * expmod(base, exp - 1, m) % m;
    }
  }
})(4, 3 - 1, 5) % 5; finished evaluating

{ { undefined; return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; }};
[afterMarker] return 4 * ((base, exp, m) => {
  if (exp === 0) {
    return 1;
  } else {
    if ((n => {
      return n % 2 === 0;
    })(exp)) {
      const to_half = expmod(base, exp / 2, m);
      return to_half * to_half % m;
    } else {
      return base * expmod(base, exp - 1, m) % m;
    }
  }
})(4, 3 - 1, 5) % 5; finished evaluating

{ { undefined; return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; }};
[beforeMarker] undefined finished evaluating

{ { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; }};
[afterMarker] undefined finished evaluating

{ { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5; }};
[beforeMarker] return 4 * ((base, exp, m) => {
  if (exp === 0) {
    return 1;
  } else {
    if ((n => {
      return n % 2 === 0;
    })(exp)) {
      const to_half = expmod(base, exp / 2, m);
      return to_half * to_half % m;
    } else {
      return base * expmod(base, exp - 1, m) % m;
    }
  }
})(4, 3 - 1, 5) % 5; finished evaluating

{ return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5;};
[afterMarker] return 4 * ((base, exp, m) => {
  if (exp === 0) {
    return 1;
  } else {
    if ((n => {
      return n % 2 === 0;
    })(exp)) {
      const to_half = expmod(base, exp / 2, m);
      return to_half * to_half % m;
    } else {
      return base * expmod(base, exp - 1, m) % m;
    }
  }
})(4, 3 - 1, 5) % 5; finished evaluating

{ return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 3 - 1, 5) % 5;};
[beforeMarker] 4 * ((base, exp, m) => {
  if (exp === 0) {
    return 1;
  } else {
    if ((n => {
      return n % 2 === 0;
    })(exp)) {
      const to_half = expmod(base, exp / 2, m);
      return to_half * to_half % m;
    } else {
      return base * expmod(base, exp - 1, m) % m;
    }
  }
})(4, 3 - 1, 5) % 5 returned

4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } }})(4, 3 - 1, 5) % 5;
[afterMarker] 4 * ((base, exp, m) => {
  if (exp === 0) {
    return 1;
  } else {
    if ((n => {
      return n % 2 === 0;
    })(exp)) {
      const to_half = expmod(base, exp / 2, m);
      return to_half * to_half % m;
    } else {
      return base * expmod(base, exp - 1, m) % m;
    }
  }
})(4, 3 - 1, 5) % 5 returned

4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } }})(4, 3 - 1, 5) % 5;
[beforeMarker] Binary expression 3 - 1 evaluated

4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } }})(4, 2, 5) % 5;
[afterMarker] Binary expression 3 - 1 evaluated

4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } }})(4, 2, 5) % 5;
[beforeMarker] Function expmod takes in 4, 2, 5 as input base, exp, m

4 * { if (2 === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(2)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 - 1, 5) % 5; } }} % 5;
[afterMarker] Function expmod takes in 4, 2, 5 as input base, exp, m

4 * { if (2 === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(2)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 - 1, 5) % 5; } }} % 5;
[beforeMarker] Binary expression 2 === 0 evaluated

4 * { if (false) { return 1; } else { if ((n => { return n % 2 === 0; })(2)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 - 1, 5) % 5; } }} % 5;
[afterMarker] Binary expression 2 === 0 evaluated

4 * { if (false) { return 1; } else { if ((n => { return n % 2 === 0; })(2)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 - 1, 5) % 5; } }} % 5;
[beforeMarker] If statement evaluated, condition false, proceed to else block

4 * { { undefined; if ((n => { return n % 2 === 0; })(2)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 - 1, 5) % 5; } }} % 5;
[afterMarker] If statement evaluated, condition false, proceed to else block

4 * { { undefined; if ((n => { return n % 2 === 0; })(2)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 - 1, 5) % 5; } }} % 5;
[beforeMarker] Function is_even takes in 2 as input n

4 * { { undefined; if (2 % 2 === 0) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 - 1, 5) % 5; } }} % 5;
[afterMarker] Function is_even takes in 2 as input n

4 * { { undefined; if (2 % 2 === 0) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 - 1, 5) % 5; } }} % 5;
[beforeMarker] Binary expression 2 % 2 evaluated

4 * { { undefined; if (0 === 0) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 - 1, 5) % 5; } }} % 5;
[afterMarker] Binary expression 2 % 2 evaluated

4 * { { undefined; if (0 === 0) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 - 1, 5) % 5; } }} % 5;
[beforeMarker] Binary expression 0 === 0 evaluated

4 * { { undefined; if (true) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 - 1, 5) % 5; } }} % 5;
[afterMarker] Binary expression 0 === 0 evaluated

4 * { { undefined; if (true) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 - 1, 5) % 5; } }} % 5;
[beforeMarker] If statement evaluated, condition true, proceed to if block

4 * { { undefined; { undefined; const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 / 2, 5); return to_half * to_half % 5; } }} % 5;
[afterMarker] If statement evaluated, condition true, proceed to if block

4 * { { undefined; { undefined; const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 2 / 2, 5); return to_half * to_half % 5; } }} % 5;
[beforeMarker] Binary expression 2 / 2 evaluated

4 * { { undefined; { undefined; const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1, 5); return to_half * to_half % 5; } }} % 5;
[afterMarker] Binary expression 2 / 2 evaluated

4 * { { undefined; { undefined; const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1, 5); return to_half * to_half % 5; } }} % 5;
[beforeMarker] Function expmod takes in 4, 1, 5 as input base, exp, m

4 * { { undefined; { undefined; const to_half = { if (1 === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(1)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } } }; return to_half * to_half % 5; } }} % 5;
[afterMarker] Function expmod takes in 4, 1, 5 as input base, exp, m

4 * { { undefined; { undefined; const to_half = { if (1 === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(1)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } } }; return to_half * to_half % 5; } }} % 5;
[beforeMarker] Binary expression 1 === 0 evaluated

4 * { { undefined; { undefined; const to_half = { if (false) { return 1; } else { if ((n => { return n % 2 === 0; })(1)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } } }; return to_half * to_half % 5; } }} % 5;
[afterMarker] Binary expression 1 === 0 evaluated

4 * { { undefined; { undefined; const to_half = { if (false) { return 1; } else { if ((n => { return n % 2 === 0; })(1)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } } }; return to_half * to_half % 5; } }} % 5;
[beforeMarker] If statement evaluated, condition false, proceed to else block

4 * { { undefined; { undefined; const to_half = { { undefined; if ((n => { return n % 2 === 0; })(1)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } } }; return to_half * to_half % 5; } }} % 5;
[afterMarker] If statement evaluated, condition false, proceed to else block

4 * { { undefined; { undefined; const to_half = { { undefined; if ((n => { return n % 2 === 0; })(1)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } } }; return to_half * to_half % 5; } }} % 5;
[beforeMarker] Function is_even takes in 1 as input n

4 * { { undefined; { undefined; const to_half = { { undefined; if (1 % 2 === 0) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } } }; return to_half * to_half % 5; } }} % 5;
[afterMarker] Function is_even takes in 1 as input n

4 * { { undefined; { undefined; const to_half = { { undefined; if (1 % 2 === 0) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } } }; return to_half * to_half % 5; } }} % 5;
[beforeMarker] Binary expression 1 % 2 evaluated

4 * { { undefined; { undefined; const to_half = { { undefined; if (1 === 0) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } } }; return to_half * to_half % 5; } }} % 5;
[afterMarker] Binary expression 1 % 2 evaluated

4 * { { undefined; { undefined; const to_half = { { undefined; if (1 === 0) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } } }; return to_half * to_half % 5; } }} % 5;
[beforeMarker] Binary expression 1 === 0 evaluated

4 * { { undefined; { undefined; const to_half = { { undefined; if (false) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } } }; return to_half * to_half % 5; } }} % 5;
[afterMarker] Binary expression 1 === 0 evaluated

4 * { { undefined; { undefined; const to_half = { { undefined; if (false) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } } }; return to_half * to_half % 5; } }} % 5;
[beforeMarker] If statement evaluated, condition false, proceed to else block

4 * { { undefined; { undefined; const to_half = { { undefined; { undefined; return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } } }; return to_half * to_half % 5; } }} % 5;
[afterMarker] If statement evaluated, condition false, proceed to else block

4 * { { undefined; { undefined; const to_half = { { undefined; { undefined; return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } } }; return to_half * to_half % 5; } }} % 5;
[beforeMarker] undefined finished evaluating

4 * { { undefined; { undefined; const to_half = { { undefined; { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } } }; return to_half * to_half % 5; } }} % 5;
[afterMarker] undefined finished evaluating

4 * { { undefined; { undefined; const to_half = { { undefined; { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } } }; return to_half * to_half % 5; } }} % 5;
[beforeMarker] return 4 * ((base, exp, m) => {
  if (exp === 0) {
    return 1;
  } else {
    if ((n => {
      return n % 2 === 0;
    })(exp)) {
      const to_half = expmod(base, exp / 2, m);
      return to_half * to_half % m;
    } else {
      return base * expmod(base, exp - 1, m) % m;
    }
  }
})(4, 1 - 1, 5) % 5; finished evaluating

4 * { { undefined; { undefined; const to_half = { { undefined; return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } }; return to_half * to_half % 5; } }} % 5;
[afterMarker] return 4 * ((base, exp, m) => {
  if (exp === 0) {
    return 1;
  } else {
    if ((n => {
      return n % 2 === 0;
    })(exp)) {
      const to_half = expmod(base, exp / 2, m);
      return to_half * to_half % m;
    } else {
      return base * expmod(base, exp - 1, m) % m;
    }
  }
})(4, 1 - 1, 5) % 5; finished evaluating

4 * { { undefined; { undefined; const to_half = { { undefined; return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } }; return to_half * to_half % 5; } }} % 5;
[beforeMarker] undefined finished evaluating

4 * { { undefined; { undefined; const to_half = { { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } }; return to_half * to_half % 5; } }} % 5;
[afterMarker] undefined finished evaluating

4 * { { undefined; { undefined; const to_half = { { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; } }; return to_half * to_half % 5; } }} % 5;
[beforeMarker] return 4 * ((base, exp, m) => {
  if (exp === 0) {
    return 1;
  } else {
    if ((n => {
      return n % 2 === 0;
    })(exp)) {
      const to_half = expmod(base, exp / 2, m);
      return to_half * to_half % m;
    } else {
      return base * expmod(base, exp - 1, m) % m;
    }
  }
})(4, 1 - 1, 5) % 5; finished evaluating

4 * { { undefined; { undefined; const to_half = { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; }; return to_half * to_half % 5; } }} % 5;
[afterMarker] return 4 * ((base, exp, m) => {
  if (exp === 0) {
    return 1;
  } else {
    if ((n => {
      return n % 2 === 0;
    })(exp)) {
      const to_half = expmod(base, exp / 2, m);
      return to_half * to_half % m;
    } else {
      return base * expmod(base, exp - 1, m) % m;
    }
  }
})(4, 1 - 1, 5) % 5; finished evaluating

4 * { { undefined; { undefined; const to_half = { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; }; return to_half * to_half % 5; } }} % 5;
[beforeMarker] 4 * ((base, exp, m) => {
  if (exp === 0) {
    return 1;
  } else {
    if ((n => {
      return n % 2 === 0;
    })(exp)) {
      const to_half = expmod(base, exp / 2, m);
      return to_half * to_half % m;
    } else {
      return base * expmod(base, exp - 1, m) % m;
    }
  }
})(4, 1 - 1, 5) % 5 returned

4 * { { undefined; { undefined; const to_half = 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; return to_half * to_half % 5; } }} % 5;
[afterMarker] 4 * ((base, exp, m) => {
  if (exp === 0) {
    return 1;
  } else {
    if ((n => {
      return n % 2 === 0;
    })(exp)) {
      const to_half = expmod(base, exp / 2, m);
      return to_half * to_half % m;
    } else {
      return base * expmod(base, exp - 1, m) % m;
    }
  }
})(4, 1 - 1, 5) % 5 returned

4 * { { undefined; { undefined; const to_half = 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 1 - 1, 5) % 5; return to_half * to_half % 5; } }} % 5;
[beforeMarker] Binary expression 1 - 1 evaluated

4 * { { undefined; { undefined; const to_half = 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 0, 5) % 5; return to_half * to_half % 5; } }} % 5;
[afterMarker] Binary expression 1 - 1 evaluated

4 * { { undefined; { undefined; const to_half = 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 0, 5) % 5; return to_half * to_half % 5; } }} % 5;
[beforeMarker] Function expmod takes in 4, 0, 5 as input base, exp, m

4 * { { undefined; { undefined; const to_half = 4 * { if (0 === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(0)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 0 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 0 - 1, 5) % 5; } } } % 5; return to_half * to_half % 5; } }} % 5;
[afterMarker] Function expmod takes in 4, 0, 5 as input base, exp, m

4 * { { undefined; { undefined; const to_half = 4 * { if (0 === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(0)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 0 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 0 - 1, 5) % 5; } } } % 5; return to_half * to_half % 5; } }} % 5;
[beforeMarker] Binary expression 0 === 0 evaluated

4 * { { undefined; { undefined; const to_half = 4 * { if (true) { return 1; } else { if ((n => { return n % 2 === 0; })(0)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 0 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 0 - 1, 5) % 5; } } } % 5; return to_half * to_half % 5; } }} % 5;
[afterMarker] Binary expression 0 === 0 evaluated

4 * { { undefined; { undefined; const to_half = 4 * { if (true) { return 1; } else { if ((n => { return n % 2 === 0; })(0)) { const to_half = ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 0 / 2, 5); return to_half * to_half % 5; } else { return 4 * ((base, exp, m) => { if (exp === 0) { return 1; } else { if ((n => { return n % 2 === 0; })(exp)) { const to_half = expmod(base, exp / 2, m); return to_half * to_half % m; } else { return base * expmod(base, exp - 1, m) % m; } } })(4, 0 - 1, 5) % 5; } } } % 5; return to_half * to_half % 5; } }} % 5;
[beforeMarker] If statement evaluated, condition true, proceed to if block

4 * { { undefined; { undefined; const to_half = 4 * { { undefined; return 1; } } % 5; return to_half * to_half % 5; } }} % 5;
[afterMarker] If statement evaluated, condition true, proceed to if block

4 * { { undefined; { undefined; const to_half = 4 * { { undefined; return 1; } } % 5; return to_half * to_half % 5; } }} % 5;
[beforeMarker] undefined finished evaluating

4 * { { undefined; { undefined; const to_half = 4 * { { return 1; } } % 5; return to_half * to_half % 5; } }} % 5;
[afterMarker] undefined finished evaluating

4 * { { undefined; { undefined; const to_half = 4 * { { return 1; } } % 5; return to_half * to_half % 5; } }} % 5;
[beforeMarker] return 1; finished evaluating

4 * { { undefined; { undefined; const to_half = 4 * { return 1; } % 5; return to_half * to_half % 5; } }} % 5;
[afterMarker] return 1; finished evaluating

4 * { { undefined; { undefined; const to_half = 4 * { return 1; } % 5; return to_half * to_half % 5; } }} % 5;
[beforeMarker] 1 returned

4 * { { undefined; { undefined; const to_half = 4 * 1 % 5; return to_half * to_half % 5; } }} % 5;
[afterMarker] 1 returned

4 * { { undefined; { undefined; const to_half = 4 * 1 % 5; return to_half * to_half % 5; } }} % 5;
[beforeMarker] Binary expression 4 * 1 evaluated

4 * { { undefined; { undefined; const to_half = 4 % 5; return to_half * to_half % 5; } }} % 5;
[afterMarker] Binary expression 4 * 1 evaluated

4 * { { undefined; { undefined; const to_half = 4 % 5; return to_half * to_half % 5; } }} % 5;
[beforeMarker] Binary expression 4 % 5 evaluated

4 * { { undefined; { undefined; const to_half = 4; return to_half * to_half % 5; } }} % 5;
[afterMarker] Binary expression 4 % 5 evaluated

4 * { { undefined; { undefined; const to_half = 4; return to_half * to_half % 5; } }} % 5;
[beforeMarker] Constant to_half declared and substituted into the rest of block

4 * { { undefined; { undefined; return 4 * 4 % 5; } }} % 5;
[afterMarker] Constant to_half declared and substituted into the rest of block

4 * { { undefined; { undefined; return 4 * 4 % 5; } }} % 5;
[beforeMarker] undefined finished evaluating

4 * { { undefined; { return 4 * 4 % 5; } }} % 5;
[afterMarker] undefined finished evaluating

4 * { { undefined; { return 4 * 4 % 5; } }} % 5;
[beforeMarker] return 4 * 4 % 5; finished evaluating

4 * { { undefined; return 4 * 4 % 5; }} % 5;
[afterMarker] return 4 * 4 % 5; finished evaluating

4 * { { undefined; return 4 * 4 % 5; }} % 5;
[beforeMarker] undefined finished evaluating

4 * { { return 4 * 4 % 5; }} % 5;
[afterMarker] undefined finished evaluating

4 * { { return 4 * 4 % 5; }} % 5;
[beforeMarker] return 4 * 4 % 5; finished evaluating

4 * { return 4 * 4 % 5;} % 5;
[afterMarker] return 4 * 4 % 5; finished evaluating

4 * { return 4 * 4 % 5;} % 5;
[beforeMarker] 4 * 4 % 5 returned

4 * (4 * 4 % 5) % 5;
[afterMarker] 4 * 4 % 5 returned

4 * (4 * 4 % 5) % 5;
[beforeMarker] Binary expression 4 * 4 evaluated

4 * (16 % 5) % 5;
[afterMarker] Binary expression 4 * 4 evaluated

4 * (16 % 5) % 5;
[beforeMarker] Binary expression 16 % 5 evaluated

4 * 1 % 5;
[afterMarker] Binary expression 16 % 5 evaluated

4 * 1 % 5;
[beforeMarker] Binary expression 4 * 1 evaluated

4 % 5;
[afterMarker] Binary expression 4 * 1 evaluated

4 % 5;
[beforeMarker] Binary expression 4 % 5 evaluated

4;
[afterMarker] Binary expression 4 % 5 evaluated

4;
[noMarker] Evaluation complete
"
`;

exports[`SOURCE 0 (Tests from previous stepper) math_pow 1`] = `
"math_pow(2, 20) || NaN;
[noMarker] Start of evaluation

math_pow(2, 20) || NaN;
[beforeMarker] math_pow runs

1048576 || NaN;
[afterMarker] math_pow runs

1048576 || NaN;
[beforeMarker] Line 2: Expected boolean on left hand side of operation, got number.

1048576 || NaN;
[noMarker] Evaluation stuck
"
`;

exports[`SOURCE 0 (Tests from previous stepper) plus undefined 1`] = `
"math_sin(1) + undefined;
[noMarker] Start of evaluation

math_sin(1) + undefined;
[beforeMarker] math_sin runs

0.8414709848078965 + undefined;
[afterMarker] math_sin runs

0.8414709848078965 + undefined;
[noMarker] Evaluation complete
"
`;

exports[`SOURCE 0 (Tests from previous stepper) undefined || 1 1`] = `
"undefined || 1;
[noMarker] Start of evaluation

undefined || 1;
[noMarker] Evaluation complete
"
`;

exports[`Statements: Blocks Block-statement-empty-reduce test case 1 1`] = `
"{}
[noMarker] Start of evaluation

{}
[beforeMarker] Empty block expression evaluated


[afterMarker] Empty block expression evaluated

undefined;
[noMarker] Evaluation complete
"
`;

exports[`Statements: Blocks Block-statement-empty-reduce test case 2 1`] = `
"{ { {} {} } { {} {} }}
[noMarker] Start of evaluation

{ { {} {} } { {} {} }}
[beforeMarker] Empty block expression evaluated

{ { {} } { {} {} }}
[afterMarker] Empty block expression evaluated

{ { {} } { {} {} }}
[beforeMarker] Empty block expression evaluated

{ {} { {} {} }}
[afterMarker] Empty block expression evaluated

{ {} { {} {} }}
[beforeMarker] Empty block expression evaluated

{ { {} {} }}
[afterMarker] Empty block expression evaluated

{ { {} {} }}
[beforeMarker] {
  {}
  {}
} finished evaluating

{ {} {}}
[afterMarker] {
  {}
  {}
} finished evaluating

{ {} {}}
[beforeMarker] Empty block expression evaluated

{ {}}
[afterMarker] Empty block expression evaluated

{ {}}
[beforeMarker] Empty block expression evaluated

{}
[afterMarker] Empty block expression evaluated

{}
[beforeMarker] Empty block expression evaluated


[afterMarker] Empty block expression evaluated

undefined;
[noMarker] Evaluation complete
"
`;

exports[`Statements: Blocks Block-statement-intro test case 1`] = `
"{ 1 + 1;}
[noMarker] Start of evaluation

{ 1 + 1;}
[beforeMarker] Binary expression 1 + 1 evaluated

{ 2;}
[afterMarker] Binary expression 1 + 1 evaluated

{ 2;}
[beforeMarker] 2; finished evaluating

2;
[afterMarker] 2; finished evaluating

2;
[noMarker] Evaluation complete
"
`;

exports[`Statements: Blocks Block-statement-single-reduce test case 1`] = `
"{ 1;}
[noMarker] Start of evaluation

{ 1;}
[beforeMarker] 1; finished evaluating

1;
[afterMarker] 1; finished evaluating

1;
[noMarker] Evaluation complete
"
`;

exports[`Statements: Conditionals Conditional-statement-alternative test case 1`] = `
"if (false) { 1;} else { 2;}
[noMarker] Start of evaluation

if (false) { 1;} else { 2;}
[beforeMarker] If statement evaluated, condition false, proceed to else block

{ undefined; 2;}
[afterMarker] If statement evaluated, condition false, proceed to else block

{ undefined; 2;}
[beforeMarker] undefined finished evaluating

{ 2;}
[afterMarker] undefined finished evaluating

{ 2;}
[beforeMarker] 2; finished evaluating

2;
[afterMarker] 2; finished evaluating

2;
[noMarker] Evaluation complete
"
`;

exports[`Statements: Conditionals Conditional-statement-blockexpr-alternative test case 1 1`] = `
"function foo(x) { if (false) { 1; } else { 2; }}foo(0);
[noMarker] Start of evaluation

function foo(x) { if (false) { 1; } else { 2; }}foo(0);
[beforeMarker] Function foo declared, parameter(s) x required

(x => { if (false) { 1; } else { 2; }})(0);
[afterMarker] Function foo declared, parameter(s) x required

(x => { if (false) { 1; } else { 2; }})(0);
[beforeMarker] Function foo takes in 0 as input x

{ if (false) { 1; } else { 2; }};
[afterMarker] Function foo takes in 0 as input x

{ if (false) { 1; } else { 2; }};
[beforeMarker] If statement evaluated, condition false, proceed to else block

{ { undefined; 2; }};
[afterMarker] If statement evaluated, condition false, proceed to else block

{ { undefined; 2; }};
[beforeMarker] undefined finished evaluating

{ { 2; }};
[afterMarker] undefined finished evaluating

{ { 2; }};
[beforeMarker] 2; finished evaluating

{ 2;};
[afterMarker] 2; finished evaluating

{ 2;};
[beforeMarker] 2; finished evaluating

undefined;
[afterMarker] 2; finished evaluating

undefined;
[noMarker] Evaluation complete
"
`;

exports[`Statements: Conditionals Conditional-statement-blockexpr-alternative test case 2 1`] = `
"function foo(x) { 3; if (false) { 1; } else { 2; }}foo(0);
[noMarker] Start of evaluation

function foo(x) { 3; if (false) { 1; } else { 2; }}foo(0);
[beforeMarker] Function foo declared, parameter(s) x required

(x => { 3; if (false) { 1; } else { 2; }})(0);
[afterMarker] Function foo declared, parameter(s) x required

(x => { 3; if (false) { 1; } else { 2; }})(0);
[beforeMarker] Function foo takes in 0 as input x

{ 3; if (false) { 1; } else { 2; }};
[afterMarker] Function foo takes in 0 as input x

{ 3; if (false) { 1; } else { 2; }};
[beforeMarker] If statement evaluated, condition false, proceed to else block

{ 3; { undefined; 2; }};
[afterMarker] If statement evaluated, condition false, proceed to else block

{ 3; { undefined; 2; }};
[beforeMarker] undefined finished evaluating

{ 3; { 2; }};
[afterMarker] undefined finished evaluating

{ 3; { 2; }};
[beforeMarker] 2; finished evaluating

{ 3; 2;};
[afterMarker] 2; finished evaluating

{ 3; 2;};
[beforeMarker] 3 finished evaluating

{ 2;};
[afterMarker] 3 finished evaluating

{ 2;};
[beforeMarker] 2; finished evaluating

undefined;
[afterMarker] 2; finished evaluating

undefined;
[noMarker] Evaluation complete
"
`;

exports[`Statements: Conditionals Conditional-statement-blockexpr-consequent test case 1 1`] = `
"function foo(x) { if (true) { 1; } else { 2; }}foo(0);
[noMarker] Start of evaluation

function foo(x) { if (true) { 1; } else { 2; }}foo(0);
[beforeMarker] Function foo declared, parameter(s) x required

(x => { if (true) { 1; } else { 2; }})(0);
[afterMarker] Function foo declared, parameter(s) x required

(x => { if (true) { 1; } else { 2; }})(0);
[beforeMarker] Function foo takes in 0 as input x

{ if (true) { 1; } else { 2; }};
[afterMarker] Function foo takes in 0 as input x

{ if (true) { 1; } else { 2; }};
[beforeMarker] If statement evaluated, condition true, proceed to if block

{ { undefined; 1; }};
[afterMarker] If statement evaluated, condition true, proceed to if block

{ { undefined; 1; }};
[beforeMarker] undefined finished evaluating

{ { 1; }};
[afterMarker] undefined finished evaluating

{ { 1; }};
[beforeMarker] 1; finished evaluating

{ 1;};
[afterMarker] 1; finished evaluating

{ 1;};
[beforeMarker] 1; finished evaluating

undefined;
[afterMarker] 1; finished evaluating

undefined;
[noMarker] Evaluation complete
"
`;

exports[`Statements: Conditionals Conditional-statement-blockexpr-consequent test case 2 1`] = `
"function foo(x) { 3; if (true) { 1; } else { 2; }}foo(0);
[noMarker] Start of evaluation

function foo(x) { 3; if (true) { 1; } else { 2; }}foo(0);
[beforeMarker] Function foo declared, parameter(s) x required

(x => { 3; if (true) { 1; } else { 2; }})(0);
[afterMarker] Function foo declared, parameter(s) x required

(x => { 3; if (true) { 1; } else { 2; }})(0);
[beforeMarker] Function foo takes in 0 as input x

{ 3; if (true) { 1; } else { 2; }};
[afterMarker] Function foo takes in 0 as input x

{ 3; if (true) { 1; } else { 2; }};
[beforeMarker] If statement evaluated, condition true, proceed to if block

{ 3; { undefined; 1; }};
[afterMarker] If statement evaluated, condition true, proceed to if block

{ 3; { undefined; 1; }};
[beforeMarker] undefined finished evaluating

{ 3; { 1; }};
[afterMarker] undefined finished evaluating

{ 3; { 1; }};
[beforeMarker] 1; finished evaluating

{ 3; 1;};
[afterMarker] 1; finished evaluating

{ 3; 1;};
[beforeMarker] 3 finished evaluating

{ 1;};
[afterMarker] 3 finished evaluating

{ 1;};
[beforeMarker] 1; finished evaluating

undefined;
[afterMarker] 1; finished evaluating

undefined;
[noMarker] Evaluation complete
"
`;

exports[`Statements: Conditionals Conditional-statement-consequent test case 1`] = `
"if (true) { 1;} else { 2;}
[noMarker] Start of evaluation

if (true) { 1;} else { 2;}
[beforeMarker] If statement evaluated, condition true, proceed to if block

{ undefined; 1;}
[afterMarker] If statement evaluated, condition true, proceed to if block

{ undefined; 1;}
[beforeMarker] undefined finished evaluating

{ 1;}
[afterMarker] undefined finished evaluating

{ 1;}
[beforeMarker] 1; finished evaluating

1;
[afterMarker] 1; finished evaluating

1;
[noMarker] Evaluation complete
"
`;

exports[`Statements: Conditionals Conditional-statement-predicate test case 1`] = `
"if (1 + 2 + 3 === 1) {} else {}
[noMarker] Start of evaluation

if (1 + 2 + 3 === 1) {} else {}
[beforeMarker] Binary expression 1 + 2 evaluated

if (3 + 3 === 1) {} else {}
[afterMarker] Binary expression 1 + 2 evaluated

if (3 + 3 === 1) {} else {}
[beforeMarker] Binary expression 3 + 3 evaluated

if (6 === 1) {} else {}
[afterMarker] Binary expression 3 + 3 evaluated

if (6 === 1) {} else {}
[beforeMarker] Binary expression 6 === 1 evaluated

if (false) {} else {}
[afterMarker] Binary expression 6 === 1 evaluated

if (false) {} else {}
[beforeMarker] If statement evaluated, condition false, proceed to else block

{ undefined;}
[afterMarker] If statement evaluated, condition false, proceed to else block

{ undefined;}
[beforeMarker] undefined; finished evaluating

undefined;
[afterMarker] undefined; finished evaluating

undefined;
[noMarker] Evaluation complete
"
`;

exports[`Statements: Constant declarations Evaluate-constant-declaration test case 1`] = `
"const x = 1 + 2 + 3;
[noMarker] Start of evaluation

const x = 1 + 2 + 3;
[beforeMarker] Binary expression 1 + 2 evaluated

const x = 3 + 3;
[afterMarker] Binary expression 1 + 2 evaluated

const x = 3 + 3;
[beforeMarker] Binary expression 3 + 3 evaluated

const x = 6;
[afterMarker] Binary expression 3 + 3 evaluated

const x = 6;
[beforeMarker] Constant x declared and substituted into the rest of block


[afterMarker] Constant x declared and substituted into the rest of block

undefined;
[noMarker] Evaluation complete
"
`;

exports[`Statements: Expression statements Expression-statement-reduce test case 1`] = `
"1 + 2 + 3;
[noMarker] Start of evaluation

1 + 2 + 3;
[beforeMarker] Binary expression 1 + 2 evaluated

3 + 3;
[afterMarker] Binary expression 1 + 2 evaluated

3 + 3;
[beforeMarker] Binary expression 3 + 3 evaluated

6;
[afterMarker] Binary expression 3 + 3 evaluated

6;
[noMarker] Evaluation complete
"
`;

exports[`Test catching errors from built in function Incorrect number of arguments 1`] = `
"pair(2);
[noMarker] Start of evaluation

pair(2);
[beforeMarker] Expected 2 arguments, but got 1.

pair(2);
[noMarker] Evaluation stuck
"
`;

exports[`Test catching errors from built in function Incorrect type of argument for math function 1`] = `
"math_sin(true);
[noMarker] Start of evaluation

math_sin(true);
[beforeMarker] Math functions must be called with number arguments

math_sin(true);
[noMarker] Evaluation stuck
"
`;

exports[`Test catching errors from built in function Incorrect type of arguments for module function 1`] = `
"arity(\\"not a function\\");
[noMarker] Start of evaluation

arity(\\"not a function\\");
[beforeMarker] arity expects a function as argument

arity(\\"not a function\\");
[noMarker] Evaluation stuck
"
`;

exports[`Test catching undefined variables Name declared later but not yet assigned 1`] = `
"x;const x = 1;x;
[noMarker] Start of evaluation

x;const x = 1;x;
[beforeMarker] Name x declared later in current scope but not yet assigned

x;const x = 1;x;
[noMarker] Evaluation stuck
"
`;

exports[`Test catching undefined variables Undefined variables 1 1`] = `
"x;
[noMarker] Start of evaluation

x;
[beforeMarker] Line 2: Name x not declared.
"
`;

exports[`Test catching undefined variables Undefined variables 3 1`] = `
"const f = () => x;
[noMarker] Start of evaluation

const f = () => x;
[beforeMarker] Line 2: Name x not declared.
"
`;

exports[`Test catching undefined variables Undefined variables 4 1`] = `
"const f = () => x;const x = 1;f();
[noMarker] Start of evaluation

const f = () => x;const x = 1;f();
[beforeMarker] Constant f declared and substituted into the rest of block

const x = 1;(() => x)();
[afterMarker] Constant f declared and substituted into the rest of block

const x = 1;(() => x)();
[beforeMarker] Constant x declared and substituted into the rest of block

(() => 1)();
[afterMarker] Constant x declared and substituted into the rest of block

(() => 1)();
[beforeMarker] () => 1 runs

1;
[afterMarker] () => 1 runs

1;
[noMarker] Evaluation complete
"
`;

exports[`Test constant declaration substitution 1`] = `
"const x = -1;x;const y = 2;y;
[noMarker] Start of evaluation

const x = -1;x;const y = 2;y;
[beforeMarker] Constant x declared and substituted into the rest of block

-1;const y = 2;y;
[afterMarker] Constant x declared and substituted into the rest of block

-1;const y = 2;y;
[beforeMarker] Constant y declared and substituted into the rest of block

-1;2;
[afterMarker] Constant y declared and substituted into the rest of block

-1;2;
[beforeMarker] -1 finished evaluating

2;
[afterMarker] -1 finished evaluating

2;
[noMarker] Evaluation complete
"
`;

exports[`Test correct evaluation sequence when first statement is a value Irreducible second statement in block 1`] = `
"{ 'value'; 'also a value';}
[noMarker] Start of evaluation

{ 'value'; 'also a value';}
[beforeMarker] 'value' finished evaluating

{ 'also a value';}
[afterMarker] 'value' finished evaluating

{ 'also a value';}
[beforeMarker] 'also a value'; finished evaluating

'also a value';
[afterMarker] 'also a value'; finished evaluating

'also a value';
[noMarker] Evaluation complete
"
`;

exports[`Test correct evaluation sequence when first statement is a value Irreducible second statement in functions 1`] = `
"function f() { 'value'; 'also a value'; return 'another value';}f();
[noMarker] Start of evaluation

function f() { 'value'; 'also a value'; return 'another value';}f();
[beforeMarker] Function f declared, parameter(s)  required

(() => { 'value'; 'also a value'; return 'another value';})();
[afterMarker] Function f declared, parameter(s)  required

(() => { 'value'; 'also a value'; return 'another value';})();
[beforeMarker] () => {...} runs

{ 'value'; 'also a value'; return 'another value';};
[afterMarker] () => {...} runs

{ 'value'; 'also a value'; return 'another value';};
[beforeMarker] 'value' finished evaluating

{ 'also a value'; return 'another value';};
[afterMarker] 'value' finished evaluating

{ 'also a value'; return 'another value';};
[beforeMarker] 'also a value' finished evaluating

{ return 'another value';};
[afterMarker] 'also a value' finished evaluating

{ return 'another value';};
[beforeMarker] 'another value' returned

'another value';
[afterMarker] 'another value' returned

'another value';
[noMarker] Evaluation complete
"
`;

exports[`Test correct evaluation sequence when first statement is a value Irreducible second statement in program 1`] = `
"'value';'also a value';
[noMarker] Start of evaluation

'value';'also a value';
[beforeMarker] 'value' finished evaluating

'also a value';
[afterMarker] 'value' finished evaluating

'also a value';
[noMarker] Evaluation complete
"
`;

exports[`Test correct evaluation sequence when first statement is a value Mix statements 1`] = `
"'value';const x = 10;function f() { 20; function p() { 22; }}const z = 30;'also a value';{ 'another value'; const a = 40; a;}'another value';const a = 40;
[noMarker] Start of evaluation

'value';const x = 10;function f() { 20; function p() { 22; }}const z = 30;'also a value';{ 'another value'; const a = 40; a;}'another value';const a = 40;
[beforeMarker] Constant x declared and substituted into the rest of block

'value';function f() { 20; function p() { 22; }}const z = 30;'also a value';{ 'another value'; const a = 40; a;}'another value';const a = 40;
[afterMarker] Constant x declared and substituted into the rest of block

'value';function f() { 20; function p() { 22; }}const z = 30;'also a value';{ 'another value'; const a = 40; a;}'another value';const a = 40;
[beforeMarker] Function f declared, parameter(s)  required

'value';const z = 30;'also a value';{ 'another value'; const a = 40; a;}'another value';const a = 40;
[afterMarker] Function f declared, parameter(s)  required

'value';const z = 30;'also a value';{ 'another value'; const a = 40; a;}'another value';const a = 40;
[beforeMarker] Constant z declared and substituted into the rest of block

'value';'also a value';{ 'another value'; const a = 40; a;}'another value';const a = 40;
[afterMarker] Constant z declared and substituted into the rest of block

'value';'also a value';{ 'another value'; const a = 40; a;}'another value';const a = 40;
[beforeMarker] 'value' finished evaluating

'also a value';{ 'another value'; const a = 40; a;}'another value';const a = 40;
[afterMarker] 'value' finished evaluating

'also a value';{ 'another value'; const a = 40; a;}'another value';const a = 40;
[beforeMarker] Constant a declared and substituted into the rest of block

'also a value';{ 'another value'; 40;}'another value';const a = 40;
[afterMarker] Constant a declared and substituted into the rest of block

'also a value';{ 'another value'; 40;}'another value';const a = 40;
[beforeMarker] 'another value' finished evaluating

'also a value';{ 40;}'another value';const a = 40;
[afterMarker] 'another value' finished evaluating

'also a value';{ 40;}'another value';const a = 40;
[beforeMarker] 40; finished evaluating

'also a value';40;'another value';const a = 40;
[afterMarker] 40; finished evaluating

'also a value';40;'another value';const a = 40;
[beforeMarker] 'also a value' finished evaluating

40;'another value';const a = 40;
[afterMarker] 'also a value' finished evaluating

40;'another value';const a = 40;
[beforeMarker] 40 finished evaluating

'another value';const a = 40;
[afterMarker] 40 finished evaluating

'another value';const a = 40;
[beforeMarker] Constant a declared and substituted into the rest of block

'another value';
[afterMarker] Constant a declared and substituted into the rest of block

'another value';
[noMarker] Evaluation complete
"
`;

exports[`Test correct evaluation sequence when first statement is a value Reducible second statement in block 1`] = `
"{ 'value'; const x = 10;}
[noMarker] Start of evaluation

{ 'value'; const x = 10;}
[beforeMarker] Constant x declared and substituted into the rest of block

{ 'value';}
[afterMarker] Constant x declared and substituted into the rest of block

{ 'value';}
[beforeMarker] 'value'; finished evaluating

'value';
[afterMarker] 'value'; finished evaluating

'value';
[noMarker] Evaluation complete
"
`;

exports[`Test correct evaluation sequence when first statement is a value Reducible second statement in function 1`] = `
"function f() { 'value'; const x = 10; return 'another value';}f();
[noMarker] Start of evaluation

function f() { 'value'; const x = 10; return 'another value';}f();
[beforeMarker] Function f declared, parameter(s)  required

(() => { 'value'; const x = 10; return 'another value';})();
[afterMarker] Function f declared, parameter(s)  required

(() => { 'value'; const x = 10; return 'another value';})();
[beforeMarker] () => {...} runs

{ 'value'; const x = 10; return 'another value';};
[afterMarker] () => {...} runs

{ 'value'; const x = 10; return 'another value';};
[beforeMarker] Constant x declared and substituted into the rest of block

{ 'value'; return 'another value';};
[afterMarker] Constant x declared and substituted into the rest of block

{ 'value'; return 'another value';};
[beforeMarker] 'value' finished evaluating

{ return 'another value';};
[afterMarker] 'value' finished evaluating

{ return 'another value';};
[beforeMarker] 'another value' returned

'another value';
[afterMarker] 'another value' returned

'another value';
[noMarker] Evaluation complete
"
`;

exports[`Test correct evaluation sequence when first statement is a value Reducible second statement in program 1`] = `
"\\"value\\";const x = 10;
[noMarker] Start of evaluation

\\"value\\";const x = 10;
[beforeMarker] Constant x declared and substituted into the rest of block

\\"value\\";
[afterMarker] Constant x declared and substituted into the rest of block

\\"value\\";
[noMarker] Evaluation complete
"
`;

exports[`Test reducing of empty block into epsilon Empty block in function 1`] = `
"function f() { 3; {}}f();
[noMarker] Start of evaluation

function f() { 3; {}}f();
[beforeMarker] Function f declared, parameter(s)  required

(() => { 3; {}})();
[afterMarker] Function f declared, parameter(s)  required

(() => { 3; {}})();
[beforeMarker] () => {...} runs

{ 3; {}};
[afterMarker] () => {...} runs

{ 3; {}};
[beforeMarker] Empty block expression evaluated

{ 3;};
[afterMarker] Empty block expression evaluated

{ 3;};
[beforeMarker] 3; finished evaluating

undefined;
[afterMarker] 3; finished evaluating

undefined;
[noMarker] Evaluation complete
"
`;

exports[`Test reducing of empty block into epsilon Empty block in program 1`] = `
"3;{}
[noMarker] Start of evaluation

3;{}
[beforeMarker] Empty block expression evaluated

3;
[afterMarker] Empty block expression evaluated

3;
[noMarker] Evaluation complete
"
`;

exports[`Test reducing of empty block into epsilon Empty blocks in block 1`] = `
"{ 3; { {} {} }}
[noMarker] Start of evaluation

{ 3; { {} {} }}
[beforeMarker] Empty block expression evaluated

{ 3; { {} }}
[afterMarker] Empty block expression evaluated

{ 3; { {} }}
[beforeMarker] Empty block expression evaluated

{ 3; {}}
[afterMarker] Empty block expression evaluated

{ 3; {}}
[beforeMarker] Empty block expression evaluated

{ 3;}
[afterMarker] Empty block expression evaluated

{ 3;}
[beforeMarker] 3; finished evaluating

3;
[afterMarker] 3; finished evaluating

3;
[noMarker] Evaluation complete
"
`;

exports[`Test runtime errors Incompatible types operation 1`] = `
"\\"1\\" + 2 * 3;
[noMarker] Start of evaluation

\\"1\\" + 2 * 3;
[beforeMarker] Binary expression 2 * 3 evaluated

\\"1\\" + 6;
[afterMarker] Binary expression 2 * 3 evaluated

\\"1\\" + 6;
[beforeMarker] Line 0: Expected string on right hand side of operation, got number.

\\"1\\" + 6;
[noMarker] Evaluation stuck
"
`;

exports[`Test two statements 1`] = `
"(1 + 2) * (3 + 4);3 * 5;
[noMarker] Start of evaluation

(1 + 2) * (3 + 4);3 * 5;
[beforeMarker] Binary expression 1 + 2 evaluated

3 * (3 + 4);3 * 5;
[afterMarker] Binary expression 1 + 2 evaluated

3 * (3 + 4);3 * 5;
[beforeMarker] Binary expression 3 + 4 evaluated

3 * 7;3 * 5;
[afterMarker] Binary expression 3 + 4 evaluated

3 * 7;3 * 5;
[beforeMarker] Binary expression 3 * 7 evaluated

21;3 * 5;
[afterMarker] Binary expression 3 * 7 evaluated

21;3 * 5;
[beforeMarker] Binary expression 3 * 5 evaluated

21;15;
[afterMarker] Binary expression 3 * 5 evaluated

21;15;
[beforeMarker] 21 finished evaluating

15;
[afterMarker] 21 finished evaluating

15;
[noMarker] Evaluation complete
"
`;

exports[`const declarations in blocks subst into call expressions 1`] = `
"const z = 1;function f(g) { const z = 3; return (y => z + z)(z);}f(undefined);
[noMarker] Start of evaluation

const z = 1;function f(g) { const z = 3; return (y => z + z)(z);}f(undefined);
[beforeMarker] Constant z declared and substituted into the rest of block

function f(g) { const z = 3; return (y => z + z)(z);}f(undefined);
[afterMarker] Constant z declared and substituted into the rest of block

function f(g) { const z = 3; return (y => z + z)(z);}f(undefined);
[beforeMarker] Function f declared, parameter(s) g required

(g => { const z = 3; return (y => z + z)(z);})(undefined);
[afterMarker] Function f declared, parameter(s) g required

(g => { const z = 3; return (y => z + z)(z);})(undefined);
[beforeMarker] Function f takes in undefined as input g

{ const z = 3; return (y => z + z)(z);};
[afterMarker] Function f takes in undefined as input g

{ const z = 3; return (y => z + z)(z);};
[beforeMarker] Constant z declared and substituted into the rest of block

{ return (y => 3 + 3)(3);};
[afterMarker] Constant z declared and substituted into the rest of block

{ return (y => 3 + 3)(3);};
[beforeMarker] (y => 3 + 3)(3) returned

(y => 3 + 3)(3);
[afterMarker] (y => 3 + 3)(3) returned

(y => 3 + 3)(3);
[beforeMarker] 3 substituted into y of y => 3 + 3

3 + 3;
[afterMarker] 3 substituted into y of y => 3 + 3

3 + 3;
[beforeMarker] Binary expression 3 + 3 evaluated

6;
[afterMarker] Binary expression 3 + 3 evaluated

6;
[noMarker] Evaluation complete
"
`;

exports[`constant declarations in blocks are protected 1`] = `
"const z = 1;function f(g) { const z = 3; return g(z);}f(y => y + z);
[noMarker] Start of evaluation

const z = 1;function f(g) { const z = 3; return g(z);}f(y => y + z);
[beforeMarker] Constant z declared and substituted into the rest of block

function f(g) { const z = 3; return g(z);}f(y => y + 1);
[afterMarker] Constant z declared and substituted into the rest of block

function f(g) { const z = 3; return g(z);}f(y => y + 1);
[beforeMarker] Function f declared, parameter(s) g required

(g => { const z = 3; return g(z);})(y => y + 1);
[afterMarker] Function f declared, parameter(s) g required

(g => { const z = 3; return g(z);})(y => y + 1);
[beforeMarker] Function f takes in y => y + 1 as input g

{ const z = 3; return (y => y + 1)(z);};
[afterMarker] Function f takes in y => y + 1 as input g

{ const z = 3; return (y => y + 1)(z);};
[beforeMarker] Constant z declared and substituted into the rest of block

{ return (y => y + 1)(3);};
[afterMarker] Constant z declared and substituted into the rest of block

{ return (y => y + 1)(3);};
[beforeMarker] (y => y + 1)(3) returned

(y => y + 1)(3);
[afterMarker] (y => y + 1)(3) returned

(y => y + 1)(3);
[beforeMarker] 3 substituted into y of y => y + 1

3 + 1;
[afterMarker] 3 substituted into y of y => y + 1

3 + 1;
[beforeMarker] Binary expression 3 + 1 evaluated

4;
[afterMarker] Binary expression 3 + 1 evaluated

4;
[noMarker] Evaluation complete
"
`;

exports[`function declarations in blocks are protected 1`] = `
"function repeat_pattern(n, p, r) { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);}function plus_one(x) { return x + 1;}repeat_pattern(5, plus_one, 0);
[noMarker] Start of evaluation

function repeat_pattern(n, p, r) { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);}function plus_one(x) { return x + 1;}repeat_pattern(5, plus_one, 0);
[beforeMarker] Function repeat_pattern declared, parameter(s) n,p,r required

function plus_one(x) { return x + 1;}((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5, plus_one, 0);
[afterMarker] Function repeat_pattern declared, parameter(s) n,p,r required

function plus_one(x) { return x + 1;}((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5, plus_one, 0);
[beforeMarker] Function plus_one declared, parameter(s) x required

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5, x => { return x + 1;}, 0);
[afterMarker] Function plus_one declared, parameter(s) x required

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5, x => { return x + 1;}, 0);
[beforeMarker] Function repeat_pattern takes in 5, plus_one, 0 as input n, p, r

{ function twice_p(r) { return (x => { return x + 1; })((x => { return x + 1; })(r)); } return 5 === 0 ? 0 : 5 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(5 - 1, x => { return x + 1; }, (x => { return x + 1; })(0)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(5 / 2, twice_p, 0);};
[afterMarker] Function repeat_pattern takes in 5, plus_one, 0 as input n, p, r

{ function twice_p(r) { return (x => { return x + 1; })((x => { return x + 1; })(r)); } return 5 === 0 ? 0 : 5 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(5 - 1, x => { return x + 1; }, (x => { return x + 1; })(0)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(5 / 2, twice_p, 0);};
[beforeMarker] Function twice_p declared, parameter(s) r required

{ return 5 === 0 ? 0 : 5 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(5 - 1, x => { return x + 1; }, (x => { return x + 1; })(0)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(5 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); }, 0);};
[afterMarker] Function twice_p declared, parameter(s) r required

{ return 5 === 0 ? 0 : 5 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(5 - 1, x => { return x + 1; }, (x => { return x + 1; })(0)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(5 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); }, 0);};
[beforeMarker] 5 === 0 ? 0 : 5 % 2 !== 0 ? ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(5 - 1, x => {
  return x + 1;
}, (x => {
  return x + 1;
})(0)) : ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(5 / 2, r => {
  return (x => {
    return x + 1;
  })((x => {
    return x + 1;
  })(r));
}, 0) returned

5 === 0 ? 0 : 5 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 - 1, x => { return x + 1;}, (x => { return x + 1;})(0)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 0);
[afterMarker] 5 === 0 ? 0 : 5 % 2 !== 0 ? ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(5 - 1, x => {
  return x + 1;
}, (x => {
  return x + 1;
})(0)) : ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(5 / 2, r => {
  return (x => {
    return x + 1;
  })((x => {
    return x + 1;
  })(r));
}, 0) returned

5 === 0 ? 0 : 5 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 - 1, x => { return x + 1;}, (x => { return x + 1;})(0)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 0);
[beforeMarker] Binary expression 5 === 0 evaluated

false ? 0 : 5 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 - 1, x => { return x + 1;}, (x => { return x + 1;})(0)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 0);
[afterMarker] Binary expression 5 === 0 evaluated

false ? 0 : 5 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 - 1, x => { return x + 1;}, (x => { return x + 1;})(0)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 0);
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

5 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 - 1, x => { return x + 1;}, (x => { return x + 1;})(0)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 0);
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

5 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 - 1, x => { return x + 1;}, (x => { return x + 1;})(0)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 0);
[beforeMarker] Binary expression 5 % 2 evaluated

1 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 - 1, x => { return x + 1;}, (x => { return x + 1;})(0)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 0);
[afterMarker] Binary expression 5 % 2 evaluated

1 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 - 1, x => { return x + 1;}, (x => { return x + 1;})(0)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 0);
[beforeMarker] Binary expression 1 !== 0 evaluated

true ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 - 1, x => { return x + 1;}, (x => { return x + 1;})(0)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 0);
[afterMarker] Binary expression 1 !== 0 evaluated

true ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 - 1, x => { return x + 1;}, (x => { return x + 1;})(0)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 0);
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 - 1, x => { return x + 1;}, (x => { return x + 1;})(0));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(5 - 1, x => { return x + 1;}, (x => { return x + 1;})(0));
[beforeMarker] Binary expression 5 - 1 evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4, x => { return x + 1;}, (x => { return x + 1;})(0));
[afterMarker] Binary expression 5 - 1 evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4, x => { return x + 1;}, (x => { return x + 1;})(0));
[beforeMarker] Function plus_one takes in 0 as input x

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4, x => { return x + 1;}, 0 + 1);
[afterMarker] Function plus_one takes in 0 as input x

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4, x => { return x + 1;}, 0 + 1);
[beforeMarker] Binary expression 0 + 1 evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4, x => { return x + 1;}, 1);
[afterMarker] Binary expression 0 + 1 evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4, x => { return x + 1;}, 1);
[beforeMarker] Function repeat_pattern takes in 4, plus_one, 1 as input n, p, r

{ function twice_p(r) { return (x => { return x + 1; })((x => { return x + 1; })(r)); } return 4 === 0 ? 1 : 4 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(4 - 1, x => { return x + 1; }, (x => { return x + 1; })(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(4 / 2, twice_p, 1);};
[afterMarker] Function repeat_pattern takes in 4, plus_one, 1 as input n, p, r

{ function twice_p(r) { return (x => { return x + 1; })((x => { return x + 1; })(r)); } return 4 === 0 ? 1 : 4 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(4 - 1, x => { return x + 1; }, (x => { return x + 1; })(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(4 / 2, twice_p, 1);};
[beforeMarker] Function twice_p declared, parameter(s) r required

{ return 4 === 0 ? 1 : 4 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(4 - 1, x => { return x + 1; }, (x => { return x + 1; })(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(4 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); }, 1);};
[afterMarker] Function twice_p declared, parameter(s) r required

{ return 4 === 0 ? 1 : 4 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(4 - 1, x => { return x + 1; }, (x => { return x + 1; })(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(4 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); }, 1);};
[beforeMarker] 4 === 0 ? 1 : 4 % 2 !== 0 ? ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(4 - 1, x => {
  return x + 1;
}, (x => {
  return x + 1;
})(1)) : ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(4 / 2, r => {
  return (x => {
    return x + 1;
  })((x => {
    return x + 1;
  })(r));
}, 1) returned

4 === 0 ? 1 : 4 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 - 1, x => { return x + 1;}, (x => { return x + 1;})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 1);
[afterMarker] 4 === 0 ? 1 : 4 % 2 !== 0 ? ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(4 - 1, x => {
  return x + 1;
}, (x => {
  return x + 1;
})(1)) : ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(4 / 2, r => {
  return (x => {
    return x + 1;
  })((x => {
    return x + 1;
  })(r));
}, 1) returned

4 === 0 ? 1 : 4 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 - 1, x => { return x + 1;}, (x => { return x + 1;})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 1);
[beforeMarker] Binary expression 4 === 0 evaluated

false ? 1 : 4 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 - 1, x => { return x + 1;}, (x => { return x + 1;})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 1);
[afterMarker] Binary expression 4 === 0 evaluated

false ? 1 : 4 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 - 1, x => { return x + 1;}, (x => { return x + 1;})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 1);
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

4 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 - 1, x => { return x + 1;}, (x => { return x + 1;})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 1);
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

4 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 - 1, x => { return x + 1;}, (x => { return x + 1;})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 1);
[beforeMarker] Binary expression 4 % 2 evaluated

0 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 - 1, x => { return x + 1;}, (x => { return x + 1;})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 1);
[afterMarker] Binary expression 4 % 2 evaluated

0 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 - 1, x => { return x + 1;}, (x => { return x + 1;})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 1);
[beforeMarker] Binary expression 0 !== 0 evaluated

false ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 - 1, x => { return x + 1;}, (x => { return x + 1;})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 1);
[afterMarker] Binary expression 0 !== 0 evaluated

false ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 - 1, x => { return x + 1;}, (x => { return x + 1;})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 1);
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 1);
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(4 / 2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 1);
[beforeMarker] Binary expression 4 / 2 evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 1);
[afterMarker] Binary expression 4 / 2 evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, 1);
[beforeMarker] Function repeat_pattern takes in 2, twice_p, 1 as input n, p, r

{ function twice_p(r) { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); } return 2 === 0 ? 1 : 2 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(2 - 1, r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); }, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(2 / 2, twice_p, 1);};
[afterMarker] Function repeat_pattern takes in 2, twice_p, 1 as input n, p, r

{ function twice_p(r) { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); } return 2 === 0 ? 1 : 2 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(2 - 1, r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); }, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(2 / 2, twice_p, 1);};
[beforeMarker] Function twice_p declared, parameter(s) r required

{ return 2 === 0 ? 1 : 2 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(2 - 1, r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); }, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(2 / 2, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); }, 1);};
[afterMarker] Function twice_p declared, parameter(s) r required

{ return 2 === 0 ? 1 : 2 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(2 - 1, r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); }, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(2 / 2, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); }, 1);};
[beforeMarker] 2 === 0 ? 1 : 2 % 2 !== 0 ? ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(2 - 1, r => {
  return (x => {
    return x + 1;
  })((x => {
    return x + 1;
  })(r));
}, (r => {
  return (x => {
    return x + 1;
  })((x => {
    return x + 1;
  })(r));
})(1)) : ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(2 / 2, r => {
  return (r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })((r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })(r));
}, 1) returned

2 === 0 ? 1 : 2 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 - 1, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 / 2, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, 1);
[afterMarker] 2 === 0 ? 1 : 2 % 2 !== 0 ? ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(2 - 1, r => {
  return (x => {
    return x + 1;
  })((x => {
    return x + 1;
  })(r));
}, (r => {
  return (x => {
    return x + 1;
  })((x => {
    return x + 1;
  })(r));
})(1)) : ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(2 / 2, r => {
  return (r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })((r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })(r));
}, 1) returned

2 === 0 ? 1 : 2 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 - 1, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 / 2, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, 1);
[beforeMarker] Binary expression 2 === 0 evaluated

false ? 1 : 2 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 - 1, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 / 2, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, 1);
[afterMarker] Binary expression 2 === 0 evaluated

false ? 1 : 2 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 - 1, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 / 2, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, 1);
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

2 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 - 1, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 / 2, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, 1);
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

2 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 - 1, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 / 2, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, 1);
[beforeMarker] Binary expression 2 % 2 evaluated

0 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 - 1, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 / 2, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, 1);
[afterMarker] Binary expression 2 % 2 evaluated

0 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 - 1, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 / 2, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, 1);
[beforeMarker] Binary expression 0 !== 0 evaluated

false ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 - 1, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 / 2, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, 1);
[afterMarker] Binary expression 0 !== 0 evaluated

false ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 - 1, r => { return (x => { return x + 1; })((x => { return x + 1; })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 / 2, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, 1);
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 / 2, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, 1);
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(2 / 2, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, 1);
[beforeMarker] Binary expression 2 / 2 evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, 1);
[afterMarker] Binary expression 2 / 2 evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, 1);
[beforeMarker] Function repeat_pattern takes in 1, twice_p, 1 as input n, p, r

{ function twice_p(r) { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r)); } return 1 === 0 ? 1 : 1 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(1 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); }, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(1 / 2, twice_p, 1);};
[afterMarker] Function repeat_pattern takes in 1, twice_p, 1 as input n, p, r

{ function twice_p(r) { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r)); } return 1 === 0 ? 1 : 1 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(1 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); }, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(1 / 2, twice_p, 1);};
[beforeMarker] Function twice_p declared, parameter(s) r required

{ return 1 === 0 ? 1 : 1 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(1 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); }, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(1 / 2, r => { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r)); }, 1);};
[afterMarker] Function twice_p declared, parameter(s) r required

{ return 1 === 0 ? 1 : 1 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(1 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); }, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(1 / 2, r => { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r)); }, 1);};
[beforeMarker] 1 === 0 ? 1 : 1 % 2 !== 0 ? ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(1 - 1, r => {
  return (r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })((r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })(r));
}, (r => {
  return (r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })((r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })(r));
})(1)) : ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(1 / 2, r => {
  return (r => {
    return (r => {
      return (x => {
        return x + 1;
      })((x => {
        return x + 1;
      })(r));
    })((r => {
      return (x => {
        return x + 1;
      })((x => {
        return x + 1;
      })(r));
    })(r));
  })((r => {
    return (r => {
      return (x => {
        return x + 1;
      })((x => {
        return x + 1;
      })(r));
    })((r => {
      return (x => {
        return x + 1;
      })((x => {
        return x + 1;
      })(r));
    })(r));
  })(r));
}, 1) returned

1 === 0 ? 1 : 1 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 / 2, r => { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r));}, 1);
[afterMarker] 1 === 0 ? 1 : 1 % 2 !== 0 ? ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(1 - 1, r => {
  return (r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })((r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })(r));
}, (r => {
  return (r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })((r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })(r));
})(1)) : ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(1 / 2, r => {
  return (r => {
    return (r => {
      return (x => {
        return x + 1;
      })((x => {
        return x + 1;
      })(r));
    })((r => {
      return (x => {
        return x + 1;
      })((x => {
        return x + 1;
      })(r));
    })(r));
  })((r => {
    return (r => {
      return (x => {
        return x + 1;
      })((x => {
        return x + 1;
      })(r));
    })((r => {
      return (x => {
        return x + 1;
      })((x => {
        return x + 1;
      })(r));
    })(r));
  })(r));
}, 1) returned

1 === 0 ? 1 : 1 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 / 2, r => { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r));}, 1);
[beforeMarker] Binary expression 1 === 0 evaluated

false ? 1 : 1 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 / 2, r => { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r));}, 1);
[afterMarker] Binary expression 1 === 0 evaluated

false ? 1 : 1 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 / 2, r => { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r));}, 1);
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

1 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 / 2, r => { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r));}, 1);
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

1 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 / 2, r => { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r));}, 1);
[beforeMarker] Binary expression 1 % 2 evaluated

1 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 / 2, r => { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r));}, 1);
[afterMarker] Binary expression 1 % 2 evaluated

1 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 / 2, r => { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r));}, 1);
[beforeMarker] Binary expression 1 !== 0 evaluated

true ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 / 2, r => { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r));}, 1);
[afterMarker] Binary expression 1 !== 0 evaluated

true ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));})(1)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 / 2, r => { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r));}, 1);
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));})(1));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(1 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));})(1));
[beforeMarker] Binary expression 1 - 1 evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));})(1));
[afterMarker] Binary expression 1 - 1 evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));})(1));
[beforeMarker] Function twice_p takes in 1 as input r

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})((r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})(1)));
[afterMarker] Function twice_p takes in 1 as input r

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})((r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})(1)));
[beforeMarker] Function twice_p takes in 1 as input r

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})((x => { return x + 1;})((x => { return x + 1;})(1))));
[afterMarker] Function twice_p takes in 1 as input r

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})((x => { return x + 1;})((x => { return x + 1;})(1))));
[beforeMarker] Function plus_one takes in 1 as input x

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})((x => { return x + 1;})(1 + 1)));
[afterMarker] Function plus_one takes in 1 as input x

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})((x => { return x + 1;})(1 + 1)));
[beforeMarker] Binary expression 1 + 1 evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})((x => { return x + 1;})(2)));
[afterMarker] Binary expression 1 + 1 evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})((x => { return x + 1;})(2)));
[beforeMarker] Function plus_one takes in 2 as input x

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})(2 + 1));
[afterMarker] Function plus_one takes in 2 as input x

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})(2 + 1));
[beforeMarker] Binary expression 2 + 1 evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})(3));
[afterMarker] Binary expression 2 + 1 evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (x => { return x + 1; })((x => { return x + 1; })(r));})(3));
[beforeMarker] Function twice_p takes in 3 as input r

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (x => { return x + 1;})((x => { return x + 1;})(3)));
[afterMarker] Function twice_p takes in 3 as input r

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (x => { return x + 1;})((x => { return x + 1;})(3)));
[beforeMarker] Function plus_one takes in 3 as input x

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (x => { return x + 1;})(3 + 1));
[afterMarker] Function plus_one takes in 3 as input x

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (x => { return x + 1;})(3 + 1));
[beforeMarker] Binary expression 3 + 1 evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (x => { return x + 1;})(4));
[afterMarker] Binary expression 3 + 1 evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (x => { return x + 1;})(4));
[beforeMarker] Function plus_one takes in 4 as input x

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, 4 + 1);
[afterMarker] Function plus_one takes in 4 as input x

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, 4 + 1);
[beforeMarker] Binary expression 4 + 1 evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, 5);
[afterMarker] Binary expression 4 + 1 evaluated

((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, 5);
[beforeMarker] Function repeat_pattern takes in 0, twice_p, 5 as input n, p, r

{ function twice_p(r) { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r)); } return 0 === 0 ? 5 : 0 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(0 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); }, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(5)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(0 / 2, twice_p, 5);};
[afterMarker] Function repeat_pattern takes in 0, twice_p, 5 as input n, p, r

{ function twice_p(r) { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r)); } return 0 === 0 ? 5 : 0 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(0 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); }, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(5)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(0 / 2, twice_p, 5);};
[beforeMarker] Function twice_p declared, parameter(s) r required

{ return 0 === 0 ? 5 : 0 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(0 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); }, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(5)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(0 / 2, r => { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r)); }, 5);};
[afterMarker] Function twice_p declared, parameter(s) r required

{ return 0 === 0 ? 5 : 0 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(0 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); }, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(5)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r); })(0 / 2, r => { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r)); }, 5);};
[beforeMarker] 0 === 0 ? 5 : 0 % 2 !== 0 ? ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(0 - 1, r => {
  return (r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })((r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })(r));
}, (r => {
  return (r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })((r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })(r));
})(5)) : ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(0 / 2, r => {
  return (r => {
    return (r => {
      return (x => {
        return x + 1;
      })((x => {
        return x + 1;
      })(r));
    })((r => {
      return (x => {
        return x + 1;
      })((x => {
        return x + 1;
      })(r));
    })(r));
  })((r => {
    return (r => {
      return (x => {
        return x + 1;
      })((x => {
        return x + 1;
      })(r));
    })((r => {
      return (x => {
        return x + 1;
      })((x => {
        return x + 1;
      })(r));
    })(r));
  })(r));
}, 5) returned

0 === 0 ? 5 : 0 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));})(5)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0 / 2, r => { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r));}, 5);
[afterMarker] 0 === 0 ? 5 : 0 % 2 !== 0 ? ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(0 - 1, r => {
  return (r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })((r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })(r));
}, (r => {
  return (r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })((r => {
    return (x => {
      return x + 1;
    })((x => {
      return x + 1;
    })(r));
  })(r));
})(5)) : ((n, p, r) => {
  function twice_p(r) {
    return p(p(r));
  }
  return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);
})(0 / 2, r => {
  return (r => {
    return (r => {
      return (x => {
        return x + 1;
      })((x => {
        return x + 1;
      })(r));
    })((r => {
      return (x => {
        return x + 1;
      })((x => {
        return x + 1;
      })(r));
    })(r));
  })((r => {
    return (r => {
      return (x => {
        return x + 1;
      })((x => {
        return x + 1;
      })(r));
    })((r => {
      return (x => {
        return x + 1;
      })((x => {
        return x + 1;
      })(r));
    })(r));
  })(r));
}, 5) returned

0 === 0 ? 5 : 0 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));})(5)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0 / 2, r => { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r));}, 5);
[beforeMarker] Binary expression 0 === 0 evaluated

true ? 5 : 0 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));})(5)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0 / 2, r => { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r));}, 5);
[afterMarker] Binary expression 0 === 0 evaluated

true ? 5 : 0 % 2 !== 0 ? ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0 - 1, r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));}, (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r));})(5)) : ((n, p, r) => { function twice_p(r) { return p(p(r)); } return n === 0 ? r : n % 2 !== 0 ? repeat_pattern(n - 1, p, p(r)) : repeat_pattern(n / 2, twice_p, r);})(0 / 2, r => { return (r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })((r => { return (r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })((r => { return (x => { return x + 1; })((x => { return x + 1; })(r)); })(r)); })(r));}, 5);
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

5;
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

5;
[noMarker] Evaluation complete
"
`;

exports[`return in nested blocks 1`] = `
"function f(x) { { return 1; }}f(0);
[noMarker] Start of evaluation

function f(x) { { return 1; }}f(0);
[beforeMarker] Function f declared, parameter(s) x required

(x => { { return 1; }})(0);
[afterMarker] Function f declared, parameter(s) x required

(x => { { return 1; }})(0);
[beforeMarker] Function f takes in 0 as input x

{ { return 1; }};
[afterMarker] Function f takes in 0 as input x

{ { return 1; }};
[beforeMarker] return 1; finished evaluating

{ return 1;};
[afterMarker] return 1; finished evaluating

{ return 1;};
[beforeMarker] 1 returned

1;
[afterMarker] 1 returned

1;
[noMarker] Evaluation complete
"
`;

exports[`scoping test for block expressions 1`] = `
"function f(x) { const y = x; return g();}function g() { return y;}const y = 1;f(0);
[noMarker] Start of evaluation

function f(x) { const y = x; return g();}function g() { return y;}const y = 1;f(0);
[beforeMarker] Function f declared, parameter(s) x required

function g() { return y;}const y = 1;(x => { const y = x; return g();})(0);
[afterMarker] Function f declared, parameter(s) x required

function g() { return y;}const y = 1;(x => { const y = x; return g();})(0);
[beforeMarker] Function g declared, parameter(s)  required

const y = 1;(x => { const y_1 = x; return (() => { return y; })();})(0);
[afterMarker] Function g declared, parameter(s)  required

const y = 1;(x => { const y_1 = x; return (() => { return y; })();})(0);
[beforeMarker] Constant y declared and substituted into the rest of block

(x => { const y_1 = x; return (() => { return 1; })();})(0);
[afterMarker] Constant y declared and substituted into the rest of block

(x => { const y_1 = x; return (() => { return 1; })();})(0);
[beforeMarker] Function f takes in 0 as input x

{ const y_1 = 0; return (() => { return 1; })();};
[afterMarker] Function f takes in 0 as input x

{ const y_1 = 0; return (() => { return 1; })();};
[beforeMarker] Constant y_1 declared and substituted into the rest of block

{ return (() => { return 1; })();};
[afterMarker] Constant y_1 declared and substituted into the rest of block

{ return (() => { return 1; })();};
[beforeMarker] (() => {
  return 1;
})() returned

(() => { return 1;})();
[afterMarker] (() => {
  return 1;
})() returned

(() => { return 1;})();
[beforeMarker] () => {...} runs

1;
[afterMarker] () => {...} runs

1;
[noMarker] Evaluation complete
"
`;

exports[`scoping test for block expressions, no renaming 1`] = `
"function h(w) { function f(w) { return g(); } function g() { return w; } return f(0);}h(1);
[noMarker] Start of evaluation

function h(w) { function f(w) { return g(); } function g() { return w; } return f(0);}h(1);
[beforeMarker] Function h declared, parameter(s) w required

(w => { function f(w) { return g(); } function g() { return w; } return f(0);})(1);
[afterMarker] Function h declared, parameter(s) w required

(w => { function f(w) { return g(); } function g() { return w; } return f(0);})(1);
[beforeMarker] Function h takes in 1 as input w

{ function f(w) { return g(); } function g() { return 1; } return f(0);};
[afterMarker] Function h takes in 1 as input w

{ function f(w) { return g(); } function g() { return 1; } return f(0);};
[beforeMarker] Function f declared, parameter(s) w required

{ function g() { return 1; } return (w => { return g(); })(0);};
[afterMarker] Function f declared, parameter(s) w required

{ function g() { return 1; } return (w => { return g(); })(0);};
[beforeMarker] Function g declared, parameter(s)  required

{ return (w => { return (() => { return 1; })(); })(0);};
[afterMarker] Function g declared, parameter(s)  required

{ return (w => { return (() => { return 1; })(); })(0);};
[beforeMarker] (w => {
  return (() => {
    return 1;
  })();
})(0) returned

(w => { return (() => { return 1; })();})(0);
[afterMarker] (w => {
  return (() => {
    return 1;
  })();
})(0) returned

(w => { return (() => { return 1; })();})(0);
[beforeMarker] Function f takes in 0 as input w

(() => { return 1;})();
[afterMarker] Function f takes in 0 as input w

(() => { return 1;})();
[beforeMarker] () => {...} runs

1;
[afterMarker] () => {...} runs

1;
[noMarker] Evaluation complete
"
`;

exports[`scoping test for blocks nested in lambda expressions 1`] = `
"const f = x => { g();};const g = () => { x;};const x = 1;f(0);
[noMarker] Start of evaluation

const f = x => { g();};const g = () => { x;};const x = 1;f(0);
[beforeMarker] Constant f declared and substituted into the rest of block

const g = () => { x;};const x = 1;(x => { g();})(0);
[afterMarker] Constant f declared and substituted into the rest of block

const g = () => { x;};const x = 1;(x => { g();})(0);
[beforeMarker] Constant g declared and substituted into the rest of block

const x = 1;(x_1 => { (() => { x; })();})(0);
[afterMarker] Constant g declared and substituted into the rest of block

const x = 1;(x_1 => { (() => { x; })();})(0);
[beforeMarker] Constant x declared and substituted into the rest of block

(x_1 => { (() => { 1; })();})(0);
[afterMarker] Constant x declared and substituted into the rest of block

(x_1 => { (() => { 1; })();})(0);
[beforeMarker] Function f takes in 0 as input x_1

{ (() => { 1; })();};
[afterMarker] Function f takes in 0 as input x_1

{ (() => { 1; })();};
[beforeMarker] () => {...} runs

{ { 1; };};
[afterMarker] () => {...} runs

{ { 1; };};
[beforeMarker] 1; finished evaluating

{ undefined;};
[afterMarker] 1; finished evaluating

{ undefined;};
[beforeMarker] undefined; finished evaluating

undefined;
[afterMarker] undefined; finished evaluating

undefined;
[noMarker] Evaluation complete
"
`;

exports[`scoping test for function expressions 1`] = `
"function f(x) { return g();}function g() { return x;}const x = 1;f(0);
[noMarker] Start of evaluation

function f(x) { return g();}function g() { return x;}const x = 1;f(0);
[beforeMarker] Function f declared, parameter(s) x required

function g() { return x;}const x = 1;(x => { return g();})(0);
[afterMarker] Function f declared, parameter(s) x required

function g() { return x;}const x = 1;(x => { return g();})(0);
[beforeMarker] Function g declared, parameter(s)  required

const x = 1;(x_1 => { return (() => { return x; })();})(0);
[afterMarker] Function g declared, parameter(s)  required

const x = 1;(x_1 => { return (() => { return x; })();})(0);
[beforeMarker] Constant x declared and substituted into the rest of block

(x_1 => { return (() => { return 1; })();})(0);
[afterMarker] Constant x declared and substituted into the rest of block

(x_1 => { return (() => { return 1; })();})(0);
[beforeMarker] Function f takes in 0 as input x_1

(() => { return 1;})();
[afterMarker] Function f takes in 0 as input x_1

(() => { return 1;})();
[beforeMarker] () => {...} runs

1;
[afterMarker] () => {...} runs

1;
[noMarker] Evaluation complete
"
`;

exports[`scoping test for lambda expressions 1`] = `
"const f = x => g();const g = () => x;const x = 1;f(0);
[noMarker] Start of evaluation

const f = x => g();const g = () => x;const x = 1;f(0);
[beforeMarker] Constant f declared and substituted into the rest of block

const g = () => x;const x = 1;(x => g())(0);
[afterMarker] Constant f declared and substituted into the rest of block

const g = () => x;const x = 1;(x => g())(0);
[beforeMarker] Constant g declared and substituted into the rest of block

const x = 1;(x_1 => (() => x)())(0);
[afterMarker] Constant g declared and substituted into the rest of block

const x = 1;(x_1 => (() => x)())(0);
[beforeMarker] Constant x declared and substituted into the rest of block

(x_1 => (() => 1)())(0);
[afterMarker] Constant x declared and substituted into the rest of block

(x_1 => (() => 1)())(0);
[beforeMarker] 0 substituted into x_1 of x_1 => (() => 1)()

(() => 1)();
[afterMarker] 0 substituted into x_1 of x_1 => (() => 1)()

(() => 1)();
[beforeMarker] () => 1 runs

1;
[afterMarker] () => 1 runs

1;
[noMarker] Evaluation complete
"
`;

exports[`scoping test for lambda expressions nested in blocks 1`] = `
"{ const f = x => g(); const g = () => x; const x = 1; f(0);}
[noMarker] Start of evaluation

{ const f = x => g(); const g = () => x; const x = 1; f(0);}
[beforeMarker] Constant f declared and substituted into the rest of block

{ const g = () => x; const x = 1; (x => g())(0);}
[afterMarker] Constant f declared and substituted into the rest of block

{ const g = () => x; const x = 1; (x => g())(0);}
[beforeMarker] Constant g declared and substituted into the rest of block

{ const x = 1; (x_1 => (() => x)())(0);}
[afterMarker] Constant g declared and substituted into the rest of block

{ const x = 1; (x_1 => (() => x)())(0);}
[beforeMarker] Constant x declared and substituted into the rest of block

{ (x_1 => (() => 1)())(0);}
[afterMarker] Constant x declared and substituted into the rest of block

{ (x_1 => (() => 1)())(0);}
[beforeMarker] 0 substituted into x_1 of x_1 => (() => 1)()

{ (() => 1)();}
[afterMarker] 0 substituted into x_1 of x_1 => (() => 1)()

{ (() => 1)();}
[beforeMarker] () => 1 runs

{ 1;}
[afterMarker] () => 1 runs

{ 1;}
[beforeMarker] 1; finished evaluating

1;
[afterMarker] 1; finished evaluating

1;
[noMarker] Evaluation complete
"
`;

exports[`steps appear as if capturing happens #1714 1`] = `
"function h(f, x) { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1);}h(h, 5);
[noMarker] Start of evaluation

function h(f, x) { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1);}h(h, 5);
[beforeMarker] Function h declared, parameter(s) f,x required

((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1);})((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1);}, 5);
[afterMarker] Function h declared, parameter(s) f,x required

((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1);})((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1);}, 5);
[beforeMarker] Function h takes in h, 5 as input f, x

{ function h(g, x) { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); } return 5 <= 1 ? 1 : 2 * ((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); })(h, 5 - 1);};
[afterMarker] Function h takes in h, 5 as input f, x

{ function h(g, x) { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); } return 5 <= 1 ? 1 : 2 * ((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); })(h, 5 - 1);};
[beforeMarker] Function h declared, parameter(s) g,x required

{ return 5 <= 1 ? 1 : 2 * ((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); })((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); }, 5 - 1);};
[afterMarker] Function h declared, parameter(s) g,x required

{ return 5 <= 1 ? 1 : 2 * ((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); })((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); }, 5 - 1);};
[beforeMarker] 5 <= 1 ? 1 : 2 * ((f, x) => {
  function h(g, x) {
    return x <= 1 ? 1 : 3 * g(f, x - 1);
  }
  return x <= 1 ? 1 : 2 * f(h, x - 1);
})((g, x) => {
  return x <= 1 ? 1 : 3 * g((f, x) => {
    function h(g, x) {
      return x <= 1 ? 1 : 3 * g(f, x - 1);
    }
    return x <= 1 ? 1 : 2 * f(h, x - 1);
  }, x - 1);
}, 5 - 1) returned

5 <= 1 ? 1 : 2 * ((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1);}, 5 - 1);
[afterMarker] 5 <= 1 ? 1 : 2 * ((f, x) => {
  function h(g, x) {
    return x <= 1 ? 1 : 3 * g(f, x - 1);
  }
  return x <= 1 ? 1 : 2 * f(h, x - 1);
})((g, x) => {
  return x <= 1 ? 1 : 3 * g((f, x) => {
    function h(g, x) {
      return x <= 1 ? 1 : 3 * g(f, x - 1);
    }
    return x <= 1 ? 1 : 2 * f(h, x - 1);
  }, x - 1);
}, 5 - 1) returned

5 <= 1 ? 1 : 2 * ((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1);}, 5 - 1);
[beforeMarker] Binary expression 5 <= 1 evaluated

false ? 1 : 2 * ((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1);}, 5 - 1);
[afterMarker] Binary expression 5 <= 1 evaluated

false ? 1 : 2 * ((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1);}, 5 - 1);
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

2 * ((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1);}, 5 - 1);
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

2 * ((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1);}, 5 - 1);
[beforeMarker] Binary expression 5 - 1 evaluated

2 * ((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1);}, 4);
[afterMarker] Binary expression 5 - 1 evaluated

2 * ((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1);}, 4);
[beforeMarker] Function h takes in h, 4 as input f, x

2 * { function h(g, x) { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); }, x - 1); } return 4 <= 1 ? 1 : 2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); })(h, 4 - 1);};
[afterMarker] Function h takes in h, 4 as input f, x

2 * { function h(g, x) { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); }, x - 1); } return 4 <= 1 ? 1 : 2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); })(h, 4 - 1);};
[beforeMarker] Function h declared, parameter(s) g,x required

2 * { return 4 <= 1 ? 1 : 2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); })((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); }, x - 1); }, 4 - 1);};
[afterMarker] Function h declared, parameter(s) g,x required

2 * { return 4 <= 1 ? 1 : 2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); })((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); }, x - 1); }, 4 - 1);};
[beforeMarker] 4 <= 1 ? 1 : 2 * ((g, x) => {
  return x <= 1 ? 1 : 3 * g((f, x) => {
    function h(g, x) {
      return x <= 1 ? 1 : 3 * g(f, x - 1);
    }
    return x <= 1 ? 1 : 2 * f(h, x - 1);
  }, x - 1);
})((g, x) => {
  return x <= 1 ? 1 : 3 * g((g, x) => {
    return x <= 1 ? 1 : 3 * g((f, x) => {
      function h(g, x) {
        return x <= 1 ? 1 : 3 * g(f, x - 1);
      }
      return x <= 1 ? 1 : 2 * f(h, x - 1);
    }, x - 1);
  }, x - 1);
}, 4 - 1) returned

2 * (4 <= 1 ? 1 : 2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); }, x - 1);}, 4 - 1));
[afterMarker] 4 <= 1 ? 1 : 2 * ((g, x) => {
  return x <= 1 ? 1 : 3 * g((f, x) => {
    function h(g, x) {
      return x <= 1 ? 1 : 3 * g(f, x - 1);
    }
    return x <= 1 ? 1 : 2 * f(h, x - 1);
  }, x - 1);
})((g, x) => {
  return x <= 1 ? 1 : 3 * g((g, x) => {
    return x <= 1 ? 1 : 3 * g((f, x) => {
      function h(g, x) {
        return x <= 1 ? 1 : 3 * g(f, x - 1);
      }
      return x <= 1 ? 1 : 2 * f(h, x - 1);
    }, x - 1);
  }, x - 1);
}, 4 - 1) returned

2 * (4 <= 1 ? 1 : 2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); }, x - 1);}, 4 - 1));
[beforeMarker] Binary expression 4 <= 1 evaluated

2 * (false ? 1 : 2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); }, x - 1);}, 4 - 1));
[afterMarker] Binary expression 4 <= 1 evaluated

2 * (false ? 1 : 2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); }, x - 1);}, 4 - 1));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

2 * (2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); }, x - 1);}, 4 - 1));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

2 * (2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); }, x - 1);}, 4 - 1));
[beforeMarker] Binary expression 4 - 1 evaluated

2 * (2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); }, x - 1);}, 3));
[afterMarker] Binary expression 4 - 1 evaluated

2 * (2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); }, x - 1);}, 3));
[beforeMarker] Function h takes in h, 3 as input g, x

2 * (2 * (3 <= 1 ? 1 : 3 * ((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); }, x - 1);})((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1);}, 3 - 1)));
[afterMarker] Function h takes in h, 3 as input g, x

2 * (2 * (3 <= 1 ? 1 : 3 * ((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); }, x - 1);})((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1);}, 3 - 1)));
[beforeMarker] Binary expression 3 <= 1 evaluated

2 * (2 * (false ? 1 : 3 * ((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); }, x - 1);})((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1);}, 3 - 1)));
[afterMarker] Binary expression 3 <= 1 evaluated

2 * (2 * (false ? 1 : 3 * ((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); }, x - 1);})((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1);}, 3 - 1)));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

2 * (2 * (3 * ((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); }, x - 1);})((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1);}, 3 - 1)));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

2 * (2 * (3 * ((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); }, x - 1);})((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1);}, 3 - 1)));
[beforeMarker] Binary expression 3 - 1 evaluated

2 * (2 * (3 * ((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); }, x - 1);})((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1);}, 2)));
[afterMarker] Binary expression 3 - 1 evaluated

2 * (2 * (3 * ((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); }, x - 1);})((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1);}, 2)));
[beforeMarker] Function h takes in h, 2 as input g, x

2 * (2 * (3 * (2 <= 1 ? 1 : 3 * ((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1);}, 2 - 1))));
[afterMarker] Function h takes in h, 2 as input g, x

2 * (2 * (3 * (2 <= 1 ? 1 : 3 * ((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1);}, 2 - 1))));
[beforeMarker] Binary expression 2 <= 1 evaluated

2 * (2 * (3 * (false ? 1 : 3 * ((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1);}, 2 - 1))));
[afterMarker] Binary expression 2 <= 1 evaluated

2 * (2 * (3 * (false ? 1 : 3 * ((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1);}, 2 - 1))));
[beforeMarker] Conditional expression evaluated, condition is false, alternate evaluated

2 * (2 * (3 * (3 * ((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1);}, 2 - 1))));
[afterMarker] Conditional expression evaluated, condition is false, alternate evaluated

2 * (2 * (3 * (3 * ((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1);}, 2 - 1))));
[beforeMarker] Binary expression 2 - 1 evaluated

2 * (2 * (3 * (3 * ((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1);}, 1))));
[afterMarker] Binary expression 2 - 1 evaluated

2 * (2 * (3 * (3 * ((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1);}, 1))));
[beforeMarker] Function h takes in h, 1 as input f, x

2 * (2 * (3 * (3 * { function h(g, x) { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); }, x - 1); } return 1 <= 1 ? 1 : 2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); })(h, 1 - 1);})));
[afterMarker] Function h takes in h, 1 as input f, x

2 * (2 * (3 * (3 * { function h(g, x) { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); }, x - 1); } return 1 <= 1 ? 1 : 2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); })(h, 1 - 1);})));
[beforeMarker] Function h declared, parameter(s) g,x required

2 * (2 * (3 * (3 * { return 1 <= 1 ? 1 : 2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); })((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); }, x - 1); }, 1 - 1);})));
[afterMarker] Function h declared, parameter(s) g,x required

2 * (2 * (3 * (3 * { return 1 <= 1 ? 1 : 2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); })((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); }, x - 1); }, 1 - 1);})));
[beforeMarker] 1 <= 1 ? 1 : 2 * ((g, x) => {
  return x <= 1 ? 1 : 3 * g((f, x) => {
    function h(g, x) {
      return x <= 1 ? 1 : 3 * g(f, x - 1);
    }
    return x <= 1 ? 1 : 2 * f(h, x - 1);
  }, x - 1);
})((g, x) => {
  return x <= 1 ? 1 : 3 * g((g, x) => {
    return x <= 1 ? 1 : 3 * g((f, x) => {
      function h(g, x) {
        return x <= 1 ? 1 : 3 * g(f, x - 1);
      }
      return x <= 1 ? 1 : 2 * f(h, x - 1);
    }, x - 1);
  }, x - 1);
}, 1 - 1) returned

2 * (2 * (3 * (3 * (1 <= 1 ? 1 : 2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); }, x - 1);}, 1 - 1)))));
[afterMarker] 1 <= 1 ? 1 : 2 * ((g, x) => {
  return x <= 1 ? 1 : 3 * g((f, x) => {
    function h(g, x) {
      return x <= 1 ? 1 : 3 * g(f, x - 1);
    }
    return x <= 1 ? 1 : 2 * f(h, x - 1);
  }, x - 1);
})((g, x) => {
  return x <= 1 ? 1 : 3 * g((g, x) => {
    return x <= 1 ? 1 : 3 * g((f, x) => {
      function h(g, x) {
        return x <= 1 ? 1 : 3 * g(f, x - 1);
      }
      return x <= 1 ? 1 : 2 * f(h, x - 1);
    }, x - 1);
  }, x - 1);
}, 1 - 1) returned

2 * (2 * (3 * (3 * (1 <= 1 ? 1 : 2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); }, x - 1);}, 1 - 1)))));
[beforeMarker] Binary expression 1 <= 1 evaluated

2 * (2 * (3 * (3 * (true ? 1 : 2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); }, x - 1);}, 1 - 1)))));
[afterMarker] Binary expression 1 <= 1 evaluated

2 * (2 * (3 * (3 * (true ? 1 : 2 * ((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1);})((g, x) => { return x <= 1 ? 1 : 3 * g((g, x) => { return x <= 1 ? 1 : 3 * g((f, x) => { function h(g, x) { return x <= 1 ? 1 : 3 * g(f, x - 1); } return x <= 1 ? 1 : 2 * f(h, x - 1); }, x - 1); }, x - 1);}, 1 - 1)))));
[beforeMarker] Conditional expression evaluated, condition is true, consequent evaluated

2 * (2 * (3 * (3 * 1)));
[afterMarker] Conditional expression evaluated, condition is true, consequent evaluated

2 * (2 * (3 * (3 * 1)));
[beforeMarker] Binary expression 3 * 1 evaluated

2 * (2 * (3 * 3));
[afterMarker] Binary expression 3 * 1 evaluated

2 * (2 * (3 * 3));
[beforeMarker] Binary expression 3 * 3 evaluated

2 * (2 * 9);
[afterMarker] Binary expression 3 * 3 evaluated

2 * (2 * 9);
[beforeMarker] Binary expression 2 * 9 evaluated

2 * 18;
[afterMarker] Binary expression 2 * 9 evaluated

2 * 18;
[beforeMarker] Binary expression 2 * 18 evaluated

36;
[afterMarker] Binary expression 2 * 18 evaluated

36;
[noMarker] Evaluation complete
"
`;

exports[`triple equals work on function 1`] = `
"function f() { return g();}function g() { return f();}f === f;g === g;f === g;
[noMarker] Start of evaluation

function f() { return g();}function g() { return f();}f === f;g === g;f === g;
[beforeMarker] Function f declared, parameter(s)  required

function g() { return (() => { return g(); })();}(() => { return g();}) === (() => { return g();});g === g;(() => { return g();}) === g;
[afterMarker] Function f declared, parameter(s)  required

function g() { return (() => { return g(); })();}(() => { return g();}) === (() => { return g();});g === g;(() => { return g();}) === g;
[beforeMarker] Function g declared, parameter(s)  required

(() => { return (() => { return (() => { return g(); })(); })();}) === (() => { return (() => { return (() => { return g(); })(); })();});(() => { return (() => { return g(); })();}) === (() => { return (() => { return g(); })();});(() => { return (() => { return (() => { return g(); })(); })();}) === (() => { return (() => { return g(); })();});
[afterMarker] Function g declared, parameter(s)  required

(() => { return (() => { return (() => { return g(); })(); })();}) === (() => { return (() => { return (() => { return g(); })(); })();});(() => { return (() => { return g(); })();}) === (() => { return (() => { return g(); })();});(() => { return (() => { return (() => { return g(); })(); })();}) === (() => { return (() => { return g(); })();});
[beforeMarker] (() => {
  return (() => {
    return (() => {
      return g();
    })();
  })();
}) === (() => {
  return (() => {
    return (() => {
      return g();
    })();
  })();
}) finished evaluating

(() => { return (() => { return g(); })();}) === (() => { return (() => { return g(); })();});(() => { return (() => { return (() => { return g(); })(); })();}) === (() => { return (() => { return g(); })();});
[afterMarker] (() => {
  return (() => {
    return (() => {
      return g();
    })();
  })();
}) === (() => {
  return (() => {
    return (() => {
      return g();
    })();
  })();
}) finished evaluating

(() => { return (() => { return g(); })();}) === (() => { return (() => { return g(); })();});(() => { return (() => { return (() => { return g(); })(); })();}) === (() => { return (() => { return g(); })();});
[beforeMarker] (() => {
  return (() => {
    return g();
  })();
}) === (() => {
  return (() => {
    return g();
  })();
}) finished evaluating

(() => { return (() => { return (() => { return g(); })(); })();}) === (() => { return (() => { return g(); })();});
[afterMarker] (() => {
  return (() => {
    return g();
  })();
}) === (() => {
  return (() => {
    return g();
  })();
}) finished evaluating

(() => { return (() => { return (() => { return g(); })(); })();}) === (() => { return (() => { return g(); })();});
[noMarker] Evaluation complete
"
`;

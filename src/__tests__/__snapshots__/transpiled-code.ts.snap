// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Empty code returns empty string 1`] = `
Object {
  "code": "",
  "transpiled": "",
}
`;

exports[`Ensure return values are of the form {isTail...} after function declarations are transformed 1`] = `
Object {
  "code": "function f() {
  return null;
}",
  "transpiled": "const native = $$NATIVE_STORAGE;
const boolOrErr = native.operators.get(\\"itselfIfBooleanElseError\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFunctionAndRightArgumentsElseError\\");
const wrap = native.properTailCalls.wrap;
(( <globals redacted> ) => {
  return (() => {
    const f = wrap(() => {
      return {
        isTail: false,
        value: null
      };
    });
    native.globals.set(\\"f\\", {
      kind: \\"const\\",
      value: f
    });
    return undefined;
  })();
})();
",
}
`;

exports[`For condition is wrapped to expect boolean 1`] = `
Object {
  "code": "for(1;1;1){}1;",
  "transpiled": "const native = $$NATIVE_STORAGE;
const boolOrErr = native.operators.get(\\"itselfIfBooleanElseError\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFunctionAndRightArgumentsElseError\\");
const wrap = native.properTailCalls.wrap;
(( <globals redacted> ) => {
  return (() => {
    for (1; 1; 1) {}
    const lastStatementResult = eval(\\"1;\\");
    return lastStatementResult;
  })();
})();
",
}
`;

exports[`Function call gets transformed 1`] = `
Object {
  "code": "runtime(1);1;",
  "transpiled": "const native = $$NATIVE_STORAGE;
const boolOrErr = native.operators.get(\\"itselfIfBooleanElseError\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFunctionAndRightArgumentsElseError\\");
const wrap = native.properTailCalls.wrap;
(( <globals redacted> ) => {
  return (() => {
    callIfFuncAndRightArgs(runtime, 1, 0, 1);
    const lastStatementResult = eval(\\"1;\\");
    return lastStatementResult;
  })();
})();
",
}
`;

exports[`If condition is wrapped to expect boolean 1`] = `
Object {
  "code": "if(true){}else{}1;",
  "transpiled": "const native = $$NATIVE_STORAGE;
const boolOrErr = native.operators.get(\\"itselfIfBooleanElseError\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFunctionAndRightArgumentsElseError\\");
const wrap = native.properTailCalls.wrap;
(( <globals redacted> ) => {
  return (() => {
    if (boolOrErr(true, 1, 0)) {} else {}
    const lastStatementResult = eval(\\"1;\\");
    return lastStatementResult;
  })();
})();
",
}
`;

exports[`Non-function call gets transformed 1`] = `
Object {
  "code": "1(1);1;",
  "transpiled": "const native = $$NATIVE_STORAGE;
const boolOrErr = native.operators.get(\\"itselfIfBooleanElseError\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFunctionAndRightArgumentsElseError\\");
const wrap = native.properTailCalls.wrap;
(( <globals redacted> ) => {
  return (() => {
    callIfFuncAndRightArgs(1, 1, 0, 1);
    const lastStatementResult = eval(\\"1;\\");
    return lastStatementResult;
  })();
})();
",
}
`;

exports[`Non-tailcall block arrow function gets transformed to return {isTail:false...} for PTC 1`] = `
Object {
  "code": "const f = () => {
  return 1;
};",
  "transpiled": "const native = $$NATIVE_STORAGE;
const boolOrErr = native.operators.get(\\"itselfIfBooleanElseError\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFunctionAndRightArgumentsElseError\\");
const wrap = native.properTailCalls.wrap;
(( <globals redacted> ) => {
  return (() => {
    const f = wrap(() => {
      return {
        isTail: false,
        value: 1
      };
    });
    native.globals.set(\\"f\\", {
      kind: \\"const\\",
      value: f
    });
    return undefined;
  })();
})();
",
}
`;

exports[`Single declaration statement does not transform to eval 1`] = `
Object {
  "code": "const a = 1;",
  "transpiled": "const native = $$NATIVE_STORAGE;
const boolOrErr = native.operators.get(\\"itselfIfBooleanElseError\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFunctionAndRightArgumentsElseError\\");
const wrap = native.properTailCalls.wrap;
(( <globals redacted> ) => {
  return (() => {
    const a = 1;
    native.globals.set(\\"a\\", {
      kind: \\"const\\",
      value: a
    });
    return undefined;
  })();
})();
",
}
`;

exports[`Single non-declaration statement transforms to eval 1`] = `
Object {
  "code": "2;",
  "transpiled": "const native = $$NATIVE_STORAGE;
const boolOrErr = native.operators.get(\\"itselfIfBooleanElseError\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFunctionAndRightArgumentsElseError\\");
const wrap = native.properTailCalls.wrap;
(( <globals redacted> ) => {
  return (() => {
    const lastStatementResult = eval(\\"2;\\");
    return lastStatementResult;
  })();
})();
",
}
`;

exports[`Tailcall block arrow function gets transformed to return {isTail:true...} for PTC 1`] = `
Object {
  "code": "const f = () => {
  return f();
};",
  "transpiled": "const native = $$NATIVE_STORAGE;
const boolOrErr = native.operators.get(\\"itselfIfBooleanElseError\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFunctionAndRightArgumentsElseError\\");
const wrap = native.properTailCalls.wrap;
(( <globals redacted> ) => {
  return (() => {
    const f = wrap(() => {
      return {
        isTail: true,
        function: f,
        arguments: [],
        line: 2,
        column: 9
      };
    });
    native.globals.set(\\"f\\", {
      kind: \\"const\\",
      value: f
    });
    return undefined;
  })();
})();
",
}
`;

exports[`Tailcall block arrow function gets transformed to return {isTail:true...} for PTC 2`] = `
Object {
  "code": "const f = () => {
  return f();
};",
  "transpiled": "const native = $$NATIVE_STORAGE;
const boolOrErr = native.operators.get(\\"itselfIfBooleanElseError\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFunctionAndRightArgumentsElseError\\");
const wrap = native.properTailCalls.wrap;
(( <globals redacted> ) => {
  return (() => {
    const f = wrap(() => {
      return {
        isTail: true,
        function: f,
        arguments: [],
        line: 2,
        column: 9
      };
    });
    native.globals.set(\\"f\\", {
      kind: \\"const\\",
      value: f
    });
    return undefined;
  })();
})();
",
}
`;

exports[`While condition is wrapped to expect boolean 1`] = `
Object {
  "code": "while(true){}1;",
  "transpiled": "const native = $$NATIVE_STORAGE;
const boolOrErr = native.operators.get(\\"itselfIfBooleanElseError\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFunctionAndRightArgumentsElseError\\");
const wrap = native.properTailCalls.wrap;
(( <globals redacted> ) => {
  return (() => {
    while (true) {}
    const lastStatementResult = eval(\\"1;\\");
    return lastStatementResult;
  })();
})();
",
}
`;

exports[`block arrow function with && gets transformed to return {isTail:...} for RHS for PTC 1`] = `
Object {
  "code": "const f = () => {
  return true && false;
};",
  "transpiled": "const native = $$NATIVE_STORAGE;
const boolOrErr = native.operators.get(\\"itselfIfBooleanElseError\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFunctionAndRightArgumentsElseError\\");
const wrap = native.properTailCalls.wrap;
(( <globals redacted> ) => {
  return (() => {
    const f = wrap(() => {
      return boolOrErr(true, 2, 9) && ({
        isTail: false,
        value: false
      });
    });
    native.globals.set(\\"f\\", {
      kind: \\"const\\",
      value: f
    });
    return undefined;
  })();
})();
",
}
`;

exports[`block arrow function with ?: gets transformed to return {isTail:...} for consequent and alternate for PTC 1`] = `
Object {
  "code": "const f = () => {
  return true ? true : false;
};",
  "transpiled": "const native = $$NATIVE_STORAGE;
const boolOrErr = native.operators.get(\\"itselfIfBooleanElseError\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFunctionAndRightArgumentsElseError\\");
const wrap = native.properTailCalls.wrap;
(( <globals redacted> ) => {
  return (() => {
    const f = wrap(() => {
      return boolOrErr(true, 2, 9) ? {
        isTail: false,
        value: true
      } : {
        isTail: false,
        value: false
      };
    });
    native.globals.set(\\"f\\", {
      kind: \\"const\\",
      value: f
    });
    return undefined;
  })();
})();
",
}
`;

exports[`block arrow function with || gets transformed to return {isTail:...} for RHS for PTC 1`] = `
Object {
  "code": "const f = () => {
  return true || false;
};",
  "transpiled": "const native = $$NATIVE_STORAGE;
const boolOrErr = native.operators.get(\\"itselfIfBooleanElseError\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFunctionAndRightArgumentsElseError\\");
const wrap = native.properTailCalls.wrap;
(( <globals redacted> ) => {
  return (() => {
    const f = wrap(() => {
      return boolOrErr(true, 2, 9) || ({
        isTail: false,
        value: false
      });
    });
    native.globals.set(\\"f\\", {
      kind: \\"const\\",
      value: f
    });
    return undefined;
  })();
})();
",
}
`;

exports[`block arrow function with if gets transformed to return {isTail:...} for every branch for PTC 1`] = `
Object {
  "code": "const f = () => {
  if (true) {
    return true;
  } else {
    return f();
  }
};",
  "transpiled": "const native = $$NATIVE_STORAGE;
const boolOrErr = native.operators.get(\\"itselfIfBooleanElseError\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFunctionAndRightArgumentsElseError\\");
const wrap = native.properTailCalls.wrap;
(( <globals redacted> ) => {
  return (() => {
    const f = wrap(() => {
      if (boolOrErr(true, 2, 2)) {
        return {
          isTail: false,
          value: true
        };
      } else {
        return {
          isTail: true,
          function: f,
          arguments: [],
          line: 5,
          column: 11
        };
      }
    });
    native.globals.set(\\"f\\", {
      kind: \\"const\\",
      value: f
    });
    return undefined;
  })();
})();
",
}
`;

exports[`builtins do get prepended 1`] = `
Object {
  "code": "ensure_builtins;",
  "transpiled": "const native = $$NATIVE_STORAGE;
const boolOrErr = native.operators.get(\\"itselfIfBooleanElseError\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFunctionAndRightArgumentsElseError\\");
const wrap = native.properTailCalls.wrap;
(( <globals redacted> ) => {
  return (() => {
    const runtime = native.builtins.get(\\"runtime\\");
    const display = native.builtins.get(\\"display\\");
    const raw_display = native.builtins.get(\\"raw_display\\");
    const stringify = native.builtins.get(\\"stringify\\");
    const error = native.builtins.get(\\"error\\");
    const prompt = native.builtins.get(\\"prompt\\");
    const is_number = native.builtins.get(\\"is_number\\");
    const is_string = native.builtins.get(\\"is_string\\");
    const is_function = native.builtins.get(\\"is_function\\");
    const is_boolean = native.builtins.get(\\"is_boolean\\");
    const is_undefined = native.builtins.get(\\"is_undefined\\");
    const parse_int = native.builtins.get(\\"parse_int\\");
    const undefined = native.builtins.get(\\"undefined\\");
    const NaN = native.builtins.get(\\"NaN\\");
    const Infinity = native.builtins.get(\\"Infinity\\");
    const math_abs = native.builtins.get(\\"math_abs\\");
    const math_acos = native.builtins.get(\\"math_acos\\");
    const math_acosh = native.builtins.get(\\"math_acosh\\");
    const math_asin = native.builtins.get(\\"math_asin\\");
    const math_asinh = native.builtins.get(\\"math_asinh\\");
    const math_atan = native.builtins.get(\\"math_atan\\");
    const math_atanh = native.builtins.get(\\"math_atanh\\");
    const math_atan2 = native.builtins.get(\\"math_atan2\\");
    const math_ceil = native.builtins.get(\\"math_ceil\\");
    const math_cbrt = native.builtins.get(\\"math_cbrt\\");
    const math_expm1 = native.builtins.get(\\"math_expm1\\");
    const math_clz32 = native.builtins.get(\\"math_clz32\\");
    const math_cos = native.builtins.get(\\"math_cos\\");
    const math_cosh = native.builtins.get(\\"math_cosh\\");
    const math_exp = native.builtins.get(\\"math_exp\\");
    const math_floor = native.builtins.get(\\"math_floor\\");
    const math_fround = native.builtins.get(\\"math_fround\\");
    const math_hypot = native.builtins.get(\\"math_hypot\\");
    const math_imul = native.builtins.get(\\"math_imul\\");
    const math_log = native.builtins.get(\\"math_log\\");
    const math_log1p = native.builtins.get(\\"math_log1p\\");
    const math_log2 = native.builtins.get(\\"math_log2\\");
    const math_log10 = native.builtins.get(\\"math_log10\\");
    const math_max = native.builtins.get(\\"math_max\\");
    const math_min = native.builtins.get(\\"math_min\\");
    const math_pow = native.builtins.get(\\"math_pow\\");
    const math_random = native.builtins.get(\\"math_random\\");
    const math_round = native.builtins.get(\\"math_round\\");
    const math_sign = native.builtins.get(\\"math_sign\\");
    const math_sin = native.builtins.get(\\"math_sin\\");
    const math_sinh = native.builtins.get(\\"math_sinh\\");
    const math_sqrt = native.builtins.get(\\"math_sqrt\\");
    const math_tan = native.builtins.get(\\"math_tan\\");
    const math_tanh = native.builtins.get(\\"math_tanh\\");
    const math_trunc = native.builtins.get(\\"math_trunc\\");
    const math_E = native.builtins.get(\\"math_E\\");
    const math_LN10 = native.builtins.get(\\"math_LN10\\");
    const math_LN2 = native.builtins.get(\\"math_LN2\\");
    const math_LOG10E = native.builtins.get(\\"math_LOG10E\\");
    const math_LOG2E = native.builtins.get(\\"math_LOG2E\\");
    const math_PI = native.builtins.get(\\"math_PI\\");
    const math_SQRT1_2 = native.builtins.get(\\"math_SQRT1_2\\");
    const math_SQRT2 = native.builtins.get(\\"math_SQRT2\\");
    const pair = native.builtins.get(\\"pair\\");
    const is_pair = native.builtins.get(\\"is_pair\\");
    const head = native.builtins.get(\\"head\\");
    const tail = native.builtins.get(\\"tail\\");
    const is_null = native.builtins.get(\\"is_null\\");
    const is_list = native.builtins.get(\\"is_list\\");
    const list = native.builtins.get(\\"list\\");
    const length = native.builtins.get(\\"length\\");
    const map = native.builtins.get(\\"map\\");
    const build_list = native.builtins.get(\\"build_list\\");
    const for_each = native.builtins.get(\\"for_each\\");
    const list_to_string = native.builtins.get(\\"list_to_string\\");
    const reverse = native.builtins.get(\\"reverse\\");
    const append = native.builtins.get(\\"append\\");
    const member = native.builtins.get(\\"member\\");
    const remove = native.builtins.get(\\"remove\\");
    const remove_all = native.builtins.get(\\"remove_all\\");
    const filter = native.builtins.get(\\"filter\\");
    const enum_list = native.builtins.get(\\"enum_list\\");
    const list_ref = native.builtins.get(\\"list_ref\\");
    const accumulate = native.builtins.get(\\"accumulate\\");
    const equal = native.builtins.get(\\"equal\\");
    const draw_data = native.builtins.get(\\"draw_data\\");
    const set_head = native.builtins.get(\\"set_head\\");
    const set_tail = native.builtins.get(\\"set_tail\\");
    const array_length = native.builtins.get(\\"array_length\\");
    const is_array = native.builtins.get(\\"is_array\\");
    const parse = native.builtins.get(\\"parse\\");
    const apply_in_underlying_javascript = native.builtins.get(\\"apply_in_underlying_javascript\\");
    const lastStatementResult = eval(\\"ensure_builtins;\\");
    return lastStatementResult;
  })();
})();
",
}
`;

exports[`function declarations get transformed to constant declaration of block arrow functions 1`] = `
Object {
  "code": "function f() {
  1; 2; 3;
}",
  "transpiled": "const native = $$NATIVE_STORAGE;
const boolOrErr = native.operators.get(\\"itselfIfBooleanElseError\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFunctionAndRightArgumentsElseError\\");
const wrap = native.properTailCalls.wrap;
(( <globals redacted> ) => {
  return (() => {
    const f = wrap(() => {
      1;
      2;
      3;
    });
    native.globals.set(\\"f\\", {
      kind: \\"const\\",
      value: f
    });
    return undefined;
  })();
})();
",
}
`;

// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Accessing array with nonexistent index returns undefined: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "const a = [];
a[1];",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": undefined,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    const a = [];
    lastStatementResult = eval(\\"getProp(a, 1, 2, 0);\\");
    globals.variables.set(\\"a\\", {
      kind: \\"const\\",
      getValue: () => {
        return a;
      }
    });
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`Accessing object with nonexistent property returns undefined: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "const o = {};
o.nonexistent;",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": undefined,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    const o = {};
    lastStatementResult = eval(\\"getProp(o, \\\\\\"nonexistent\\\\\\", 2, 0);\\");
    globals.variables.set(\\"o\\", {
      kind: \\"const\\",
      getValue: () => {
        return o;
      }
    });
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`Allow display to return value it is displaying: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "25*(display(1+1));",
  "displayResult": Array [
    "2",
  ],
  "errors": Array [],
  "parsedErrors": "",
  "result": 50,
  "resultStatus": "finished",
  "visualiseListResult": Array [],
}
`;

exports[`Array assignment has value: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "let arr = [];
const a = arr[0] = 1;
const b = arr[1] = arr[2] = 4;
arr[0] === 1 && arr[1] === 4 && arr[2] === 4;",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": true,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    let arr = [];
    const a = setProp(arr, 0, 1, 2, 10);
    const b = setProp(arr, 1, setProp(arr, 2, 4, 3, 19), 3, 10);
    lastStatementResult = eval(\\"boolOrErr(boolOrErr(binaryOp(\\\\\\"===\\\\\\", 3, getProp(arr, 0, 4, 0), 1, 4, 0), 4, 0) && binaryOp(\\\\\\"===\\\\\\", 3, getProp(arr, 1, 4, 16), 4, 4, 16), 4, 0) && binaryOp(\\\\\\"===\\\\\\", 3, getProp(arr, 2, 4, 32), 4, 4, 32);\\");
    globals.variables.set(\\"arr\\", {
      kind: \\"let\\",
      getValue: () => {
        return arr;
      },
      assignNewValue: function (unique) {
        return arr = unique;
      }
    });
    globals.variables.set(\\"a\\", {
      kind: \\"const\\",
      getValue: () => {
        return a;
      }
    });
    globals.variables.set(\\"b\\", {
      kind: \\"const\\",
      getValue: () => {
        return b;
      }
    });
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`Arrays toString matches up with JS: expect to match JS 1`] = `
Object {
  "alertResult": Array [],
  "code": "toString([1, 2]);",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": "1,2",
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(toString, 1, 0, [1, 2]);\\");
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`Arrow function definition returns itself: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "() => 42;",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": [Function],
  "resultStatus": "finished",
  "visualiseListResult": Array [],
}
`;

exports[`Arrow function infinite recursion with list args represents CallExpression well: expectParsedErrorNoErrorSnapshot 1`] = `
Object {
  "alertResult": Array [],
  "code": "const f = xs => append(f(xs), list());
f(list(1, 2));",
  "displayResult": Array [],
  "errors": Any<Array>,
  "parsedErrors": "Line 1: Maximum call stack size exceeded
  f([1, [2, null]])..  f([1, [2, null]])..  f([1, [2, null]])..",
  "result": undefined,
  "resultStatus": "error",
  "visualiseListResult": Array [],
}
`;

exports[`Assignment has value: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "let a = 1;
let b = a = 4;
b === 4 && a === 4;",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": true,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    let a = 1;
    let b = a = 4;
    lastStatementResult = eval(\\"boolOrErr(binaryOp(\\\\\\"===\\\\\\", 3, b, 4, 3, 0), 3, 0) && binaryOp(\\\\\\"===\\\\\\", 3, a, 4, 3, 11);\\");
    globals.variables.set(\\"a\\", {
      kind: \\"let\\",
      getValue: () => {
        return a;
      },
      assignNewValue: function (unique) {
        return a = unique;
      }
    });
    globals.variables.set(\\"b\\", {
      kind: \\"let\\",
      getValue: () => {
        return b;
      },
      assignNewValue: function (unique0) {
        return b = unique0;
      }
    });
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`Builtins hide their implementation when stringify: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "stringify(pair);",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": "function pair(left, right) {
	[implementation hidden]
}",
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(stringify, 1, 0, pair);\\");
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`Builtins hide their implementation when toString: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "toString(pair);",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": "function pair(left, right) {
	[implementation hidden]
}",
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(toString, 1, 0, pair);\\");
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`Can overwrite lets when assignment is allowed: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "function test() {
  let variable = false;
  variable = true;
  return variable;
}
test();",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": true,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    const test = wrap(() => {
      let variable = false;
      variable = true;
      return {
        isTail: false,
        value: variable
      };
    }, \\"function test() {\\\\n  let variable = false;\\\\n  variable = true;\\\\n  return variable;\\\\n}\\", native);
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(test, 6, 0);\\");
    globals.variables.set(\\"test\\", {
      kind: \\"const\\",
      getValue: () => {
        return test;
      }
    });
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`Cannot overwrite consts even when assignment is allowed: expectParsedError 1`] = `
Object {
  "alertResult": Array [],
  "code": "function test(){
  const constant = 3;
  constant = 4;
  return constant;
}
test();",
  "displayResult": Array [],
  "errors": Array [
    ConstAssignment {
      "location": SourceLocation {
        "end": Position {
          "column": 14,
          "line": 3,
        },
        "start": Position {
          "column": 2,
          "line": 3,
        },
      },
      "name": "constant",
      "severity": "Error",
      "type": "Runtime",
    },
  ],
  "parsedErrors": "Line 3: Cannot assign new value to constant constant.",
  "pretranspiled": "",
  "result": undefined,
  "resultStatus": "error",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    const test = wrap(() => {
      const constant = 3;
      constant = 4;
      return {
        isTail: false,
        value: constant
      };
    }, \\"function test() {\\\\n  const constant = 3;\\\\n  constant = 4;\\\\n  return constant;\\\\n}\\", native);
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(test, 6, 0);\\");
    globals.variables.set(\\"test\\", {
      kind: \\"const\\",
      getValue: () => {
        return test;
      }
    });
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`Deep object assignment and retrieval: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "const o = {};
o.a = {};
o.a.b = {};
o.a.b.c = \\"string\\";
o.a.b.c;",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": "string",
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    const o = {};
    setProp(o, \\"a\\", {}, 2, 0);
    setProp(getProp(o, \\"a\\", 3, 0), \\"b\\", {}, 3, 0);
    setProp(getProp(getProp(o, \\"a\\", 4, 0), \\"b\\", 4, 0), \\"c\\", \\"string\\", 4, 0);
    lastStatementResult = eval(\\"getProp(getProp(getProp(o, \\\\\\"a\\\\\\", 5, 0), \\\\\\"b\\\\\\", 5, 0), \\\\\\"c\\\\\\", 5, 0);\\");
    globals.variables.set(\\"o\\", {
      kind: \\"const\\",
      getValue: () => {
        return o;
      }
    });
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`Empty code returns undefined: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": undefined,
  "resultStatus": "finished",
  "visualiseListResult": Array [],
}
`;

exports[`Factorial arrow function: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "const fac = (i) => i === 1 ? 1 : i * fac(i-1);
fac(5);",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": 120,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    const fac = wrap(i => boolOrErr(binaryOp(\\"===\\", 1, i, 1, 1, 17), 1, 17) ? {
      isTail: false,
      value: 1
    } : {
      isTail: false,
      value: binaryOp(\\"*\\", 1, i, callIfFuncAndRightArgs(fac, 1, 35, binaryOp(\\"-\\", 1, i, 1, 1, 39)), 1, 31)
    }, \\"i => i === 1 ? 1 : i * fac(i - 1)\\", native);
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(fac, 2, 0, 5);\\");
    globals.variables.set(\\"fac\\", {
      kind: \\"const\\",
      getValue: () => {
        return fac;
      }
    });
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`Find arrow function declaration 1`] = `
SourceLocation {
  "end": Position {
    "column": 9,
    "line": 2,
  },
  "start": Position {
    "column": 6,
    "line": 2,
  },
}
`;

exports[`Find arrow function param declaration 1`] = `
SourceLocation {
  "end": Position {
    "column": 21,
    "line": 1,
  },
  "start": Position {
    "column": 18,
    "line": 1,
  },
}
`;

exports[`Find declaration in init of for loop 1`] = `
SourceLocation {
  "end": Position {
    "column": 10,
    "line": 2,
  },
  "start": Position {
    "column": 9,
    "line": 2,
  },
}
`;

exports[`Find declaration of of variable in update statement of a for loop 1`] = `
SourceLocation {
  "end": Position {
    "column": 10,
    "line": 1,
  },
  "start": Position {
    "column": 9,
    "line": 1,
  },
}
`;

exports[`Find function declaration 1`] = `
SourceLocation {
  "end": Position {
    "column": 12,
    "line": 2,
  },
  "start": Position {
    "column": 9,
    "line": 2,
  },
}
`;

exports[`Find function param declaration 1`] = `
SourceLocation {
  "end": Position {
    "column": 21,
    "line": 1,
  },
  "start": Position {
    "column": 18,
    "line": 1,
  },
}
`;

exports[`Find no declaration from occurrence when there is no declaration (syntax error) 1`] = `null`;

exports[`Find no declaration from selection that does not refer to a declaration 1`] = `null`;

exports[`Find scope of a function declaration 1`] = `
Array [
  SourceLocation {
    "end": Position {
      "column": 5,
      "line": 8,
    },
    "start": Position {
      "column": 4,
      "line": 3,
    },
  },
]
`;

exports[`Find scope of a function parameter 1`] = `
Array [
  SourceLocation {
    "end": Position {
      "column": 9,
      "line": 7,
    },
    "start": Position {
      "column": 22,
      "line": 5,
    },
  },
]
`;

exports[`Find scope of a nested variable declaration 1`] = `
Array [
  SourceLocation {
    "end": Position {
      "column": 5,
      "line": 8,
    },
    "start": Position {
      "column": 4,
      "line": 3,
    },
  },
]
`;

exports[`Find scope of a variable declaration 1`] = `
Array [
  Object {
    "end": Position {
      "column": 4,
      "line": 3,
    },
    "start": Position {
      "column": 0,
      "line": 1,
    },
  },
  Object {
    "end": Position {
      "column": 3,
      "line": 10,
    },
    "start": Position {
      "column": 5,
      "line": 8,
    },
  },
]
`;

exports[`Find scope of a variable declaration with more nesting 1`] = `
Array [
  Object {
    "end": Position {
      "column": 12,
      "line": 6,
    },
    "start": Position {
      "column": 4,
      "line": 3,
    },
  },
  Object {
    "end": Position {
      "column": 8,
      "line": 11,
    },
    "start": Position {
      "column": 13,
      "line": 8,
    },
  },
  Object {
    "end": Position {
      "column": 5,
      "line": 14,
    },
    "start": Position {
      "column": 9,
      "line": 13,
    },
  },
]
`;

exports[`Find scope of a variable declaration with multiple blocks 1`] = `
Array [
  Object {
    "end": Position {
      "column": 8,
      "line": 4,
    },
    "start": Position {
      "column": 4,
      "line": 2,
    },
  },
  Object {
    "end": Position {
      "column": 8,
      "line": 8,
    },
    "start": Position {
      "column": 9,
      "line": 6,
    },
  },
  Object {
    "end": Position {
      "column": 8,
      "line": 12,
    },
    "start": Position {
      "column": 9,
      "line": 10,
    },
  },
  Object {
    "end": Position {
      "column": 5,
      "line": 15,
    },
    "start": Position {
      "column": 9,
      "line": 14,
    },
  },
]
`;

exports[`Find variable declaration in block statement 1`] = `
SourceLocation {
  "end": Position {
    "column": 7,
    "line": 2,
  },
  "start": Position {
    "column": 6,
    "line": 2,
  },
}
`;

exports[`Find variable declaration in function scope from occurrence in function scope 1`] = `
SourceLocation {
  "end": Position {
    "column": 7,
    "line": 3,
  },
  "start": Position {
    "column": 6,
    "line": 3,
  },
}
`;

exports[`Find variable declaration in global scope 1`] = `
SourceLocation {
  "end": Position {
    "column": 5,
    "line": 1,
  },
  "start": Position {
    "column": 4,
    "line": 1,
  },
}
`;

exports[`Find variable declaration in global scope from occurrence in function scope 1`] = `
SourceLocation {
  "end": Position {
    "column": 5,
    "line": 1,
  },
  "start": Position {
    "column": 4,
    "line": 1,
  },
}
`;

exports[`Find variable declaration of same name as variable declaration in block statement 1`] = `
SourceLocation {
  "end": Position {
    "column": 5,
    "line": 5,
  },
  "start": Position {
    "column": 4,
    "line": 5,
  },
}
`;

exports[`Find variable declaration with same name as arrow function param declaration 1`] = `
SourceLocation {
  "end": Position {
    "column": 9,
    "line": 4,
  },
  "start": Position {
    "column": 6,
    "line": 4,
  },
}
`;

exports[`Find variable declaration with same name as init of for loop 1`] = `
SourceLocation {
  "end": Position {
    "column": 7,
    "line": 5,
  },
  "start": Position {
    "column": 6,
    "line": 5,
  },
}
`;

exports[`Function infinite recursion with list args represents CallExpression well: expectParsedErrorNoErrorSnapshot 1`] = `
Object {
  "alertResult": Array [],
  "code": "function f(xs) { return append(f(xs), list()); }
f(list(1, 2));",
  "displayResult": Array [],
  "errors": Any<Array>,
  "parsedErrors": "Line 1: Maximum call stack size exceeded
  f([1, [2, null]])..  f([1, [2, null]])..  f([1, [2, null]])..",
  "result": undefined,
  "resultStatus": "error",
  "visualiseListResult": Array [],
}
`;

exports[`Functions passed into non-source functions remain equal: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "function t(x, y, z) {
  return x + y + z;
}
identity(t) === t && t(1, 2, 3) === 6;",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": true,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    const t = wrap((x, y, z) => {
      return {
        isTail: false,
        value: binaryOp(\\"+\\", 3, binaryOp(\\"+\\", 3, x, y, 2, 9), z, 2, 9)
      };
    }, \\"function t(x, y, z) {\\\\n  return x + y + z;\\\\n}\\", native);
    lastStatementResult = eval(\\"boolOrErr(binaryOp(\\\\\\"===\\\\\\", 3, callIfFuncAndRightArgs(identity, 4, 0, t), t, 4, 0), 4, 0) && binaryOp(\\\\\\"===\\\\\\", 3, callIfFuncAndRightArgs(t, 4, 21, 1, 2, 3), 6, 4, 21);\\");
    globals.variables.set(\\"t\\", {
      kind: \\"const\\",
      getValue: () => {
        return t;
      }
    });
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`Multiline string self-evaluates to itself: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "\`1
1\`;",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": "1
1",
  "resultStatus": "finished",
  "visualiseListResult": Array [],
}
`;

exports[`Objects toString matches up with JS: expect to match JS 1`] = `
Object {
  "alertResult": Array [],
  "code": "toString({a: 1});",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": "[object Object]",
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(toString, 1, 0, {   a: 1 });\\");
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`Simple arrow function infinite recursion represents CallExpression well: expectParsedErrorNoErrorSnapshot 1`] = `
Object {
  "alertResult": Array [],
  "code": "(x => x(x)(x))(x => x(x)(x));",
  "displayResult": Array [],
  "errors": Any<Array>,
  "parsedErrors": "Line 1: Maximum call stack size exceeded
  x(x => x(x)(x))..  x(x => x(x)(x))..  x(x => x(x)(x))..",
  "result": undefined,
  "resultStatus": "error",
  "visualiseListResult": Array [],
}
`;

exports[`Simple function infinite recursion represents CallExpression well: expectParsedErrorNoErrorSnapshot 1`] = `
Object {
  "alertResult": Array [],
  "code": "function f(x) {return x(x)(x);} f(f);",
  "displayResult": Array [],
  "errors": Any<Array>,
  "parsedErrors": "Line 1: Maximum call stack size exceeded
  x(function f(x) {
  return x(x)(x);
})..  x(function f(x) {
  return x(x)(x);
})..  x(function f(x) {
  return x(x)(x);
})..",
  "result": undefined,
  "resultStatus": "error",
  "visualiseListResult": Array [],
}
`;

exports[`Simple object assignment and retrieval: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "const o = {};
o.a = 1;
o.a;",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": 1,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    const o = {};
    setProp(o, \\"a\\", 1, 2, 0);
    lastStatementResult = eval(\\"getProp(o, \\\\\\"a\\\\\\", 3, 0);\\");
    globals.variables.set(\\"o\\", {
      kind: \\"const\\",
      getValue: () => {
        return o;
      }
    });
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`Single boolean self-evaluates to itself: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "true;",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": true,
  "resultStatus": "finished",
  "visualiseListResult": Array [],
}
`;

exports[`Single number self-evaluates to itself: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "42;",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": 42,
  "resultStatus": "finished",
  "visualiseListResult": Array [],
}
`;

exports[`Single string self-evaluates to itself: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "'42';",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": "42",
  "resultStatus": "finished",
  "visualiseListResult": Array [],
}
`;

exports[`Test apply_in_underlying_javascript: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "apply_in_underlying_javascript((a, b, c) => a * b * c, list(2, 5, 6));",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": 60,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"callIfFuncAndRightArgs(apply_in_underlying_javascript, 1, 0, wrap((a, b, c) => ({   isTail: false,   value: binaryOp(\\\\\\"*\\\\\\", 4, binaryOp(\\\\\\"*\\\\\\", 4, a, b, 1, 44), c, 1, 44) }), \\\\\\"(a, b, c) => a * b * c\\\\\\", native), callIfFuncAndRightArgs(list, 1, 55, 2, 5, 6));\\");
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`Test context reuse: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "let i = 0;
function f() {
  i = i + 1;
  return i;
}
i;",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": 0,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    let i = 0;
    const f = wrap(() => {
      i = binaryOp(\\"+\\", 4, i, 1, 3, 6);
      return {
        isTail: false,
        value: i
      };
    }, \\"function f() {\\\\n  i = i + 1;\\\\n  return i;\\\\n}\\", native);
    lastStatementResult = eval(\\"i;\\");
    globals.variables.set(\\"i\\", {
      kind: \\"let\\",
      getValue: () => {
        return i;
      },
      assignNewValue: function (unique) {
        return i = unique;
      }
    });
    globals.variables.set(\\"f\\", {
      kind: \\"const\\",
      getValue: () => {
        return f;
      }
    });
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`Test context reuse: expectResult 2`] = `
Object {
  "alertResult": Array [],
  "code": "i = 100; f();",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": 101,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    {
      let i = globals.previousScope.variables.get(\\"i\\").getValue();
      const f = globals.previousScope.variables.get(\\"f\\").getValue();
      {
        i = globals.previousScope.variables.get(\\"i\\").assignNewValue(100);
        lastStatementResult = eval(\\"callIfFuncAndRightArgs(f, 1, 8);\\");
      }
    }
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`Test context reuse: expectResult 3`] = `
Object {
  "alertResult": Array [],
  "code": "f(); i;",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": 102,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    {
      let i = globals.previousScope.previousScope.previousScope.variables.get(\\"i\\").getValue();
      const f = globals.previousScope.previousScope.previousScope.variables.get(\\"f\\").getValue();
      {
        {
          {
            callIfFuncAndRightArgs(f, 1, 0);
            lastStatementResult = eval(\\"i = globals.previousScope.previousScope.previousScope.variables.get(\\\\\\"i\\\\\\").getValue();\\");
          }
        }
      }
    }
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`Test context reuse: expectResult 4`] = `
Object {
  "alertResult": Array [],
  "code": "i;",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": 102,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    {
      let i = globals.previousScope.previousScope.previousScope.previousScope.previousScope.variables.get(\\"i\\").getValue();
      const f = globals.previousScope.previousScope.previousScope.previousScope.previousScope.variables.get(\\"f\\").getValue();
      {
        {
          {
            {
              {
                lastStatementResult = eval(\\"i = globals.previousScope.previousScope.previousScope.previousScope.previousScope.variables.get(\\\\\\"i\\\\\\").getValue();\\");
              }
            }
          }
        }
      }
    }
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`Test equal for different lists: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "!equal(list(1, 2), pair(1, 2)) && !equal(list(1, 2, 3), list(1, list(2, 3)));",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": true,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"boolOrErr(unaryOp(\\\\\\"!\\\\\\", callIfFuncAndRightArgs(equal, 1, 1, callIfFuncAndRightArgs(list, 1, 7, 1, 2), callIfFuncAndRightArgs(pair, 1, 19, 1, 2)), 1, 0), 1, 0) && unaryOp(\\\\\\"!\\\\\\", callIfFuncAndRightArgs(equal, 1, 35, callIfFuncAndRightArgs(list, 1, 41, 1, 2, 3), callIfFuncAndRightArgs(list, 1, 56, 1, callIfFuncAndRightArgs(list, 1, 64, 2, 3))), 1, 34);\\");
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`Test equal for lists: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "equal(list(1, 2), pair(1, pair(2, null))) && equal(list(1, 2, 3, 4), list(1, 2, 3, 4));",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": true,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"boolOrErr(callIfFuncAndRightArgs(equal, 1, 0, callIfFuncAndRightArgs(list, 1, 6, 1, 2), callIfFuncAndRightArgs(pair, 1, 18, 1, callIfFuncAndRightArgs(pair, 1, 26, 2, null))), 1, 0) && callIfFuncAndRightArgs(equal, 1, 45, callIfFuncAndRightArgs(list, 1, 51, 1, 2, 3, 4), callIfFuncAndRightArgs(list, 1, 69, 1, 2, 3, 4));\\");
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`Test equal for primitives: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "equal(1, 1) && equal(\\"str\\", \\"str\\") && equal(null, null) && !equal(1, 2) && !equal(\\"str\\", \\"\\");",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": true,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"boolOrErr(boolOrErr(boolOrErr(boolOrErr(callIfFuncAndRightArgs(equal, 1, 0, 1, 1), 1, 0) && callIfFuncAndRightArgs(equal, 1, 15, \\\\\\"str\\\\\\", \\\\\\"str\\\\\\"), 1, 0) && callIfFuncAndRightArgs(equal, 1, 38, null, null), 1, 0) && unaryOp(\\\\\\"!\\\\\\", callIfFuncAndRightArgs(equal, 1, 60, 1, 2), 1, 59), 1, 0) && unaryOp(\\\\\\"!\\\\\\", callIfFuncAndRightArgs(equal, 1, 76, \\\\\\"str\\\\\\", \\\\\\"\\\\\\"), 1, 75);\\");
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`false if with empty else works: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "if (false) {
} else {
}",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": undefined,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"if (boolOrErr(false, 1, 0)) {} else {}\\");
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`false if with nonempty if works: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "if (false) {
} else {
  2;
}",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": 2,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"if (boolOrErr(false, 1, 0)) {} else {   2; }\\");
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`functions toString (mostly) matches up with JS: expect to loosely match JS 1`] = `
Object {
  "alertResult": Array [],
  "code": "function f(x) {
  return 5;
}
toString(a=>a) + toString(f);",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": "a => afunction f(x) {
  return 5;
}",
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    const f = wrap(x => {
      return {
        isTail: false,
        value: 5
      };
    }, \\"function f(x) {\\\\n  return 5;\\\\n}\\", native);
    lastStatementResult = eval(\\"binaryOp(\\\\\\"+\\\\\\", 1, callIfFuncAndRightArgs(toString, 4, 0, wrap(a => ({   isTail: false,   value: a }), \\\\\\"a => a\\\\\\", native)), callIfFuncAndRightArgs(toString, 4, 19, f), 4, 0);\\");
    globals.variables.set(\\"f\\", {
      kind: \\"const\\",
      getValue: () => {
        return f;
      }
    });
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`parseError for missing semicolon: expectParsedError 1`] = `
Object {
  "alertResult": Array [],
  "code": "42",
  "displayResult": Array [],
  "errors": Array [
    MissingSemicolonError {
      "location": Object {
        "end": Object {
          "column": 3,
          "line": 1,
        },
        "start": Object {
          "column": 3,
          "line": 1,
        },
      },
      "severity": "Error",
      "type": "Syntax",
    },
  ],
  "parsedErrors": "Line 1: Missing semicolon at the end of statement",
  "result": undefined,
  "resultStatus": "error",
  "visualiseListResult": Array [],
}
`;

exports[`parseError for template literals with expressions: expectParsedError 1`] = `
Object {
  "alertResult": Array [],
  "code": "\`\${1}\`;",
  "displayResult": Array [],
  "errors": Array [
    NoTemplateExpressionError {
      "node": Node {
        "end": 6,
        "expressions": Array [
          Node {
            "end": 4,
            "loc": SourceLocation {
              "end": Position {
                "column": 4,
                "line": 1,
              },
              "start": Position {
                "column": 3,
                "line": 1,
              },
            },
            "raw": "1",
            "start": 3,
            "type": "Literal",
            "value": 1,
          },
        ],
        "loc": SourceLocation {
          "end": Position {
            "column": 6,
            "line": 1,
          },
          "start": Position {
            "column": 0,
            "line": 1,
          },
        },
        "quasis": Array [
          Node {
            "end": 1,
            "loc": SourceLocation {
              "end": Position {
                "column": 1,
                "line": 1,
              },
              "start": Position {
                "column": 1,
                "line": 1,
              },
            },
            "start": 1,
            "tail": false,
            "type": "TemplateElement",
            "value": Object {
              "cooked": "",
              "raw": "",
            },
          },
          Node {
            "end": 5,
            "loc": SourceLocation {
              "end": Position {
                "column": 5,
                "line": 1,
              },
              "start": Position {
                "column": 5,
                "line": 1,
              },
            },
            "start": 5,
            "tail": true,
            "type": "TemplateElement",
            "value": Object {
              "cooked": "",
              "raw": "",
            },
          },
        ],
        "start": 0,
        "type": "TemplateLiteral",
      },
      "severity": "Error",
      "type": "Syntax",
    },
  ],
  "parsedErrors": "Line 1: Expressions are not allowed in template literals (\`multiline strings\`)",
  "result": undefined,
  "resultStatus": "error",
  "visualiseListResult": Array [],
}
`;

exports[`primitives toString matches up with JS: expect to match JS 1`] = `
Object {
  "alertResult": Array [],
  "code": "toString(true) +
toString(false) +
toString(1) +
toString(1.5) +
toString(null) +
toString(undefined) +
toString(NaN);",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": "truefalse11.5nullundefinedNaN",
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"binaryOp(\\\\\\"+\\\\\\", 2, binaryOp(\\\\\\"+\\\\\\", 2, binaryOp(\\\\\\"+\\\\\\", 2, binaryOp(\\\\\\"+\\\\\\", 2, binaryOp(\\\\\\"+\\\\\\", 2, binaryOp(\\\\\\"+\\\\\\", 2, callIfFuncAndRightArgs(toString, 1, 0, true), callIfFuncAndRightArgs(toString, 2, 0, false), 1, 0), callIfFuncAndRightArgs(toString, 3, 0, 1), 1, 0), callIfFuncAndRightArgs(toString, 4, 0, 1.5), 1, 0), callIfFuncAndRightArgs(toString, 5, 0, null), 1, 0), callIfFuncAndRightArgs(toString, 6, 0, undefined), 1, 0), callIfFuncAndRightArgs(toString, 7, 0, NaN), 1, 0);\\");
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`test && shortcircuiting: expect to match JS 1`] = `
Object {
  "alertResult": Array [],
  "code": "false && 1();",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": false,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"boolOrErr(false, 1, 0) && callIfFuncAndRightArgs(1, 1, 9);\\");
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`test || shortcircuiting: expect to match JS 1`] = `
Object {
  "alertResult": Array [],
  "code": "true || 1();",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": true,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"boolOrErr(true, 1, 0) || callIfFuncAndRightArgs(1, 1, 8);\\");
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`test false && false: expect to match JS 1`] = `
Object {
  "alertResult": Array [],
  "code": "false && false;",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": false,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"boolOrErr(false, 1, 0) && false;\\");
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`test false && true: expect to match JS 1`] = `
Object {
  "alertResult": Array [],
  "code": "false && true;",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": false,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"boolOrErr(false, 1, 0) && true;\\");
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`test false || false: expect to match JS 1`] = `
Object {
  "alertResult": Array [],
  "code": "false || false;",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": false,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"boolOrErr(false, 1, 0) || false;\\");
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`test false || true: expect to match JS 1`] = `
Object {
  "alertResult": Array [],
  "code": "false || true;",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": true,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"boolOrErr(false, 1, 0) || true;\\");
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`test false conditional expression: expect to match JS 1`] = `
Object {
  "alertResult": Array [],
  "code": "false ? true : false;",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": false,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"boolOrErr(false, 1, 0) ? true : false;\\");
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`test true && false: expect to match JS 1`] = `
Object {
  "alertResult": Array [],
  "code": "true && false;",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": false,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"boolOrErr(true, 1, 0) && false;\\");
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`test true && true: expect to match JS 1`] = `
Object {
  "alertResult": Array [],
  "code": "true && true;",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": true,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"boolOrErr(true, 1, 0) && true;\\");
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`test true || false: expect to match JS 1`] = `
Object {
  "alertResult": Array [],
  "code": "true || false;",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": true,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"boolOrErr(true, 1, 0) || false;\\");
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`test true || true: expect to match JS 1`] = `
Object {
  "alertResult": Array [],
  "code": "true || true;",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": true,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"boolOrErr(true, 1, 0) || true;\\");
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`test true conditional expression: expect to match JS 1`] = `
Object {
  "alertResult": Array [],
  "code": "true ? true : false;",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": true,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"boolOrErr(true, 1, 0) ? true : false;\\");
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`true if with empty if works: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "if (true) {
} else {
}",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": undefined,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"if (boolOrErr(true, 1, 0)) {} else {}\\");
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

exports[`true if with nonempty if works: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "if (true) {
  1;
} else {
}",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": 1,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    lastStatementResult = eval(\\"if (boolOrErr(true, 1, 0)) {   1; } else {}\\");
  }
}
lastStatementResult;
",
  "visualiseListResult": Array [],
}
`;

// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Binary operations force arguments: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "function add(x, y) {
  return x + y;
}
const res = add(((x) => x)(5), ((x) => x + 1)(9));
res;",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": 15,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    const add = wrap((x, y) => {
      return {
        isTail: false,
        value: binaryOp(\\"+\\", 1, x, y, 2, 9)
      };
    }, \\"function add(x, y) {\\\\n  return x + y;\\\\n}\\", native);
    const res = callIfFuncAndRightArgs(add, 4, 12, {
      isThunk: true,
      memoizedValue: 0,
      isMemoized: false,
      expr: () => {
        return callIfFuncAndRightArgs(wrap(x => ({
          isTail: false,
          value: x
        }), \\"x => x\\", native), 4, 16, {
          isThunk: true,
          memoizedValue: 0,
          isMemoized: false,
          expr: () => {
            return 5;
          }
        });
      }
    }, {
      isThunk: true,
      memoizedValue: 0,
      isMemoized: false,
      expr: () => {
        return callIfFuncAndRightArgs(wrap(x => ({
          isTail: false,
          value: binaryOp(\\"+\\", 1, x, 1, 4, 39)
        }), \\"x => x + 1\\", native), 4, 31, {
          isThunk: true,
          memoizedValue: 0,
          isMemoized: false,
          expr: () => {
            return 9;
          }
        });
      }
    });
    lastStatementResult = eval(\\"res;\\");
    globals.variables.set(\\"add\\", {
      kind: \\"const\\",
      getValue: () => {
        return add;
      }
    });
    globals.variables.set(\\"res\\", {
      kind: \\"const\\",
      getValue: () => {
        return res;
      }
    });
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`Conditionals force test: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "function f(a, b) {
  return (a ? true : head(null)) && (!b ? true : head(null));
}

const res = f(((b) => b)(true), ((b) => !b)(true));
res;",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": true,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    const f = wrap((a, b) => {
      return boolOrErr(boolOrErr(a, 2, 10) ? true : callIfFuncAndRightArgs(head, 2, 21, {
        isThunk: true,
        memoizedValue: 0,
        isMemoized: false,
        expr: () => {
          return null;
        }
      }), 2, 9) && (boolOrErr(unaryOp(\\"!\\", b, 2, 37), 2, 37) ? {
        isTail: false,
        value: true
      } : {
        isTail: true,
        function: head,
        functionName: \\"head\\",
        arguments: [{
          isThunk: true,
          memoizedValue: 0,
          isMemoized: false,
          expr: () => {
            return null;
          }
        }],
        line: 2,
        column: 49
      });
    }, \\"function f(a, b) {\\\\n  return (a ? true : head(null)) && (!b ? true : head(null));\\\\n}\\", native);
    const res = callIfFuncAndRightArgs(f, 5, 12, {
      isThunk: true,
      memoizedValue: 0,
      isMemoized: false,
      expr: () => {
        return callIfFuncAndRightArgs(wrap(b => ({
          isTail: false,
          value: b
        }), \\"b => b\\", native), 5, 14, {
          isThunk: true,
          memoizedValue: 0,
          isMemoized: false,
          expr: () => {
            return true;
          }
        });
      }
    }, {
      isThunk: true,
      memoizedValue: 0,
      isMemoized: false,
      expr: () => {
        return callIfFuncAndRightArgs(wrap(b => ({
          isTail: false,
          value: unaryOp(\\"!\\", b, 5, 40)
        }), \\"b => !b\\", native), 5, 32, {
          isThunk: true,
          memoizedValue: 0,
          isMemoized: false,
          expr: () => {
            return true;
          }
        });
      }
    });
    lastStatementResult = eval(\\"res;\\");
    globals.variables.set(\\"f\\", {
      kind: \\"const\\",
      getValue: () => {
        return f;
      }
    });
    globals.variables.set(\\"res\\", {
      kind: \\"const\\",
      getValue: () => {
        return res;
      }
    });
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`Tail calls work: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "function test(a, b) {
  return a === 1 ? a : b;
}

function test2(a) {
  return test(a, head(null));
}

const res = test2(1);
res;",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": 1,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    const test = wrap((a, b) => {
      return boolOrErr(binaryOp(\\"===\\", 2, a, 1, 2, 9), 2, 9) ? {
        isTail: false,
        value: a
      } : {
        isTail: false,
        value: b
      };
    }, \\"function test(a, b) {\\\\n  return a === 1 ? a : b;\\\\n}\\", native);
    const test2 = wrap(a => {
      return {
        isTail: true,
        function: test,
        functionName: \\"test\\",
        arguments: [{
          isThunk: true,
          memoizedValue: 0,
          isMemoized: false,
          expr: () => {
            return a;
          }
        }, {
          isThunk: true,
          memoizedValue: 0,
          isMemoized: false,
          expr: () => {
            return callIfFuncAndRightArgs(head, 6, 17, {
              isThunk: true,
              memoizedValue: 0,
              isMemoized: false,
              expr: () => {
                return null;
              }
            });
          }
        }],
        line: 6,
        column: 9
      };
    }, \\"function test2(a) {\\\\n  return test(a, head(null));\\\\n}\\", native);
    const res = callIfFuncAndRightArgs(test2, 9, 12, {
      isThunk: true,
      memoizedValue: 0,
      isMemoized: false,
      expr: () => {
        return 1;
      }
    });
    lastStatementResult = eval(\\"res;\\");
    globals.variables.set(\\"test\\", {
      kind: \\"const\\",
      getValue: () => {
        return test;
      }
    });
    globals.variables.set(\\"test2\\", {
      kind: \\"const\\",
      getValue: () => {
        return test2;
      }
    });
    globals.variables.set(\\"res\\", {
      kind: \\"const\\",
      getValue: () => {
        return res;
      }
    });
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`Thunks are memoized: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "let x = 1;

function incX() {
  x = x + 1;
  return x;
}

function square(n) {
  return n * n;
}

const res = square(incX());
res;",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": 4,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    let x = 1;
    const incX = wrap(() => {
      x = binaryOp(\\"+\\", 3, x, 1, 4, 6);
      return {
        isTail: false,
        value: x
      };
    }, \\"function incX() {\\\\n  x = x + 1;\\\\n  return x;\\\\n}\\", native);
    const square = wrap(n => {
      return {
        isTail: false,
        value: binaryOp(\\"*\\", 3, n, n, 9, 9)
      };
    }, \\"function square(n) {\\\\n  return n * n;\\\\n}\\", native);
    const res = callIfFuncAndRightArgs(square, 12, 12, {
      isThunk: true,
      memoizedValue: 0,
      isMemoized: false,
      expr: () => {
        return callIfFuncAndRightArgs(incX, 12, 19);
      }
    });
    lastStatementResult = eval(\\"res;\\");
    globals.variables.set(\\"x\\", {
      kind: \\"let\\",
      getValue: () => {
        return x;
      },
      assignNewValue: function (unique) {
        return x = unique;
      }
    });
    globals.variables.set(\\"incX\\", {
      kind: \\"const\\",
      getValue: () => {
        return incX;
      }
    });
    globals.variables.set(\\"square\\", {
      kind: \\"const\\",
      getValue: () => {
        return square;
      }
    });
    globals.variables.set(\\"res\\", {
      kind: \\"const\\",
      getValue: () => {
        return res;
      }
    });
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`Thunks capture local environment: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "function addSome(x) {
  const y = x + 1;
  return z => y + z;
}

const addSome2 = addSome(2);

const res = addSome2(3);
res;",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": 6,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    const addSome = wrap(x => {
      const y = binaryOp(\\"+\\", 1, x, 1, 2, 12);
      return {
        isTail: false,
        value: wrap(z => ({
          isTail: false,
          value: binaryOp(\\"+\\", 1, y, z, 3, 14)
        }), \\"z => y + z\\", native)
      };
    }, \\"function addSome(x) {\\\\n  const y = x + 1;\\\\n  return z => y + z;\\\\n}\\", native);
    const addSome2 = callIfFuncAndRightArgs(addSome, 6, 17, {
      isThunk: true,
      memoizedValue: 0,
      isMemoized: false,
      expr: () => {
        return 2;
      }
    });
    const res = callIfFuncAndRightArgs(addSome2, 8, 12, {
      isThunk: true,
      memoizedValue: 0,
      isMemoized: false,
      expr: () => {
        return 3;
      }
    });
    lastStatementResult = eval(\\"res;\\");
    globals.variables.set(\\"addSome\\", {
      kind: \\"const\\",
      getValue: () => {
        return addSome;
      }
    });
    globals.variables.set(\\"addSome2\\", {
      kind: \\"const\\",
      getValue: () => {
        return addSome2;
      }
    });
    globals.variables.set(\\"res\\", {
      kind: \\"const\\",
      getValue: () => {
        return res;
      }
    });
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`Unary operations force argument: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "function neg(b) {
  return !b;
}
const res = neg(((x) => x)(false));
res;",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": true,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    const neg = wrap(b => {
      return {
        isTail: false,
        value: unaryOp(\\"!\\", b, 2, 9)
      };
    }, \\"function neg(b) {\\\\n  return !b;\\\\n}\\", native);
    const res = callIfFuncAndRightArgs(neg, 4, 12, {
      isThunk: true,
      memoizedValue: 0,
      isMemoized: false,
      expr: () => {
        return callIfFuncAndRightArgs(wrap(x => ({
          isTail: false,
          value: x
        }), \\"x => x\\", native), 4, 16, {
          isThunk: true,
          memoizedValue: 0,
          isMemoized: false,
          expr: () => {
            return false;
          }
        });
      }
    });
    lastStatementResult = eval(\\"res;\\");
    globals.variables.set(\\"neg\\", {
      kind: \\"const\\",
      getValue: () => {
        return neg;
      }
    });
    globals.variables.set(\\"res\\", {
      kind: \\"const\\",
      getValue: () => {
        return res;
      }
    });
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

exports[`Unused arguments are not evaluated: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "function test(a, b, c, d, e, f) {
  return a;
}
const res = test(1, head(null), 1 + '', !1, '' - 1, head(head(null)));
res;",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "pretranspiled": "",
  "result": 1,
  "resultStatus": "finished",
  "transpiled": "const native = nativeStorage;
const forceIt = native.operators.get(\\"forceIt\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFuncAndRightArgs\\");
const boolOrErr = native.operators.get(\\"boolOrErr\\");
const wrap = native.operators.get(\\"wrap\\");
const unaryOp = native.operators.get(\\"unaryOp\\");
const binaryOp = native.operators.get(\\"binaryOp\\");
const throwIfTimeout = native.operators.get(\\"throwIfTimeout\\");
const setProp = native.operators.get(\\"setProp\\");
const getProp = native.operators.get(\\"getProp\\");
let lastStatementResult = undefined;
const globals = native.globals;
{
  {
    const test = wrap((a, b, c, d, e, f) => {
      return {
        isTail: false,
        value: a
      };
    }, \\"function test(a, b, c, d, e, f) {\\\\n  return a;\\\\n}\\", native);
    const res = callIfFuncAndRightArgs(test, 4, 12, {
      isThunk: true,
      memoizedValue: 0,
      isMemoized: false,
      expr: () => {
        return 1;
      }
    }, {
      isThunk: true,
      memoizedValue: 0,
      isMemoized: false,
      expr: () => {
        return callIfFuncAndRightArgs(head, 4, 20, {
          isThunk: true,
          memoizedValue: 0,
          isMemoized: false,
          expr: () => {
            return null;
          }
        });
      }
    }, {
      isThunk: true,
      memoizedValue: 0,
      isMemoized: false,
      expr: () => {
        return binaryOp(\\"+\\", 2, 1, '', 4, 32);
      }
    }, {
      isThunk: true,
      memoizedValue: 0,
      isMemoized: false,
      expr: () => {
        return unaryOp(\\"!\\", 1, 4, 40);
      }
    }, {
      isThunk: true,
      memoizedValue: 0,
      isMemoized: false,
      expr: () => {
        return binaryOp(\\"-\\", 2, '', 1, 4, 44);
      }
    }, {
      isThunk: true,
      memoizedValue: 0,
      isMemoized: false,
      expr: () => {
        return callIfFuncAndRightArgs(head, 4, 52, {
          isThunk: true,
          memoizedValue: 0,
          isMemoized: false,
          expr: () => {
            return callIfFuncAndRightArgs(head, 4, 57, {
              isThunk: true,
              memoizedValue: 0,
              isMemoized: false,
              expr: () => {
                return null;
              }
            });
          }
        });
      }
    });
    lastStatementResult = eval(\\"res;\\");
    globals.variables.set(\\"test\\", {
      kind: \\"const\\",
      getValue: () => {
        return test;
      }
    });
    globals.variables.set(\\"res\\", {
      kind: \\"const\\",
      getValue: () => {
        return res;
      }
    });
  }
}
forceIt(lastStatementResult);
",
  "visualiseListResult": Array [],
}
`;

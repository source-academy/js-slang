// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Bare early returns in for loops work: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "
    function unreachable() {
      return 1 < true; // Will cause an error
    }
    function f() {
      for (let i = 0; i < 100; i = i + 1) {
        return i+1;
        unreachable();
      }
      unreachable();
      return 0;
      unreachable();
    }
    f();
  ",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": 1,
  "resultStatus": "finished",
  "transpiled": "const native = $$NATIVE_STORAGE;
const boolOrErr = native.operators.get(\\"itselfIfBooleanElseError\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFunctionAndRightArgumentsElseError\\");
const wrap = native.properTailCalls.wrap;
(( <globals redacted> ) => {
  return (() => {
    const unreachable = wrap(() => {
      return {
        isTail: false,
        value: 1 < true
      };
    }, \\"function unreachable() {\\\\n  return 1 < true;\\\\n}\\");
    const f = wrap(() => {
      for (let i = 0; i < 100; i = i + 1) {
        return {
          isTail: false,
          value: i + 1
        };
        callIfFuncAndRightArgs(unreachable, 8, 8);
      }
      callIfFuncAndRightArgs(unreachable, 10, 6);
      return {
        isTail: false,
        value: 0
      };
      callIfFuncAndRightArgs(unreachable, 12, 6);
    }, \\"function f() {\\\\n  for (let i = 0; i < 100; i = i + 1) {\\\\n    return i + 1;\\\\n    unreachable();\\\\n  }\\\\n  unreachable();\\\\n  return 0;\\\\n  unreachable();\\\\n}\\");
    const lastStatementResult = eval(\\"callIfFuncAndRightArgs(f, 14, 4);\\");
    native.globals.set(\\"unreachable\\", {
      kind: \\"const\\",
      value: unreachable
    });
    native.globals.set(\\"f\\", {
      kind: \\"const\\",
      value: f
    });
    return lastStatementResult;
  })();
})();
",
  "visualiseListResult": Array [],
}
`;

exports[`Bare early returns in if statements work: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "
    function unreachable() {
      return 1 < true; // Will cause an error
    }
    function f() {
      if (true) {
        return 1;
        unreachable();
      } else {}
      unreachable();
      return 0;
      unreachable();
    }
    f();
  ",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": 1,
  "resultStatus": "finished",
  "transpiled": "const native = $$NATIVE_STORAGE;
const boolOrErr = native.operators.get(\\"itselfIfBooleanElseError\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFunctionAndRightArgumentsElseError\\");
const wrap = native.properTailCalls.wrap;
(( <globals redacted> ) => {
  return (() => {
    const unreachable = wrap(() => {
      return {
        isTail: false,
        value: 1 < true
      };
    }, \\"function unreachable() {\\\\n  return 1 < true;\\\\n}\\");
    const f = wrap(() => {
      if (boolOrErr(true, 6, 6)) {
        return {
          isTail: false,
          value: 1
        };
        callIfFuncAndRightArgs(unreachable, 8, 8);
      } else {}
      callIfFuncAndRightArgs(unreachable, 10, 6);
      return {
        isTail: false,
        value: 0
      };
      callIfFuncAndRightArgs(unreachable, 12, 6);
    }, \\"function f() {\\\\n  if (true) {\\\\n    return 1;\\\\n    unreachable();\\\\n  } else {}\\\\n  unreachable();\\\\n  return 0;\\\\n  unreachable();\\\\n}\\");
    const lastStatementResult = eval(\\"callIfFuncAndRightArgs(f, 14, 4);\\");
    native.globals.set(\\"unreachable\\", {
      kind: \\"const\\",
      value: unreachable
    });
    native.globals.set(\\"f\\", {
      kind: \\"const\\",
      value: f
    });
    return lastStatementResult;
  })();
})();
",
  "visualiseListResult": Array [],
}
`;

exports[`Bare early returns in while loops work: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "
    function unreachable() {
      return 1 < true; // Will cause an error
    }
    function f() {
      while (true) {
        return 1;
        unreachable();
      }
      unreachable();
      return 0;
      unreachable();
    }
    f();
  ",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": 1,
  "resultStatus": "finished",
  "transpiled": "const native = $$NATIVE_STORAGE;
const boolOrErr = native.operators.get(\\"itselfIfBooleanElseError\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFunctionAndRightArgumentsElseError\\");
const wrap = native.properTailCalls.wrap;
(( <globals redacted> ) => {
  return (() => {
    const unreachable = wrap(() => {
      return {
        isTail: false,
        value: 1 < true
      };
    }, \\"function unreachable() {\\\\n  return 1 < true;\\\\n}\\");
    const f = wrap(() => {
      while (true) {
        return {
          isTail: false,
          value: 1
        };
        callIfFuncAndRightArgs(unreachable, 8, 8);
      }
      callIfFuncAndRightArgs(unreachable, 10, 6);
      return {
        isTail: false,
        value: 0
      };
      callIfFuncAndRightArgs(unreachable, 12, 6);
    }, \\"function f() {\\\\n  while (true) {\\\\n    return 1;\\\\n    unreachable();\\\\n  }\\\\n  unreachable();\\\\n  return 0;\\\\n  unreachable();\\\\n}\\");
    const lastStatementResult = eval(\\"callIfFuncAndRightArgs(f, 14, 4);\\");
    native.globals.set(\\"unreachable\\", {
      kind: \\"const\\",
      value: unreachable
    });
    native.globals.set(\\"f\\", {
      kind: \\"const\\",
      value: f
    });
    return lastStatementResult;
  })();
})();
",
  "visualiseListResult": Array [],
}
`;

exports[`Bare early returns work: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "
    function unreachable() {
      return 1 < true; // Will cause an error
    }
    function f() {
      return 1;
      unreachable();
      return 0;
      unreachable();
    }
    f();
  ",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": 1,
  "resultStatus": "finished",
  "transpiled": "const native = $$NATIVE_STORAGE;
const boolOrErr = native.operators.get(\\"itselfIfBooleanElseError\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFunctionAndRightArgumentsElseError\\");
const wrap = native.properTailCalls.wrap;
(( <globals redacted> ) => {
  return (() => {
    const unreachable = wrap(() => {
      return {
        isTail: false,
        value: 1 < true
      };
    }, \\"function unreachable() {\\\\n  return 1 < true;\\\\n}\\");
    const f = wrap(() => {
      return {
        isTail: false,
        value: 1
      };
      callIfFuncAndRightArgs(unreachable, 7, 6);
      return {
        isTail: false,
        value: 0
      };
      callIfFuncAndRightArgs(unreachable, 9, 6);
    }, \\"function f() {\\\\n  return 1;\\\\n  unreachable();\\\\n  return 0;\\\\n  unreachable();\\\\n}\\");
    const lastStatementResult = eval(\\"callIfFuncAndRightArgs(f, 11, 4);\\");
    native.globals.set(\\"unreachable\\", {
      kind: \\"const\\",
      value: unreachable
    });
    native.globals.set(\\"f\\", {
      kind: \\"const\\",
      value: f
    });
    return lastStatementResult;
  })();
})();
",
  "visualiseListResult": Array [],
}
`;

exports[`Calling unreachable results in error: expectParsedError 1`] = `
Object {
  "alertResult": Array [],
  "code": "
    function unreachable() {
      return 1 < true; // Will cause an error
    }
    function f() {
      unreachable();
      return 0;
    }
    f();
  ",
  "displayResult": Array [],
  "errors": Array [
    TypeError {
      "expected": "number",
      "got": "boolean",
      "location": SourceLocation {
        "end": Position {
          "column": 21,
          "line": 3,
        },
        "start": Position {
          "column": 13,
          "line": 3,
        },
      },
      "severity": "Error",
      "side": " on right hand side of operation",
      "type": "Runtime",
    },
  ],
  "parsedErrors": "Line 3: Expected number on right hand side of operation, got boolean.",
  "result": undefined,
  "resultStatus": "error",
  "visualiseListResult": Array [],
}
`;

exports[`Recursive call early returns in for loops work: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "
    function unreachable() {
      return 1 < true; // Will cause an error
    }
    function id(x) {
      return x;
    }
    function f() {
      for (let i = 0; i < 100; i = i + 1) {
        return id(i+1) + id(i+2);
      }
      return 0;
    }
    f();
  ",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": 3,
  "resultStatus": "finished",
  "transpiled": "const native = $$NATIVE_STORAGE;
const boolOrErr = native.operators.get(\\"itselfIfBooleanElseError\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFunctionAndRightArgumentsElseError\\");
const wrap = native.properTailCalls.wrap;
(( <globals redacted> ) => {
  return (() => {
    const unreachable = wrap(() => {
      return {
        isTail: false,
        value: 1 < true
      };
    }, \\"function unreachable() {\\\\n  return 1 < true;\\\\n}\\");
    const id = wrap(x => {
      return {
        isTail: false,
        value: x
      };
    }, \\"function id(x) {\\\\n  return x;\\\\n}\\");
    const f = wrap(() => {
      for (let i = 0; i < 100; i = i + 1) {
        return {
          isTail: false,
          value: callIfFuncAndRightArgs(id, 10, 15, i + 1) + callIfFuncAndRightArgs(id, 10, 25, i + 2)
        };
      }
      return {
        isTail: false,
        value: 0
      };
    }, \\"function f() {\\\\n  for (let i = 0; i < 100; i = i + 1) {\\\\n    return id(i + 1) + id(i + 2);\\\\n  }\\\\n  return 0;\\\\n}\\");
    const lastStatementResult = eval(\\"callIfFuncAndRightArgs(f, 14, 4);\\");
    native.globals.set(\\"unreachable\\", {
      kind: \\"const\\",
      value: unreachable
    });
    native.globals.set(\\"id\\", {
      kind: \\"const\\",
      value: id
    });
    native.globals.set(\\"f\\", {
      kind: \\"const\\",
      value: f
    });
    return lastStatementResult;
  })();
})();
",
  "visualiseListResult": Array [],
}
`;

exports[`Recursive call early returns in if statements work: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "
    function unreachable() {
      return 1 < true; // Will cause an error
    }
    function id(x) {
      return x;
    }
    function f() {
      if (true) {
        return id(1) + id(2);
        unreachable();
      } else {}
      unreachable();
      return 0;
      unreachable();
    }
    f();
  ",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": 3,
  "resultStatus": "finished",
  "transpiled": "const native = $$NATIVE_STORAGE;
const boolOrErr = native.operators.get(\\"itselfIfBooleanElseError\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFunctionAndRightArgumentsElseError\\");
const wrap = native.properTailCalls.wrap;
(( <globals redacted> ) => {
  return (() => {
    const unreachable = wrap(() => {
      return {
        isTail: false,
        value: 1 < true
      };
    }, \\"function unreachable() {\\\\n  return 1 < true;\\\\n}\\");
    const id = wrap(x => {
      return {
        isTail: false,
        value: x
      };
    }, \\"function id(x) {\\\\n  return x;\\\\n}\\");
    const f = wrap(() => {
      if (boolOrErr(true, 9, 6)) {
        return {
          isTail: false,
          value: callIfFuncAndRightArgs(id, 10, 15, 1) + callIfFuncAndRightArgs(id, 10, 23, 2)
        };
        callIfFuncAndRightArgs(unreachable, 11, 8);
      } else {}
      callIfFuncAndRightArgs(unreachable, 13, 6);
      return {
        isTail: false,
        value: 0
      };
      callIfFuncAndRightArgs(unreachable, 15, 6);
    }, \\"function f() {\\\\n  if (true) {\\\\n    return id(1) + id(2);\\\\n    unreachable();\\\\n  } else {}\\\\n  unreachable();\\\\n  return 0;\\\\n  unreachable();\\\\n}\\");
    const lastStatementResult = eval(\\"callIfFuncAndRightArgs(f, 17, 4);\\");
    native.globals.set(\\"unreachable\\", {
      kind: \\"const\\",
      value: unreachable
    });
    native.globals.set(\\"id\\", {
      kind: \\"const\\",
      value: id
    });
    native.globals.set(\\"f\\", {
      kind: \\"const\\",
      value: f
    });
    return lastStatementResult;
  })();
})();
",
  "visualiseListResult": Array [],
}
`;

exports[`Recursive call early returns in while loops work: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "
    function unreachable() {
      return 1 < true; // Will cause an error
    }
    function id(x) {
      return x;
    }
    function f() {
      while (true) {
        return id(1) + id(2);
        unreachable();
      }
      unreachable();
      return 0;
      unreachable();
    }
    f();
  ",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": 3,
  "resultStatus": "finished",
  "transpiled": "const native = $$NATIVE_STORAGE;
const boolOrErr = native.operators.get(\\"itselfIfBooleanElseError\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFunctionAndRightArgumentsElseError\\");
const wrap = native.properTailCalls.wrap;
(( <globals redacted> ) => {
  return (() => {
    const unreachable = wrap(() => {
      return {
        isTail: false,
        value: 1 < true
      };
    }, \\"function unreachable() {\\\\n  return 1 < true;\\\\n}\\");
    const id = wrap(x => {
      return {
        isTail: false,
        value: x
      };
    }, \\"function id(x) {\\\\n  return x;\\\\n}\\");
    const f = wrap(() => {
      while (true) {
        return {
          isTail: false,
          value: callIfFuncAndRightArgs(id, 10, 15, 1) + callIfFuncAndRightArgs(id, 10, 23, 2)
        };
        callIfFuncAndRightArgs(unreachable, 11, 8);
      }
      callIfFuncAndRightArgs(unreachable, 13, 6);
      return {
        isTail: false,
        value: 0
      };
      callIfFuncAndRightArgs(unreachable, 15, 6);
    }, \\"function f() {\\\\n  while (true) {\\\\n    return id(1) + id(2);\\\\n    unreachable();\\\\n  }\\\\n  unreachable();\\\\n  return 0;\\\\n  unreachable();\\\\n}\\");
    const lastStatementResult = eval(\\"callIfFuncAndRightArgs(f, 17, 4);\\");
    native.globals.set(\\"unreachable\\", {
      kind: \\"const\\",
      value: unreachable
    });
    native.globals.set(\\"id\\", {
      kind: \\"const\\",
      value: id
    });
    native.globals.set(\\"f\\", {
      kind: \\"const\\",
      value: f
    });
    return lastStatementResult;
  })();
})();
",
  "visualiseListResult": Array [],
}
`;

exports[`Recursive call early returns work: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "
    function unreachable() {
      return 1 < true; // Will cause an error
    }
    function id(x) {
      return x;
    }
    function f() {
      return id(1) + id(2);
      unreachable();
      return 0;
      unreachable();
    }
    f();
  ",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": 3,
  "resultStatus": "finished",
  "transpiled": "const native = $$NATIVE_STORAGE;
const boolOrErr = native.operators.get(\\"itselfIfBooleanElseError\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFunctionAndRightArgumentsElseError\\");
const wrap = native.properTailCalls.wrap;
(( <globals redacted> ) => {
  return (() => {
    const unreachable = wrap(() => {
      return {
        isTail: false,
        value: 1 < true
      };
    }, \\"function unreachable() {\\\\n  return 1 < true;\\\\n}\\");
    const id = wrap(x => {
      return {
        isTail: false,
        value: x
      };
    }, \\"function id(x) {\\\\n  return x;\\\\n}\\");
    const f = wrap(() => {
      return {
        isTail: false,
        value: callIfFuncAndRightArgs(id, 9, 13, 1) + callIfFuncAndRightArgs(id, 9, 21, 2)
      };
      callIfFuncAndRightArgs(unreachable, 10, 6);
      return {
        isTail: false,
        value: 0
      };
      callIfFuncAndRightArgs(unreachable, 12, 6);
    }, \\"function f() {\\\\n  return id(1) + id(2);\\\\n  unreachable();\\\\n  return 0;\\\\n  unreachable();\\\\n}\\");
    const lastStatementResult = eval(\\"callIfFuncAndRightArgs(f, 14, 4);\\");
    native.globals.set(\\"unreachable\\", {
      kind: \\"const\\",
      value: unreachable
    });
    native.globals.set(\\"id\\", {
      kind: \\"const\\",
      value: id
    });
    native.globals.set(\\"f\\", {
      kind: \\"const\\",
      value: f
    });
    return lastStatementResult;
  })();
})();
",
  "visualiseListResult": Array [],
}
`;

exports[`Tail call early returns in for loops work: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "
    function unreachable() {
      return 1 < true; // Will cause an error
    }
    function id(x) {
      return x;
    }
    function f() {
      for (let i = 0; i < 100; i = i + 1) {
        return id(i+1);
        unreachable();
      }
      unreachable();
      return 0;
      unreachable();
    }
    f();
  ",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": 1,
  "resultStatus": "finished",
  "transpiled": "const native = $$NATIVE_STORAGE;
const boolOrErr = native.operators.get(\\"itselfIfBooleanElseError\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFunctionAndRightArgumentsElseError\\");
const wrap = native.properTailCalls.wrap;
(( <globals redacted> ) => {
  return (() => {
    const unreachable = wrap(() => {
      return {
        isTail: false,
        value: 1 < true
      };
    }, \\"function unreachable() {\\\\n  return 1 < true;\\\\n}\\");
    const id = wrap(x => {
      return {
        isTail: false,
        value: x
      };
    }, \\"function id(x) {\\\\n  return x;\\\\n}\\");
    const f = wrap(() => {
      for (let i = 0; i < 100; i = i + 1) {
        return {
          isTail: true,
          function: id,
          arguments: [i + 1],
          line: 10,
          column: 15
        };
        callIfFuncAndRightArgs(unreachable, 11, 8);
      }
      callIfFuncAndRightArgs(unreachable, 13, 6);
      return {
        isTail: false,
        value: 0
      };
      callIfFuncAndRightArgs(unreachable, 15, 6);
    }, \\"function f() {\\\\n  for (let i = 0; i < 100; i = i + 1) {\\\\n    return id(i + 1);\\\\n    unreachable();\\\\n  }\\\\n  unreachable();\\\\n  return 0;\\\\n  unreachable();\\\\n}\\");
    const lastStatementResult = eval(\\"callIfFuncAndRightArgs(f, 17, 4);\\");
    native.globals.set(\\"unreachable\\", {
      kind: \\"const\\",
      value: unreachable
    });
    native.globals.set(\\"id\\", {
      kind: \\"const\\",
      value: id
    });
    native.globals.set(\\"f\\", {
      kind: \\"const\\",
      value: f
    });
    return lastStatementResult;
  })();
})();
",
  "visualiseListResult": Array [],
}
`;

exports[`Tail call early returns in if statements work: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "
    function unreachable() {
      return 1 < true; // Will cause an error
    }
    function id(x) {
      return x;
    }
    function f() {
      if (true) {
        return id(1);
        unreachable();
      } else {}
      unreachable();
      return 0;
      unreachable();
    }
    f();
  ",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": 1,
  "resultStatus": "finished",
  "transpiled": "const native = $$NATIVE_STORAGE;
const boolOrErr = native.operators.get(\\"itselfIfBooleanElseError\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFunctionAndRightArgumentsElseError\\");
const wrap = native.properTailCalls.wrap;
(( <globals redacted> ) => {
  return (() => {
    const unreachable = wrap(() => {
      return {
        isTail: false,
        value: 1 < true
      };
    }, \\"function unreachable() {\\\\n  return 1 < true;\\\\n}\\");
    const id = wrap(x => {
      return {
        isTail: false,
        value: x
      };
    }, \\"function id(x) {\\\\n  return x;\\\\n}\\");
    const f = wrap(() => {
      if (boolOrErr(true, 9, 6)) {
        return {
          isTail: true,
          function: id,
          arguments: [1],
          line: 10,
          column: 15
        };
        callIfFuncAndRightArgs(unreachable, 11, 8);
      } else {}
      callIfFuncAndRightArgs(unreachable, 13, 6);
      return {
        isTail: false,
        value: 0
      };
      callIfFuncAndRightArgs(unreachable, 15, 6);
    }, \\"function f() {\\\\n  if (true) {\\\\n    return id(1);\\\\n    unreachable();\\\\n  } else {}\\\\n  unreachable();\\\\n  return 0;\\\\n  unreachable();\\\\n}\\");
    const lastStatementResult = eval(\\"callIfFuncAndRightArgs(f, 17, 4);\\");
    native.globals.set(\\"unreachable\\", {
      kind: \\"const\\",
      value: unreachable
    });
    native.globals.set(\\"id\\", {
      kind: \\"const\\",
      value: id
    });
    native.globals.set(\\"f\\", {
      kind: \\"const\\",
      value: f
    });
    return lastStatementResult;
  })();
})();
",
  "visualiseListResult": Array [],
}
`;

exports[`Tail call early returns in while loops work: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "
    function unreachable() {
      return 1 < true; // Will cause an error
    }
    function id(x) {
      return x;
    }
    function f() {
      while (true) {
        return id(1);
        unreachable();
      }
      unreachable();
      return 0;
      unreachable();
    }
    f();
  ",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": 1,
  "resultStatus": "finished",
  "transpiled": "const native = $$NATIVE_STORAGE;
const boolOrErr = native.operators.get(\\"itselfIfBooleanElseError\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFunctionAndRightArgumentsElseError\\");
const wrap = native.properTailCalls.wrap;
(( <globals redacted> ) => {
  return (() => {
    const unreachable = wrap(() => {
      return {
        isTail: false,
        value: 1 < true
      };
    }, \\"function unreachable() {\\\\n  return 1 < true;\\\\n}\\");
    const id = wrap(x => {
      return {
        isTail: false,
        value: x
      };
    }, \\"function id(x) {\\\\n  return x;\\\\n}\\");
    const f = wrap(() => {
      while (true) {
        return {
          isTail: true,
          function: id,
          arguments: [1],
          line: 10,
          column: 15
        };
        callIfFuncAndRightArgs(unreachable, 11, 8);
      }
      callIfFuncAndRightArgs(unreachable, 13, 6);
      return {
        isTail: false,
        value: 0
      };
      callIfFuncAndRightArgs(unreachable, 15, 6);
    }, \\"function f() {\\\\n  while (true) {\\\\n    return id(1);\\\\n    unreachable();\\\\n  }\\\\n  unreachable();\\\\n  return 0;\\\\n  unreachable();\\\\n}\\");
    const lastStatementResult = eval(\\"callIfFuncAndRightArgs(f, 17, 4);\\");
    native.globals.set(\\"unreachable\\", {
      kind: \\"const\\",
      value: unreachable
    });
    native.globals.set(\\"id\\", {
      kind: \\"const\\",
      value: id
    });
    native.globals.set(\\"f\\", {
      kind: \\"const\\",
      value: f
    });
    return lastStatementResult;
  })();
})();
",
  "visualiseListResult": Array [],
}
`;

exports[`Tail call early returns work: expectResult 1`] = `
Object {
  "alertResult": Array [],
  "code": "
    function unreachable() {
      return 1 < true; // Will cause an error
    }
    function id(x) {
      return x;
    }
    function f() {
      return id(1);
      unreachable();
      return 0;
      unreachable();
    }
    f();
  ",
  "displayResult": Array [],
  "errors": Array [],
  "parsedErrors": "",
  "result": 1,
  "resultStatus": "finished",
  "transpiled": "const native = $$NATIVE_STORAGE;
const boolOrErr = native.operators.get(\\"itselfIfBooleanElseError\\");
const callIfFuncAndRightArgs = native.operators.get(\\"callIfFunctionAndRightArgumentsElseError\\");
const wrap = native.properTailCalls.wrap;
(( <globals redacted> ) => {
  return (() => {
    const unreachable = wrap(() => {
      return {
        isTail: false,
        value: 1 < true
      };
    }, \\"function unreachable() {\\\\n  return 1 < true;\\\\n}\\");
    const id = wrap(x => {
      return {
        isTail: false,
        value: x
      };
    }, \\"function id(x) {\\\\n  return x;\\\\n}\\");
    const f = wrap(() => {
      return {
        isTail: true,
        function: id,
        arguments: [1],
        line: 9,
        column: 13
      };
      callIfFuncAndRightArgs(unreachable, 10, 6);
      return {
        isTail: false,
        value: 0
      };
      callIfFuncAndRightArgs(unreachable, 12, 6);
    }, \\"function f() {\\\\n  return id(1);\\\\n  unreachable();\\\\n  return 0;\\\\n  unreachable();\\\\n}\\");
    const lastStatementResult = eval(\\"callIfFuncAndRightArgs(f, 14, 4);\\");
    native.globals.set(\\"unreachable\\", {
      kind: \\"const\\",
      value: unreachable
    });
    native.globals.set(\\"id\\", {
      kind: \\"const\\",
      value: id
    });
    native.globals.set(\\"f\\", {
      kind: \\"const\\",
      value: f
    });
    return lastStatementResult;
  })();
})();
",
  "visualiseListResult": Array [],
}
`;

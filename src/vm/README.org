#+OPTIONS: toc:nil H:4
#+LATEX_HEADER: \newcommand{\qed}{$\Box$}
#+LATEX_HEADER: \newcommand{\Rule}[2]{\genfrac{}{}{0.7pt}{}{{\setlength{\fboxrule}{0pt}\setlength{\fboxsep}{3mm}\fbox{$#1$}}}{{\setlength{\fboxrule}{0pt}\setlength{\fboxsep}{3mm}\fbox{$#2$}}}}
#+LATEX_HEADER: \newcommand{\Rulee}[3]{\genfrac{}{}{0.7pt}{}{{\setlength{\fboxrule}{0pt}\setlength{\fboxsep}{3mm}\fbox{$#1$}}}{{\setlength{\fboxrule}{0pt}\setlength{\fboxsep}{3mm}\fbox{$#2$}}}[#3]}
#+LATEX_HEADER: \newcommand{\transition}{\rightrightarrows_s}
#+LATEX_HEADER: \newcommand{\translate}{\twoheadrightarrow}
#+LATEX_HEADER: \newcommand{\translateaux}{\hookrightarrow}

* Specification of Concurrent Virtual Machine
Compared to Source $\S 3$, this concurrent system has the following changes:
- The addition of three primitive concurrent functions.
For details, see Section ``Concurrency Support'' below.

** Overview
This concurrent system consists of concurrently executing (potentially multiple) code in multiple threads. Communication between threads is achieved by updating the values of memory shared between threads. Each thread is a nullary function that returns =undefined=, and the concurrent system executes each thread by running the code in the body of the nullary function.

To comply with the textbook, the thread that calls =concurrent_execute= also continues to execute the rest of its code concurrently with the threads. Furthermore, there is no =join= primitive concurrent function.

However, this design departs from the textbook, as the system does not execute parallel threads. Instead, it executes concurrent threads.

** Concurrency Support
The following concurrent functions are supported:
- =concurrent_execute=: \textit{primitive}, executes multiple threads concurrently. Each $f_1, \cdots ,f_n$ is a nullary function that returns =undefined=, and each thread is executed by running the code in the body of the nullary function. Returns =undefined=.
- =test_and_set=: \textit{primitive}, assumes the head of array $a$ is a boolean $b$. Sets the head of $a$ to =true=. Returns $b$.
- =clear=: \textit{primitive}, sets the head of array $a$ to =false=. Returns =undefined=.

** =EXECUTE= Rules

*** Notes
- For simplicity, heap is not represented in the rules.

*** Compiling
$\Rule{E_1 \translateaux s_1 \qquad \cdots \qquad E_n \translateaux s_n}{\texttt{concurrent\_execute}(E_1, \cdots , E_n) \translateaux s_1. \cdots .s_n.\texttt{EXECUTE n}}\\$
Each of $s_1. \cdots .s_n$ is a string of VM instruction that loads a closure onto the operand stack.

*** Running
There are additional structures in our VM:
0. $\textit{tq}$, a register which is a queue of threads.
0. $\textit{to}$, a register initialized with $0$, that indicates how many instructions are left for a thread to run.
The state representing our VM will have two more corresponding structures:
$(\textit{os}, \textit{pc}, \textit{e}, \textit{rs}, \textit{tq}, \textit{to})\\$
The initial state of our VM is a $\textit{pc}$, which has empty $\textit{os}$, $\textit{env}$, $\textit{rs}$, and $\textit{tq}$, and zero timeout:
$(\langle \rangle, \textit{pc}, \langle \rangle, \langle \rangle, \langle \rangle, 0)\\$

Some notes on program execution:
0. When the program calls =concurrent_execute=, it executes the rest of its code along with the concurrent threads, therefore the sequential program becomes a concurrent thread.
0. Consider the case when a program does not use any primitive concurrent functions. To avoid distinguishing between the case when the program is sequential and the program is concurrent, therefore simplifying the rules, the sequential program must still execute like a concurrent thread. This means sequential execution may time out, and may be pushed and popped from the thread queue.
0. As a result, all programs here are concurrent programs, even if they do not call =concurrent_execute=.
0. None of the programs here return a result, because concurrent programs should not return a result, since concurrent threads return nothing.

**** Thread timeout
$\\\Rule{}{(\textit{os}_1, \textit{pc}_1, \textit{e}_1, \textit{rs}_1, ((\textit{os}_2, \textit{pc}_2, \textit{e}_2).\textit{rs}_2).\textit{tq}, 0) \transition (\textit{os}_2, \textit{pc}_2, \textit{e}_2, \textit{rs}_2, \textit{tq}.((\textit{os}_1, \textit{pc}_1, \textit{e}_1).\textit{rs}_1), c)}\\$
If a thread times out and has not finished execution (has not executed the =RET= statement), then it is enqueued on the thread queue, and the next thread is dequeued from the thread queue, with a constant timeout value $c$.

The above rule assumes there is least one thread in the thread queue. To cover all cases, here is the rule for zero threads in the thread queue:
$\\\Rule{}{(\textit{os}, \textit{pc}, \textit{e}, \textit{rs}, \langle \rangle, 0) \transition (\textit{os}, \textit{pc}, \textit{e}, \textit{rs}, \langle \rangle, c)}\\$

**** Running thread
$\\\Rule{s(\textit{pc}) \neq \texttt{RET} \qquad \textit{to} > 0}{(\textit{os}, \textit{pc}, \textit{e}, \textit{rs}, \textit{tq}, \textit{to}) \transition (\textit{os'}, \textit{pc'}, \textit{e'}, \textit{rs'}, \textit{tq}, \textit{to}-1)}\\$
where the primed values are just like normal VM code execution, and the timeout is initially nonzero, and then decrements.

**** Running thread, returning from function
$\\\Rule{s(\textit{pc}) = \texttt{RET} \qquad \textit{to} > 0 \qquad \textit{rs} \neq \langle \rangle}{(\textit{os}, \textit{pc}, \textit{e}, \textit{rs}, \textit{tq}, \textit{to}) \transition (\textit{os'}, \textit{pc'}, \textit{e'}, \textit{rs'}, \textit{tq}, \textit{to}-1)}\\$
where the primed values are just like normal VM code execution, and the timeout is initially nonzero, and then decrements. Note: the thread may execute the =RET= statement inside a function, and the thread does the normal thing of popping =rs= and so on.

**** Starting =EXECUTE=
$\\\Rule{s(\textit{pc}) = \texttt{EXECUTE n}}{(((\langle \rangle, \textit{pc}_1, \textit{e}_1).\langle \rangle). \cdots .((\langle \rangle, \textit{pc}_n, \textit{e}_n).\langle \rangle).\textit{os}, \textit{pc}, \textit{e}, \textit{rs}, \langle \rangle, 0)}\\$
$\transition (\textit{os}, \textit{pc}, \textit{e}, \textit{rs}, ((\langle \rangle, \textit{pc}_1, \textit{e}_1).\langle \rangle). \cdots .((\langle \rangle, \textit{pc}_n, \textit{e}_n).\langle \rangle), 0)\\$

Thread $i$ is a four-tuple of each thread $i$'s own $\textit{os}_i$, $\textit{pc}_i$, $\textit{e}_i$, and $\textit{rs}_i$. The thread that calls =concurrent_execute= also continues to execute concurrently with the other threads. Initially, thread $i$ has empty $\textit{os}_i$ and empty $\textit{rs}_i$.

**** Returning from thread
$\\\Rule{s(\textit{pc}_1) = \texttt{RET} \qquad \textit{to} > 0 \qquad \textit{rs}_1 = \langle \rangle}{(\textit{os}_1, \textit{pc}_1, \textit{e}_1, \textit{rs}_1, ((\textit{os}_2, \textit{pc}_2, \textit{e}_2).\textit{rs}_2).\textit{tq}, 0) \transition (\textit{os}_2, \textit{pc}_2, \textit{e}_2, \textit{rs}_2, \textit{tq}, c)}\\$
If a thread executes the =RET= statement, and the runtime stack is empty, then the thread is not enqueued on the thread queue, and the next thread is dequeued from the thread queue, with a constant timeout value $c$.

The above rule assumes there is least one thread in the thread queue. To cover all cases, the rule for zero threads in the thread queue is in the next subsection:

**** Ending our VM
$\\\Rule{s(\textit{pc}) = \texttt{RET} \qquad \textit{to} > 0 \qquad \textit{rs} = \langle \rangle \qquad \textit{tq} = \langle \rangle}{(v.\textit{os}, \textit{pc}, \textit{e}, \textit{rs}, \textit{tq}, \textit{to}) \transition (v.\textit{os}, \textit{pc}, \textit{e}, \textit{rs}, \textit{tq}, \textit{to}-1)}\\$
If a thread executes the =RET= statement, and both the runtime stack and the thread queue are empty, and the timeout is nonzero, then the timeout decrements, the thread executing the =RET= statement is not enqueued on the thread queue, and our VM stops and returns the top of $\textit{os}$, which is $v$.

** =TEST_AND_SET= and =CLEAR= Rules

*** Notes
- For simplicity, all registers and heap are not represented in the rules, except $\textit{os}$ and $\textit{pc}$.
- =test_and_set= is an atomic operation.

*** Compiling
$\Rule{E \translateaux s}{\texttt{test\_and\_set}(E) \translateaux s.\texttt{TEST\_AND\_SET}}\\$
where $E$ is an array, whose head is a boolean.

$\Rule{E \translateaux s}{\texttt{clear}(E) \translateaux s.\texttt{CLEAR}}\\$
where $E$ is an array.

*** Running
$\Rule{s(\textit{pc}) = \texttt{TEST\_AND\_SET}}{(a.\textit{os},\textit{pc}) \transition (b.\textit{os},\textit{pc} + 1)}\\$
where $a$ is the address of an array stored on the heap. The head of this array is initially $b$, where $b$ is a boolean. After this rule executes, the head of this array is set to $\textit{true}$.

$\Rule{s(\textit{pc}) = \texttt{CLEAR}}{(a.\textit{os},\textit{pc}) \transition (\textit{os},\textit{pc} + 1)}\\$
where $a$ is the address of an array stored on the heap. The head of this array is updated to $\textit{false}$.

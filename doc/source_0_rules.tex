\section*{Reduction}

A \emph{thunk} is a pair whose first component is a program
and whose
second component is an environment, and an
\emph{environment} is a mapping from names to programs, all of which are
function declarations. The environment extension operation
$E [ n \leftarrow f]$ returns an environment that is extended by
a new binding: $E[n \leftarrow f](m) = f$ if $n = m$ and
$E[n \leftarrow f](m) = E(m)$ otherwise.

The \emph{reducer} $\Rightarrow$ is a partial function from thunks to thunks,
and $\Rightarrow^*$ is its reflexive transitive closure.
A \emph{reduction} is a sequence of thunks
$t_1 \Rightarrow^* t_n$, where $t_n$ is not reducible, i.e. there is no thunk
s such that $t_n \Rightarrow s$.

The result of evaluating a given program $p$ is a program $p'$
such that $(p, \emptyset) \Rightarrow^* (p', E)$ is a reduction,
where $\emptyset$ is the empty environment.

A \emph{value} is a primitive number expresssion, primitive boolean expression,
or a primitive string expression.

The \emph{substitution} function
$p [ n \leftarrow v ]$ replaces every free occurrence of the name $n$
in statement or expression $p$ by value $v$.

\subsection*{How to read inference rules}

To read the rules below, think of each "fraction" as an
"if we know X then we can infer Y" implication statement.
For example,

\[
\frac{
  X = 5
}{
  X + 1 = 5 + 1
}
\]

corresponds to the statement
"If we know $X$ is equal to $5$,
then we can infer that $X + 1$ is equal to $5 + 1$".

\subsection*{Statement sequences}


\textbf{First-statement}: In a sequence of statements, only reduce the first
one.
\[
\frac{
  (\textit{statement},E) \Rightarrow (\textit{statement}',E)
}{
  (\textit{statement} \ldots, E)
  \Rightarrow
  (\textit{statement}' \ldots, E)
}
\]

\vspace{10mm}

\textbf{Eliminate-function-declaration}: Function declarations as first
statements are moved to the environment.
\[
\frac{
             f = \textbf{\texttt{function}}\  \textit{name}
                 \ \textbf{\texttt{(}}\  \textit{parameters}
                 \ \textbf{\texttt{)}}\ \textit{block}
}{
( f\ \textit{statement} \ldots, E)
  \Rightarrow
  ( \textit{statement} \ldots, E[\textit{name} \leftarrow f])
}
\]

\vspace{10mm}
\textbf{Eliminate-Values}: Values as first statemments are discarded, if
they are preceding one or more statements in a statement sequence.
\[
\frac{
v \ \mbox{is a value}
}{
(v \textbf{\texttt{;}} \textit{statement}+, E)
   \Rightarrow
  ( \textit{statement}+, E)
}
\]

\subsection*{Statements}

\textbf{Expression-statement-reduce}: An expression statement
is reducible if its expression is reducible.
\[
\frac{
  (e,E) \Rightarrow (e',E)
}{
  (e \textbf{\texttt{;}}, E)
  \Rightarrow
  (e' \textbf{\texttt{;}}, E)
}
\]

\subsection*{Expressions: Binary operators}

\textbf{Left-binary-reduce}: An expression with binary operator
can be reduced if its left sub-expression can be reduced.
\[
\frac{
  ( e_1 , E ) \Rightarrow (e_1', E)
}{
  (e_1\  \textit{binary-operator} \ e_2, E)
  \Rightarrow
  (e_1'\  \textit{binary-operator} \ e_2, E)
}
\]


\vspace{10mm}
\textbf{And-shortcut-false}: An expression with binary operator
$\textbf{\texttt{\&\&}}$ whose left sub-expression is
$\textbf{\texttt{false}}$ can be reduced to
$\textbf{\texttt{false}}$.
\[
\frac{
}{
  (\textbf{\texttt{false}}\  \textbf{\texttt{\&\&}}\ e, E)
  \Rightarrow
  (\textbf{\texttt{false}}, E)
}
\]

\vspace{10mm}
\textbf{And-shortcut-true}: An expression with binary operator
$\textbf{\texttt{\&\&}}$ whose left sub-expression is
$\textbf{\texttt{true}}$ can be reduced to
the right sub-expression.
\[
\frac{
}{
  (\textbf{\texttt{true}}\  \textbf{\texttt{\&\&}}\ e, E)
  \Rightarrow
  (e, E)
}
\]

\vspace{10mm}
\textbf{Or-shortcut-true}: An expression with binary operator
$\textbf{\texttt{||}}$ whose left sub-expression is
$\textbf{\texttt{true}}$ can be reduced to
$\textbf{\texttt{true}}$.
\[
\frac{
}{
  (\textbf{\texttt{true}}\  \textbf{\texttt{||}}\ e, E)
  \Rightarrow
  (\textbf{\texttt{true}}, E)
}
\]

\vspace{10mm}
\textbf{Or-shortcut-false}: An expression with binary operator
$\textbf{\texttt{||}}$ whose left sub-expression is
$\textbf{\texttt{false}}$ can be reduced to
the right sub-expression.
\[
\frac{
}{
  (\textbf{\texttt{false}}\  \textbf{\texttt{||}}\ e, E)
  \Rightarrow
  (e, E)
}
\]


\vspace{10mm}
\textbf{Right-binary-reduce}: An expression with binary operator
can be reduced if its left sub-expression is a value and its right
sub-expression can be reduced.
\[
\frac{
  ( e_2 , E ) \Rightarrow (e_2', E), \textrm{and}\ \textit{binary-operator}
  \ \mbox{is not}\ \textbf{\texttt{\&\&}}\ \textrm{or}\ \texttt{\textbf{||}}
}{
  (v\  \textit{binary-operator} \ e_2, E)
  \Rightarrow
  (v\  \textit{binary-operator} \ e_2', E)
}
\]

\vspace{10mm}
\textbf{Prim-binary-reduce}: An expression with binary operator
can be reduced if its left and right sub-expressions are values and
the corresponding function is defined for those values.
\[
\frac{
  v\ \mbox{is result of}\ v_1\  \textit{binary-operator} \ v_2
}{
  (v_1\  \textit{binary-operator} \ v_2, E)
  \Rightarrow
  (v, E)
}
\]

\subsection*{Expressions: Unary operators}

\textbf{Unary-reduce}: An expression with unary operator
can be reduced if its sub-expression can be reduced.
\[
\frac{
  ( e , E ) \Rightarrow (e', E)
}{
  (\textit{unary-operator} \ e, E)
  \Rightarrow
  (\textit{unary-operator} \ e', E)
}
\]

\vspace{10mm}
\textbf{Prim-unary-reduce}: An expression with unary operator
can be reduced if its left and right sub-expressions are values and
the corresponding function is defined for that value.
\[
\frac{
  v'\ \mbox{is result of}\ \textit{unary-operator} \ v
}{
  (\textit{unary-operator} \ v, E)
  \Rightarrow
  (v', E)
}
\]

\subsection*{Expressions: conditionals}

\textbf{Conditional-predicate-reduce}: A conditional
expression
can be reduced if its predicate can be reduced.
\[
\frac{
  ( e_1 , E ) \Rightarrow (e_1', E)
}{
  (e_1\  \textbf{\texttt{?}}\ e_2\ \textbf{\texttt{:}}\ e_3, E)
  \Rightarrow
  (e_1'\ \textbf{\texttt{?}}\ e_2\ \textbf{\texttt{:}}\ e_3, E)
}
\]

\vspace{10mm}
\textbf{Conditional-true-reduce}: A conditional
expression whose predicate is the value
$\textbf{\texttt{true}}$
can be reduced to its consequent expression.
\[
\frac{
}{
  (\textbf{\texttt{true}}\  \textbf{\texttt{?}}\ e_1\ \textbf{\texttt{:}}\ e_2, E)
  \Rightarrow
  (e_1, E)
}
\]

\vspace{10mm}
\textbf{Conditional-false-reduce}: A conditional
expression whose predicate is the value
$\textbf{\texttt{false}}$
can be reduced to its alternative expression.
\[
\frac{
}{
  (\textbf{\texttt{false}}\  \textbf{\texttt{?}}\ e_1\ \textbf{\texttt{:}}\ e_2, E)
  \Rightarrow
  (e_2, E)
}
\]


\subsection*{Expressions: function application}

\textbf{Application-functor-reduce}: A function application
can be reduced if its functor expression can be reduced.
\[
\frac{
  ( e , E ) \Rightarrow (e', E)
}{
  (e\  \textbf{\texttt{(}}\ \textit{expressions} \ \textbf{\texttt{)}}, E)
  \Rightarrow
  (e'\  \textbf{\texttt{(}}\ \textit{expressions} \ \textbf{\texttt{)}}, E)
}
\]

\vspace{10mm}
\textbf{Application-argument-reduce}: A function application
can be reduced if one of its argument expressions can be reduced and all
preceding arguments are values or names, denoted by $w$.
\[
\frac{
  ( e_i , E ) \Rightarrow (e_i', E)
}{
  (w\  \textbf{\texttt{(}}\ w \ldots e_i \ e \ldots\ \textbf{\texttt{)}}, E)
  \Rightarrow
  (w\  \textbf{\texttt{(}}\ w \ldots e_i' \ e \ldots\ \textbf{\texttt{)}}, E)
}
\]

\vspace{10mm}
\textbf{Application-reduce}: A function application
can be reduced if the functor is a name that refers to
a function declaration in the environment, and if all
arguments are values or names, denoted by $w$. If an argument
is a name, it must refer to a function declaration in the
environment.
\[
\frac{
  E[n] = \textbf{\texttt{function}}\  \textit{n}
                 \ \textbf{\texttt{(}}\  x_1 \ldots x_n
                 \ \textbf{\texttt{)}}\ \textbf{\texttt{\{}}\ \textbf{\texttt{return}}\ e \textbf{\texttt{;}} \textbf{\texttt{\}}}
\mbox{, and all names in $w_1 \ldots w_n$ have a binding in $E$}
}{
  (n\  \textbf{\texttt{(}}\ w_1 \ldots w_n\ \textbf{\texttt{)}}, E)
  \Rightarrow
  (e[x_1 \leftarrow w_1]\ldots[x_n \leftarrow w_n], E)
}
\]

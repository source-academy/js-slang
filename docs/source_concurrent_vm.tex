% Created 2020-03-17 Tue 16:07
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\newcommand{\qed}{$\Box$}
\newcommand{\Rule}[2]{\genfrac{}{}{0.7pt}{}{{\setlength{\fboxrule}{0pt}\setlength{\fboxsep}{3mm}\fbox{$#1$}}}{{\setlength{\fboxrule}{0pt}\setlength{\fboxsep}{3mm}\fbox{$#2$}}}}
\newcommand{\Rulee}[3]{\genfrac{}{}{0.7pt}{}{{\setlength{\fboxrule}{0pt}\setlength{\fboxsep}{3mm}\fbox{$#1$}}}{{\setlength{\fboxrule}{0pt}\setlength{\fboxsep}{3mm}\fbox{$#2$}}}[#3]}
\newcommand{\transition}{\rightrightarrows_s}
\newcommand{\translate}{\twoheadrightarrow}
\newcommand{\translateaux}{\hookrightarrow}
\author{koo}
\date{\today}
\title{}
\hypersetup{
 pdfauthor={koo},
 pdftitle={},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.3 (Org mode 9.2.6)},
 pdflang={English}}
\begin{document}


\section{Specification of Concurrent Virtual Machine}
\label{sec:orgc6ebafc}
Compared to Source \(\S 3\), this concurrent system has the following changes:
\begin{itemize}
\item The addition of three primitive concurrent functions.
\end{itemize}
For details, see Section ``Concurrency Support'' below.

\subsection{Overview}
\label{sec:orgf0735e6}
This concurrent system consists of concurrently executing (potentially multiple) code in multiple threads. Communication between threads is achieved by updating the values of memory shared between threads. Each thread is a nullary function, so the concurrent system executes each thread by running the code in the body of the nullary function.

The design of this system is inspired by \href{https://doi.org/10.1007/978-1-4757-3472-0\_2}{Dijkstra's \texttt{cobegin} / \texttt{coend} constructs}, of which a good overview and comparison with \texttt{fork} / \texttt{join} can be found in section 7.2.2 of \href{https://doi.org/10.1145/359576.359585}{Hoare's Communicating Sequential Processes}.

However, this design departs from Dijkstra's constructs, as the system does not execute parallel threads. Instead, it executes concurrent threads.

\subsection{Concurrency Support}
\label{sec:orga25444d}
The following concurrent functions are supported:
\begin{itemize}
\item \(\texttt{concurrent\_execute}(f_1, \cdots ,f_n)\): \textit{primitive}, executes multiple threads concurrently. Each \(f_1, \cdots ,f_n\) is a nullary function, and each thread is executed by running the code in the body of the nullary function. Returns \(\texttt{undefined}\).
\item \(\texttt{test\_and\_set}(a)\): \textit{primitive}, assumes the head of array \(a\) is a boolean \(b\). Sets the head of \(a\) to \(\texttt{true}\). Returns \(b\).
\item \(\texttt{clear}(a)\): \textit{primitive}, sets the head of array \(a\) to \(\texttt{false}\). Returns \(\texttt{undefined}\).
\end{itemize}

\subsection{\(\texttt{EXECUTE}\) Rules}
\label{sec:orga76ff96}

\subsubsection{Notes}
\label{sec:org406dee3}
\begin{itemize}
\item For simplicity, heap is not represented in the rules.
\item \(g\) represents garbage value: its value is not important to the rule.
\end{itemize}

\subsubsection{Compiling}
\label{sec:org536d6c2}
\(\Rule{E_1 \translateaux s_1 \qquad \cdots \qquad E_n \translateaux s_n}{\texttt{concurrent\_execute}(E_1, \cdots , E_n) \translateaux s_1. \cdots .s_n.\texttt{EXECUTE n}}\\\)
Each of \(s_1. \cdots .s_n\) is a string of VM instruction that loads a closure onto the operand stack.

\subsubsection{Running}
\label{sec:org729f4ea}
There are additional structures in our VM:
\begin{enumerate}
\item \(\textit{tq}\), a register which is a queue of thread suspensions.
\item \(\textit{to}\), a register initialized with \(0\), that indicates how many instructions are left for a thread to run.
\item \(\textit{seq}\), a register initialized with \(\langle \rangle\), that represents an empty sequential runtime stack. When entering the concurrent context, \(\textit{os}\), \(\textit{pc}\), \(\textit{e}\), and \(\textit{rs}\) are copied onto \(\textit{seq}\), and when exiting the concurrent context, they are popped from \(\textit{seq}\).
\end{enumerate}
The tuple representing our VM will have three more corresponding structures:
\((\textit{os}, \textit{pc}, \textit{e}, \textit{rs}, \textit{tq}, \textit{to}, \textit{seq})\\\)

\paragraph{Starting \(\texttt{EXECUTE}\), loading thread frames into register \(\textit{tq}\)}
\label{sec:orgdf43f47}
\(\\\Rule{s(\textit{pc}) = \texttt{EXECUTE n}}{(\textit{os}, \textit{pc}, \textit{e}, \textit{rs}, \langle \rangle, 0, \langle \rangle) \transition (g, \langle \rangle, g, g, ((\langle \rangle, \textit{pc}_1, \textit{e}_1).\langle \rangle). \cdots .((\langle \rangle, \textit{pc}_n, \textit{e}_n).\langle \rangle), 0, (\textit{os}, \textit{pc}, \textit{e}).\textit{rs})}\\\)
Each thread is a four-tuple of \(\textit{os}\), \(\textit{pc}\), \(\textit{e}\), and \(\textit{rs}\). Initially, threads have empty \(\textit{os}\) and empty \(\textit{rs}\). Note the transition from empty \(\textit{seq}\) to nonempty \(\textit{seq}\): this disambiguates concurrent execution rules from sequential execution rules, so that we know we are executing in the concurrent context.

\paragraph{Beginning thread execution}
\label{sec:orgc7b21eb}
\(\\\Rule{}{(g, \langle \rangle, g, g, ((\textit{os}, \textit{pc}, \textit{e}).\textit{trs}).\textit{tq}, 0, \textit{seq}) \transition (\textit{os}, \textit{pc}, \textit{e}, \textit{rs}, \textit{tq}, c, \textit{seq})}\\\)
where \(c\) is a constant timeout value. Note: \(\textit{pc}\) is \(\langle \rangle\) to disambiguate this rule from the thread timeout rule.

\paragraph{Running thread}
\label{sec:org755c72f}
\(\\\Rule{s(\textit{pc}) \neq \texttt{RET} \qquad \textit{to} \ge 0}{(\textit{os}, \textit{pc}, \textit{e}, \textit{trs}, \textit{tq}, \textit{to}, \textit{seq}) \transition (\textit{os'}, \textit{pc'}, \textit{e'}, \textit{trs'}, \textit{tq}, \textit{to}-1, \textit{seq})}\\\)
where the primed values are just like normal VM code execution.

\paragraph{Running thread, returning from function}
\label{sec:orgcacd3c5}
\(\\\Rule{s(\textit{pc}) = \texttt{RET} \qquad \textit{to} \ge 0 \qquad \textit{trs} \neq \langle \rangle}{(\textit{os}, \textit{pc}, \textit{e}, \textit{trs}, \textit{tq}, \textit{to}, \textit{seq}) \transition (\textit{os'}, \textit{pc'}, \textit{e'}, \textit{trs'}, \textit{tq}, \textit{to}-1, \textit{seq})}\\\)
where the primed values are just like normal VM code execution. Note: the thread may execute the \texttt{RET} statement inside a function, and the thread does the normal thing of popping \texttt{trs} and so on.

\paragraph{Thread timeout}
\label{sec:org2a45ce5}
\(\\\Rule{}{(\textit{os}, \textit{pc}, \textit{e}, \textit{trs}, \textit{tq}, 0, \textit{seq}) \transition (g, \langle \rangle, g, g, \textit{tq}.((\textit{os}, \textit{pc}, \textit{e}).\textit{trs}), 0, \textit{seq})}\\\)
When a thread times out and has not finished execution (has not executed the \texttt{RET} statement), then it is queued on the thread queue.

\paragraph{Returning from thread}
\label{sec:org469c5b0}
\(\\\Rule{s(\textit{pc}) = \texttt{RET} \qquad \textit{to} \ge 0 \qquad \textit{trs} = \langle \rangle}{(\textit{os}, \textit{pc}, \textit{e}, \textit{rs}, \langle \rangle, 0, \langle \rangle) \transition (g, \langle \rangle, g, g, \textit{tq}, 0, \textit{seq})}\\\)
When a thread executes the \(\texttt{RET}\) statement, and there are no more thread runtime stacks, the thread is not added back to the thread queue,

\paragraph{Ending \(\texttt{EXECUTE}\)}
\label{sec:org69772e4}
\(\\\Rule{}{(g, \langle \rangle, g, g, \langle \rangle, 0, (\textit{os}, \textit{pc}, \textit{e}).\textit{rs}) \transition (\textit{os}, \textit{pc}, \textit{e}, \textit{rs}, \langle \rangle, 0, \langle \rangle)}\\\)
When the thread queue is empty, we restore normal sequential execution.

\subsection{\(\texttt{TEST\_AND\_SET}\) and \(\texttt{CLEAR}\) Rules}
\label{sec:org5eec42e}

\subsubsection{Notes}
\label{sec:orgf230dca}
\begin{itemize}
\item For simplicity, all registers and heap are not represented in the rules, except \(\textit{os} and \textit{pc}\).
\item \(\textit{test\_and\_set}\) is an atomic operation.
\end{itemize}

\subsubsection{Compiling}
\label{sec:org8e554eb}
\(\Rule{E \translateaux s}{\texttt{test\_and\_set}(E) \translateaux s.\texttt{TEST\_AND\_SET}}\\\)
where \(E\) is an array, whose head is a boolean.

\(\Rule{E \translateaux s}{\texttt{clear}(E) \translateaux s.\texttt{CLEAR}}\\\)
where \(E\) is an array.

\subsubsection{Running}
\label{sec:orgdf23403}
\(\Rule{s(\textit{pc}) = \texttt{TEST\_AND\_SET}}{(a.\textit{os},\textit{pc}) \transition (b.\textit{os},\textit{pc} + 1)}\\\)
where \(a\) is the address of an array stored on the heap. The head of this list is initially \(b\), where \(b\) is a boolean. After this rule executes, the head of this list is set to \(\textit{true}\).

\(\Rule{s(\textit{pc}) = \texttt{CLEAR}}{(a.\textit{os},\textit{pc}) \transition (\textit{os},\textit{pc} + 1)}\\\)
where \(a\) is the address of an array stored on the heap. The head of this list is updated to \(\textit{false}\).
\end{document}
\newcommand{\Rule}[2]{\genfrac{}{}{0.7pt}{}{{\setlength{\fboxrule}{0pt}\setlength{\fboxsep}{3mm}\fbox{$#1$}}}{{\setlength{\fboxrule}{0pt}\setlength{\fboxsep}{3mm}\fbox{$#2$}}}}

\newcommand{\TruE}{\textbf{\texttt{true}}}
\newcommand{\FalsE}{\textbf{\texttt{false}}}
\newcommand{\AndOp}{\texttt{\&\&}}
\newcommand{\OrOp}{\texttt{||}}
\newcommand{\ThenOp}{\texttt{?}}
\newcommand{\ElseOp}{\texttt{:}}
\newcommand{\Rc}{\texttt{\}}}
\newcommand{\Lc}{\texttt{\{}}
\newcommand{\Rp}{\texttt{)}}
\newcommand{\Lp}{\texttt{(}}
\newcommand{\Fun}{\textbf{\texttt{function}}}
\newcommand{\Let}{\textbf{\texttt{let}}}
\newcommand{\Return}{\textbf{\texttt{return}}}
\newcommand{\Const}{\textbf{\texttt{const}}}
\newcommand{\If}{\textbf{\texttt{if}}}
\newcommand{\Else}{\textbf{\texttt{else}}}
\newcommand{\Bool}{\texttt{boolean}}
\newcommand{\Number}{\texttt{number}}
\newcommand{\String}{\texttt{string}}
\newcommand{\Undefined}{\texttt{undefined}}
\newcommand{\Any}{\texttt{any}}
\newcommand{\Void}{\texttt{void}}
\newcommand{\Pred}{\textit{Pred}}
\newcommand{\type}{\textit{type}}
\newcommand{\polytype}{\textit{polytype}}
\newcommand{\predtype}{\textit{predtype}}
\newcommand{\ExtractPos}{\ensuremath{\textit{Extract}^+}}
\newcommand{\ExtractNeg}{\ensuremath{\textit{Extract}^-}}

\newtheorem{definition}{Definition}[section]

\section{Type System}  

In Source \S 1 Typed, the Source \S 1 syntax is expanded to include type syntax such as type annotations and type aliases.
This allows names to be explicitly typed, and for type checks to be performed.

Support for \texttt{typeof} operations is also added to Source \S 1 Typed.

\subsection{Types}

The following types are introduced in Source \S 1 Typed:

\noindent
\[
\Rule{}{\Number\ \type}
\qquad
\Rule{}{\Bool\ \type}
\qquad
\Rule{}{\String\ \type}
\qquad
\Rule{}{\Undefined\ \type}
\]
\noindent
\[
\Rule{}{\Void\ \type}
\qquad
\Rule{}{\Any\ \type}
\qquad
\Rule{}{\textit{literal}\ \type}
\]
\noindent
\[
\Rule{t_1\ \type \quad \cdots\quad t_n\ \type\quad t\ \type}{(t_1, \ldots t_n) \rightarrow t\ \type\ (\textit{function type})}
\qquad
\Rule{t_1\ \type \quad \cdots\quad t_n\ \type}{t_1\ |\ \ldots\ |\ t_n\ \type\ (\textit{union type})}
\]

\noindent
where $n \geq 1$. The symbols $t_i$ in the rules above are meta-variables that stand for types.

The $\Number$, $\Bool$, $\String$ and $\Undefined$ types are introduced for each of
the primitive expressions available in Source \S 1. Additionally, two special types are introduced:
the $\Void$ type is used specifically to indicate the return type of a function that does not return,
while the $\Any$ type is used to annotate names that can take on any type (type-checking for such names will be skipped).
These six types are collectively known as \emph{basic types}.

Literal types are types for specific number, boolean or string values
(e.g. \texttt{1}, \texttt{true}, \texttt{'2'}).

Function types are used to indicate the argument type(s) as well as return type of a function,
while union types are used to indicate a combination of types.

\subsection{Type Syntax}

Source \S 1 Typed supports the following type syntax:

\begin{itemize}
\item Type annotations: Used to explicitly assign a type to a name. Type annotations are optional;
names that are declared without accompanying type annotations are assumed to be of the $\Any$ type during typechecking.
\item Type alias declarations: Used to declare new types on top of the basic types,
which can then be used in the rest of the program. Note that names for types are independent of names for variables and functions;
a type and a variable with the same name can coexist in the same program.
\item As expressions: Used to cast the type of a name to a subset of its original type.
\end{itemize}

\subsection{Type Environment}

In order to keep track of the type of names in a program, we define a
\emph{type environment}, denoted by $\Gamma$. More
formally,
the partial function $\Gamma$ from names to types expresses a 
context, in which a name $x$ is associated with type $\Gamma(x)$. 

We define a relation $\Gamma[x \leftarrow t]\Gamma'$ on type environments 
$\Gamma$, names $x$, types $t$, and type environments $\Gamma'$,
which constructs a type environment that behaves like the 
given one, except that the type of $x$ is $t$. More formally, 
if $\Gamma[x \leftarrow t]\Gamma'$, then $\Gamma'(y)$ is $t$, 
if $y=x$ and $\Gamma(y)$ 
otherwise. Obviously, this uniquely identifies $\Gamma'$ for
a given $\Gamma$, $x$, and $t$, and thus the type environment extension
relation is functional in its first three arguments.

The set of names, on which a type environment
$\Gamma$ is defined, is called the domain of $\Gamma$, 
denoted by $\textit{dom}(\Gamma)$.

For each non-overloaded primitive operator, we add a binding to our initial
type environment $\Gamma_0$ as follows:

\begin{eqnarray*}
& &
       \emptyset[ -_2 \leftarrow  (\Number, \Number) \rightarrow \Number]\\
&& \hspace{2mm} [ * \leftarrow  (\Number, \Number) \rightarrow \Number]\\
&& \hspace{2mm} [ / \leftarrow  (\Number, \Number) \rightarrow \Number]\\
&& \hspace{2mm} [ \% \leftarrow (\Number, \Number) \rightarrow \Number]\\
&& \hspace{2mm} [ \&\& \leftarrow (\Bool, \texttt{T}) \rightarrow \Bool\ |\ \texttt{T}]\\
&& \hspace{2mm} [ || \leftarrow   (\Bool, \texttt{T}) \rightarrow \Bool\ |\ \texttt{T}]\\
&& \hspace{2mm} [ ! \leftarrow \Bool \rightarrow \Bool]\\
&& \hspace{2mm} [ -_1 \leftarrow \Number \rightarrow \Number]\\
&& \hspace{2mm} [ \texttt{typeof} \leftarrow \Any \rightarrow \String]\Gamma_{-2}
\end{eqnarray*}

The overloaded binary primitives are handled as follows:

\begin{eqnarray*}
 & &
      \Gamma_{-2}
                 [ \texttt{+} \leftarrow (\String,\ \String) \rightarrow \String\ |\ (\Number,\ \Number) \rightarrow \Number] \\
&& \hspace{6mm}  [ \texttt{===} \leftarrow (\String,\ \String) \rightarrow \Bool\ |\ (\Number,\ \Number) \rightarrow \Bool] \\
&& \hspace{6mm}  [ \texttt{!==} \leftarrow (\String,\ \String) \rightarrow \Bool\ |\ (\Number,\ \Number) \rightarrow \Bool] \\
&& \hspace{6mm}  [ \texttt{>} \leftarrow (\String,\ \String) \rightarrow \Bool\ |\ (\Number,\ \Number) \rightarrow \Bool]\\
&& \hspace{6mm}  [ \texttt{>=} \leftarrow (\String,\ \String) \rightarrow \Bool\ |\ (\Number,\ \Number) \rightarrow \Bool]\\
&& \hspace{6mm}  [ \texttt{<} \leftarrow (\String,\ \String) \rightarrow \Bool\ |\ (\Number,\ \Number) \rightarrow \Bool] \\
&& \hspace{6mm}  [ \texttt{<=} \leftarrow (\String,\ \String) \rightarrow \Bool\ |\ (\Number,\ \Number) \rightarrow \Bool]\Gamma_{-1}
\end{eqnarray*}

The Source \S 1 standard library functions and constants have their types defined as follows:

\begin{tabular}[fragile]{lllllllll}
$\Gamma_{-1}$
& $[$ & \texttt{display}      & $\leftarrow$  & $\Any$ & & & $]$ \\
& $[$ & \texttt{error}      & $\leftarrow$  & $\Any$ & & & $]$ \\
& $[$ & \texttt{Infinity}      & $\leftarrow$  & $\Number$ & & & $]$ \\
& $[$ & \texttt{is\_boolean}   & $\leftarrow$  & $\Any$ & $\rightarrow$ & $\Bool$ & $]$ \\
& $[$ & \texttt{is\_function}  & $\leftarrow$  & $\Any$ & $\rightarrow$ & $\Bool$ & $]$ \\
& $[$ & \texttt{is\_number}    & $\leftarrow$  & $\Any$ & $\rightarrow$ & $\Bool$ & $]$ \\
& $[$ & \texttt{is\_string}    & $\leftarrow$  & $\Any$ & $\rightarrow$ & $\Bool$ & $]$ \\
& $[$ & \texttt{is\_undefined} & $\leftarrow$  & $\Any$ & $\rightarrow$ & $\Bool$ & $]$ \\
& $[$ & \texttt{math\_abs} & $\leftarrow$  & $\Number$ & $\rightarrow$ & $\Number$ & $]$ \\
& $[$ & \texttt{math\_acos} & $\leftarrow$  & $\Number$ & $\rightarrow$ & $\Number$ & $]$ \\
& $[$ & \texttt{math\_acosh} & $\leftarrow$  & $\Number$ & $\rightarrow$ & $\Number$ & $]$ \\
& $[$ & \texttt{math\_asin} & $\leftarrow$  & $\Number$ & $\rightarrow$ & $\Number$ & $]$ \\
& $[$ & \texttt{math\_asinh} & $\leftarrow$  & $\Number$ & $\rightarrow$ & $\Number$ & $]$ \\
& $[$ & \texttt{math\_atan} & $\leftarrow$  & $\Number$ & $\rightarrow$ & $\Number$ & $]$ \\
& $[$ & \texttt{math\_atan2} & $\leftarrow$  & $(\Number, \Number)$ & $\rightarrow$ & $\Number$ & $]$ \\
& $[$ & \texttt{math\_atanh} & $\leftarrow$  & $\Number$ & $\rightarrow$ & $\Number$ & $]$ \\
& $[$ & \texttt{math\_cbrt} & $\leftarrow$  & $\Number$ & $\rightarrow$ & $\Number$ & $]$ \\
& $[$ & \texttt{math\_ceil} & $\leftarrow$  & $\Number$ & $\rightarrow$ & $\Number$ & $]$ \\
& $[$ & \texttt{math\_clz32} & $\leftarrow$  & $\Number$ & $\rightarrow$ & $\Number$ & $]$ \\
& $[$ & \texttt{math\_cos} & $\leftarrow$  & $\Number$ & $\rightarrow$ & $\Number$ & $]$ \\
& $[$ & \texttt{math\_cosh} & $\leftarrow$  & $\Number$ & $\rightarrow$ & $\Number$ & $]$ \\
& $[$ & \texttt{math\_exp} & $\leftarrow$  & $\Number$ & $\rightarrow$ & $\Number$ & $]$ \\
& $[$ & \texttt{math\_expm1} & $\leftarrow$  & $\Number$ & $\rightarrow$ & $\Number$ & $]$ \\
& $[$ & \texttt{math\_floor} & $\leftarrow$  & $\Number$ & $\rightarrow$ & $\Number$ & $]$ \\
& $[$ & \texttt{math\_fround} & $\leftarrow$  & $\Number$ & $\rightarrow$ & $\Number$ & $]$ \\
& $[$ & \texttt{math\_hypot} & $\leftarrow$  & $\Any$ & & & $]$ \\
& $[$ & \texttt{math\_imul} & $\leftarrow$  & $(\Number, \Number)$ & $\rightarrow$ & $\Number$ & $]$ \\
& $[$ & \texttt{math\_LN2} & $\leftarrow$  & $\Number$ & & & $]$ \\
& $[$ & \texttt{math\_LN10} & $\leftarrow$  & $\Number$ & & & $]$ \\
& $[$ & \texttt{math\_log} & $\leftarrow$  & $\Number$ & $\rightarrow$ & $\Number$ & $]$ \\
& $[$ & \texttt{math\_log1p} & $\leftarrow$  & $\Number$ & $\rightarrow$ & $\Number$ & $]$ \\
& $[$ & \texttt{math\_log2} & $\leftarrow$  & $\Number$ & $\rightarrow$ & $\Number$ & $]$ \\
& $[$ & \texttt{math\_LOG2E} & $\leftarrow$  & $\Number$ & & & $]$ \\
& $[$ & \texttt{math\_log10} & $\leftarrow$  & $\Number$ & $\rightarrow$ & $\Number$ & $]$ \\
& $[$ & \texttt{math\_LOG10E} & $\leftarrow$  & $\Number$ & & & $]$ \\
& $[$ & \texttt{math\_max} & $\leftarrow$  & $\Any$ & & & $]$ \\
& $[$ & \texttt{math\_min} & $\leftarrow$  & $\Any$ & & & $]$ \\
& $[$ & \texttt{math\_PI} & $\leftarrow$  & $\Number$ & & & $]$ \\
& $[$ & \texttt{math\_pow} & $\leftarrow$  & $(\Number, \Number)$ & $\rightarrow$ & $\Number$ & $]$ \\
& $[$ & \texttt{math\_random} & $\leftarrow$  & $()$ & $\rightarrow$ & $\Number$ & $]$ \\
& $[$ & \texttt{math\_round} & $\leftarrow$  & $\Number$ & $\rightarrow$ & $\Number$ & $]$ \\
& $[$ & \texttt{math\_sign} & $\leftarrow$  & $\Number$ & $\rightarrow$ & $\Number$ & $]$ \\
& $[$ & \texttt{math\_sin} & $\leftarrow$  & $\Number$ & $\rightarrow$ & $\Number$ & $]$ \\
& $[$ & \texttt{math\_sinh} & $\leftarrow$  & $\Number$ & $\rightarrow$ & $\Number$ & $]$ \\
& $[$ & \texttt{math\_sqrt} & $\leftarrow$  & $\Number$ & $\rightarrow$ & $\Number$ & $]$ \\
& $[$ & \texttt{math\_SQRT1\_2} & $\leftarrow$  & $\Number$ & & & $]$ \\
& $[$ & \texttt{math\_SQRT2} & $\leftarrow$  & $\Number$ & & & $]$ \\
& $[$ & \texttt{math\_tan} & $\leftarrow$  & $\Number$ & $\rightarrow$ & $\Number$ & $]$ \\
& $[$ & \texttt{math\_tanh} & $\leftarrow$  & $\Number$ & $\rightarrow$ & $\Number$ & $]$ \\
& $[$ & \texttt{math\_trunc} & $\leftarrow$  & $\Number$ & $\rightarrow$ & $\Number$ & $]$ \\
& $[$ & \texttt{NaN} & $\leftarrow$  & $\Number$ & & & $]$ \\
& $[$ & \texttt{parse\_int} & $\leftarrow$  & $(\String, \Number)$ & $\rightarrow$ & $\Number$ & $]$ \\
& $[$ & \texttt{prompt} & $\leftarrow$  & $\String$ & $\rightarrow$ & $\String$ & $]$ \\
& $[$ & \texttt{get\_time} & $\leftarrow$  & $()$ & $\rightarrow$ & $\Number$ & $]$ \\
& $[$ & \texttt{stringify} & $\leftarrow$  & $\Any$ & $\rightarrow$ & $\String$ & $]$ \\
& $[$ & \texttt{undefined} & $\leftarrow$  & $\Undefined$ & & & $]$ & $\Gamma_0$ \\
& \end{tabular}

\subsection{Subtyping}

In order for type checks to be performed in Source \S 1 Typed, we introduce the notion of subtyping.

\begin{definition}
$t \subseteq t'$ is used to denote that type $t$ is a subtype of type $t'$.
\end{definition}

Subtyping is illustrated using the following type rules:

\noindent
\[
\Rule{}{t \subseteq \Any}
\qquad
\Rule{t'\ \textit{is a basic type} \quad t\ \textit{is a basic type} \quad t' = t}{t' \subseteq t}
\]
\noindent
\[
\Rule{t'\ \textit{is a literal type} \quad t\ \textit{is a basic type} \quad \texttt{typeof}\ t' = t}{t' \subseteq t}
\]
\noindent
\[
\Rule{(\forall 1 \leq i \leq n)(t_i \subseteq t'_i) \quad t' \subseteq t}{(t'_1, \ldots t'_n) \rightarrow t' \subseteq (t_1, \ldots t_n) \rightarrow t}
\qquad
\Rule{(\exists i)(t' \subseteq t_i)}{t'\ \subseteq\ t_1\ |\ \ldots\ |\ t_n}
\]
\noindent

\subsection{Typing Relations}

To perform type checking on the program, typing relations are applied to every statement and expression in the program.

Note that a name that is declared to be of type $t$ will always refer to values of a type $t'$ such that $t' \subseteq t$ at runtime.
Names that do not have a type declared will be assumed to have the $any$ type; the $any$ type will not ever produce any type errors.

\subsubsection{Notation}

In order to simplify the type relations, the following notation is used.

Function declaration statements of the form
%
\[ \Fun\ f \Lp x_1,\cdots, x_n\Rp\ \Lc\ S\ \Rc \]
%
\noindent
are treated as abbreviations for constant declaration statements of the form
%
\[ \Const\ f\ \texttt{=}\ \Lp x_1,\cdots, x_n\Rp\ \texttt{=>}\ \Lc\ S\ \Rc \texttt{;} \]
%
function definitions of the form 
%
\[ \Lp x_1,\cdots, x_n\Rp\ \texttt{=>}\ E \]
%
\noindent
are treated as abbreviations for the following
%
\[ \Lp x_1,\cdots, x_n\Rp\ \texttt{=>}\ \Lc\ \Return\ E\ \texttt{;}\ \Rc \]
%
conditional statements of the form 
\begin{lstlisting}
if (x1) {
    const x = 1;    
} else if (x2) {
    const y = 3;
} else if (x3) {
    const a = 3;
} else {
    const b = 3;
}
\end{lstlisting}
\noindent
are treated as abbreviations for the following
\begin{lstlisting}
if (x1) {
    const x = 1;    
} else {
    if (x2) {
        const y = 3;
    } else {
        if (x3) {
            const a = 3;
        } else {
            const b = 3;
        }
    }
}
\end{lstlisting}

\subsubsection{Typing Relations on Expressions}

The derived type of primitive expressions is their literal type, which is always a subtype of its corresponding basic type.

\noindent
\[
  \Rule{}{\Gamma \vdash n : \textit{literal type}\ n}
  \quad
  \Rule{}{\Gamma \vdash s : \textit{literal type}\ s}
\]
\noindent

where $n$ denotes any literal number and $s$ denotes any literal string.

\noindent
\[
  \Rule{}{\Gamma \vdash \TruE : \textit{literal type}\ \TruE}
  \quad
  \Rule{}{\Gamma \vdash \FalsE : \textit{literal type}\ \FalsE}
\]
\noindent

For all other names, the type must be derived from the type environment.

\noindent
\[
  \Rule{}{\Gamma \vdash x : \Gamma(x)}
\]
\noindent

For function applications (including binary and unary operators), the following two type rules are used, depending on the type of $E_0$.

\noindent
\[
\Rule{\Gamma \vdash E_0 : (t_1, \ldots, t_n) \rightarrow t \quad \Gamma \vdash E_1 : t'_1, \ldots,  \Gamma \vdash E_n : t'_n
  \quad (\forall 1 \leq i \leq n)(t'_i \subseteq t_i \vee t'_i = \Any)}{\Gamma \vdash (E_0\ \Lp \ E_1, \ldots, E_n\ \Rp) : t}
\]
\noindent
\[
  \Rule{\Gamma \vdash E_0 : \Any \quad \Gamma \vdash E_1 : t'_1, \ldots,  \Gamma \vdash E_n : t'_n
  \quad (\forall 1 \leq i \leq n)(t'_i \subseteq \Any)}{\Gamma \vdash (E_0\ \Lp \ E_1, \ldots, E_n\ \Rp) : \Any}
\]

The type of the operator must be a function type with the right number of parameters,
and the type of every argument must be a subtype of the corresponding parameter type of the function type.
If all these conditions are met, the type of the function application is the same
as the return type of the function type that is the type of the operator.
If the type of the operator is $\Any$, the types for the arguments will be checked against $\Any$ and the return type will be $\Any$.

For lambda expressions, we extend $\Gamma$ with the declared types of all the function parameters,
and check the type of the function body against the declared return type.
As type syntax is optional, if type annotations are absent for any of the arguments or the return type, the type is assumed to be $\Any$.
The type of the lambda expression is then the function type with the declared types of the parameters and the return type. 

\noindent
\[
  \Rule{\Gamma, x_1 : t_1, \cdots, x_n : t_n \vdash S : t' \quad t' \subseteq t \vee t' = \Any}{
    \Gamma \vdash ( \Lp  x_1:\ t_1, \ldots, x_n:\ t_n \Rp :\ t\ \texttt{=>}\ \Lc\ S\ \Rc) : (t_1, \ldots, t_n) \rightarrow t}  
\]
\noindent

For as expressions, the type to cast the expression to must be a subtype of the type of the expression.
We impose a special rule that the type must not be cast to $\Any$.

\noindent
\[
  \Rule{\Gamma \vdash E : t' \quad t \subseteq t' \quad t \neq \Any}{\Gamma \vdash (E\ \texttt{as}\ t) : t}  
\]
\noindent

\subsubsection{Typing Relations on Statements}

For constant declarations, the declared type of $x$, $t$, is added to the type environment.
As type syntax is optional, if the type annotation for $x$ absent, the declared type $t$ is assumed to be $\Any$.
The derived type of the expression $E$ must be a subtype of the type declared for name $x$.
The type of the constant declaration statement itself is $\Undefined$.

\[
  \Rule{\Gamma, x : t \vdash E : t' \quad t' \subseteq t \vee t' = \Any}{
    \Gamma \vdash (\texttt{const}\ x \texttt{:}\ t = E\texttt{;}) : \Undefined}
\]

For type alias declarations, the declared type of $x$, $t$, is added to the type environment.
The type of the type alias declaration itself is $\Undefined$.

\[
  \Rule{\Gamma, x : t}{\Gamma \vdash (\texttt{type}\ x = t\texttt{;}) : \Undefined}
\]

The type of a return statement is the type of the expression in the statement,
while the type of an expression statement is $\Undefined$ regardless of the type of the expression in the statement.

\[
  \Rule{\Gamma \vdash E : t}{\Gamma \vdash (\texttt{return}\ E\texttt{;}) : t}
  \quad
  \Rule{\Gamma \vdash E : t}{\Gamma \vdash (E\texttt{;}) : \Undefined}
\]

The type of a block is the type of the last statement in the block. We assume that
whenever there is a return statement or a conditional statement with a return statement within a
sequence, it is the last statement in the sequence.
(One could consider a ``dead code'' error otherwise.)

\[
  \Rule{\Gamma \vdash S_1 : t_1, \ldots, \Gamma \vdash S_n : t_n}{\Gamma \vdash \{S_1, \ldots, S_n\} : t_n}
\]

The type of a conditional statement or if statement is the union of the type of its consequent statement and its alternate statement.
The predicate expression of a conditional statement must be a subtype of a boolean.

\[
  \Rule{\Gamma \vdash S_{pred} : t_{pred} \quad \Gamma \vdash S_{cons} : t_{cons} \quad \Gamma \vdash S_{alt} : t_{alt}
    \quad t_{pred} \subseteq \Bool \vee t_{pred} = \Any}{\Gamma \vdash (\texttt{if}\ (S_{pred})\ \{\ S_{cons}\ \}\
    \texttt{else}\ \{\ S_{alt}\ \}) : t_{cons}\ |\ t_{alt}}
\]
